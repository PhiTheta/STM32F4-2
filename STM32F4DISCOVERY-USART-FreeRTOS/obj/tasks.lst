   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"tasks.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.global	pxCurrentTCB
  20              		.section	.bss.pxCurrentTCB,"aw",%nobits
  21              		.align	2
  24              	pxCurrentTCB:
  25 0000 00000000 		.space	4
  26              		.section	.bss.pxReadyTasksLists,"aw",%nobits
  27              		.align	2
  30              	pxReadyTasksLists:
  31 0000 00000000 		.space	100
  31      00000000 
  31      00000000 
  31      00000000 
  31      00000000 
  32              		.section	.bss.xDelayedTaskList1,"aw",%nobits
  33              		.align	2
  36              	xDelayedTaskList1:
  37 0000 00000000 		.space	20
  37      00000000 
  37      00000000 
  37      00000000 
  37      00000000 
  38              		.section	.bss.xDelayedTaskList2,"aw",%nobits
  39              		.align	2
  42              	xDelayedTaskList2:
  43 0000 00000000 		.space	20
  43      00000000 
  43      00000000 
  43      00000000 
  43      00000000 
  44              		.section	.bss.pxDelayedTaskList,"aw",%nobits
  45              		.align	2
  48              	pxDelayedTaskList:
  49 0000 00000000 		.space	4
  50              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
  51              		.align	2
  54              	pxOverflowDelayedTaskList:
  55 0000 00000000 		.space	4
  56              		.section	.bss.xPendingReadyList,"aw",%nobits
  57              		.align	2
  60              	xPendingReadyList:
  61 0000 00000000 		.space	20
  61      00000000 
  61      00000000 
  61      00000000 
  61      00000000 
  62              		.section	.bss.xTasksWaitingTermination,"aw",%nobits
  63              		.align	2
  66              	xTasksWaitingTermination:
  67 0000 00000000 		.space	20
  67      00000000 
  67      00000000 
  67      00000000 
  67      00000000 
  68              		.section	.bss.uxTasksDeleted,"aw",%nobits
  69              		.align	2
  72              	uxTasksDeleted:
  73 0000 00000000 		.space	4
  74              		.section	.bss.xSuspendedTaskList,"aw",%nobits
  75              		.align	2
  78              	xSuspendedTaskList:
  79 0000 00000000 		.space	20
  79      00000000 
  79      00000000 
  79      00000000 
  79      00000000 
  80              		.section	.bss.xIdleTaskHandle,"aw",%nobits
  81              		.align	2
  84              	xIdleTaskHandle:
  85 0000 00000000 		.space	4
  86              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
  87              		.align	2
  90              	uxCurrentNumberOfTasks:
  91 0000 00000000 		.space	4
  92              		.section	.bss.xTickCount,"aw",%nobits
  93              		.align	2
  96              	xTickCount:
  97 0000 00000000 		.space	4
  98              		.section	.bss.uxTopUsedPriority,"aw",%nobits
  99              		.align	2
 102              	uxTopUsedPriority:
 103 0000 00000000 		.space	4
 104              		.section	.bss.uxTopReadyPriority,"aw",%nobits
 105              		.align	2
 108              	uxTopReadyPriority:
 109 0000 00000000 		.space	4
 110              		.section	.bss.xSchedulerRunning,"aw",%nobits
 111              		.align	2
 114              	xSchedulerRunning:
 115 0000 00000000 		.space	4
 116              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 117              		.align	2
 120              	uxSchedulerSuspended:
 121 0000 00000000 		.space	4
 122              		.section	.bss.uxMissedTicks,"aw",%nobits
 123              		.align	2
 126              	uxMissedTicks:
 127 0000 00000000 		.space	4
 128              		.section	.bss.xMissedYield,"aw",%nobits
 129              		.align	2
 132              	xMissedYield:
 133 0000 00000000 		.space	4
 134              		.section	.bss.xNumOfOverflows,"aw",%nobits
 135              		.align	2
 138              	xNumOfOverflows:
 139 0000 00000000 		.space	4
 140              		.section	.bss.uxTaskNumber,"aw",%nobits
 141              		.align	2
 144              	uxTaskNumber:
 145 0000 00000000 		.space	4
 146              		.section	.data.xNextTaskUnblockTime,"aw",%progbits
 147              		.align	2
 150              	xNextTaskUnblockTime:
 151 0000 FFFFFFFF 		.word	-1
 152              		.section	.bss.pcStatsString,"aw",%nobits
 153              		.align	2
 156              	pcStatsString:
 157 0000 00000000 		.space	50
 157      00000000 
 157      00000000 
 157      00000000 
 157      00000000 
 158 0032 0000     		.section	.bss.ulTaskSwitchedInTime,"aw",%nobits
 159              		.align	2
 162              	ulTaskSwitchedInTime:
 163 0000 00000000 		.space	4
 164              		.section	.text.xTaskGenericCreate,"ax",%progbits
 165              		.align	2
 166              		.global	xTaskGenericCreate
 167              		.thumb
 168              		.thumb_func
 170              	xTaskGenericCreate:
 171              	.LFB110:
 172              		.file 1 "FreeRTOS/Source/tasks.c"
   1:FreeRTOS/Source/tasks.c **** /*
   2:FreeRTOS/Source/tasks.c ****     FreeRTOS V7.0.2 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:FreeRTOS/Source/tasks.c **** 	
   4:FreeRTOS/Source/tasks.c **** 
   5:FreeRTOS/Source/tasks.c ****     ***************************************************************************
   6:FreeRTOS/Source/tasks.c ****      *                                                                       *
   7:FreeRTOS/Source/tasks.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:FreeRTOS/Source/tasks.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:FreeRTOS/Source/tasks.c ****      *    available.                                                         *
  10:FreeRTOS/Source/tasks.c ****      *                                                                       *
  11:FreeRTOS/Source/tasks.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:FreeRTOS/Source/tasks.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:FreeRTOS/Source/tasks.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:FreeRTOS/Source/tasks.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:FreeRTOS/Source/tasks.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:FreeRTOS/Source/tasks.c ****      *    for microcontrollers - completely free of charge!                  *
  17:FreeRTOS/Source/tasks.c ****      *                                                                       *
  18:FreeRTOS/Source/tasks.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:FreeRTOS/Source/tasks.c ****      *                                                                       *
  20:FreeRTOS/Source/tasks.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:FreeRTOS/Source/tasks.c ****      *                                                                       *
  22:FreeRTOS/Source/tasks.c ****     ***************************************************************************
  23:FreeRTOS/Source/tasks.c **** 
  24:FreeRTOS/Source/tasks.c **** 
  25:FreeRTOS/Source/tasks.c ****     This file is part of the FreeRTOS distribution.
  26:FreeRTOS/Source/tasks.c **** 
  27:FreeRTOS/Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:FreeRTOS/Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:FreeRTOS/Source/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:FreeRTOS/Source/tasks.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:FreeRTOS/Source/tasks.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:FreeRTOS/Source/tasks.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:FreeRTOS/Source/tasks.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:FreeRTOS/Source/tasks.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:FreeRTOS/Source/tasks.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:FreeRTOS/Source/tasks.c ****     more details. You should have received a copy of the GNU General Public
  37:FreeRTOS/Source/tasks.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:FreeRTOS/Source/tasks.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:FreeRTOS/Source/tasks.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:FreeRTOS/Source/tasks.c ****     FreeRTOS WEB site.
  41:FreeRTOS/Source/tasks.c **** 
  42:FreeRTOS/Source/tasks.c ****     1 tab == 4 spaces!
  43:FreeRTOS/Source/tasks.c **** 
  44:FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:FreeRTOS/Source/tasks.c ****     contact details.
  46:FreeRTOS/Source/tasks.c **** 
  47:FreeRTOS/Source/tasks.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:FreeRTOS/Source/tasks.c ****     critical systems.
  49:FreeRTOS/Source/tasks.c **** 
  50:FreeRTOS/Source/tasks.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:FreeRTOS/Source/tasks.c ****     licensing and training services.
  52:FreeRTOS/Source/tasks.c **** */
  53:FreeRTOS/Source/tasks.c **** 
  54:FreeRTOS/Source/tasks.c **** 
  55:FreeRTOS/Source/tasks.c **** #include <stdio.h>
  56:FreeRTOS/Source/tasks.c **** #include <stdlib.h>
  57:FreeRTOS/Source/tasks.c **** #include <string.h>
  58:FreeRTOS/Source/tasks.c **** 
  59:FreeRTOS/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  60:FreeRTOS/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  61:FreeRTOS/Source/tasks.c **** task.h is included from an application file. */
  62:FreeRTOS/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  63:FreeRTOS/Source/tasks.c **** 
  64:FreeRTOS/Source/tasks.c **** #include "FreeRTOS.h"
  65:FreeRTOS/Source/tasks.c **** #include "task.h"
  66:FreeRTOS/Source/tasks.c **** #include "timers.h"
  67:FreeRTOS/Source/tasks.c **** #include "StackMacros.h"
  68:FreeRTOS/Source/tasks.c **** 
  69:FreeRTOS/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:FreeRTOS/Source/tasks.c **** 
  71:FreeRTOS/Source/tasks.c **** /*
  72:FreeRTOS/Source/tasks.c ****  * Macro to define the amount of stack available to the idle task.
  73:FreeRTOS/Source/tasks.c ****  */
  74:FreeRTOS/Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  75:FreeRTOS/Source/tasks.c **** 
  76:FreeRTOS/Source/tasks.c **** /*
  77:FreeRTOS/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated to each task,
  78:FreeRTOS/Source/tasks.c ****  * and stores the context of the task.
  79:FreeRTOS/Source/tasks.c ****  */
  80:FreeRTOS/Source/tasks.c **** typedef struct tskTaskControlBlock
  81:FreeRTOS/Source/tasks.c **** {
  82:FreeRTOS/Source/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
  83:FreeRTOS/Source/tasks.c **** 
  84:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
  85:FreeRTOS/Source/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
  86:FreeRTOS/Source/tasks.c **** 	#endif	
  87:FreeRTOS/Source/tasks.c **** 	
  88:FreeRTOS/Source/tasks.c **** 	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
  89:FreeRTOS/Source/tasks.c **** 	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
  90:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. 
  91:FreeRTOS/Source/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
  92:FreeRTOS/Source/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
  93:FreeRTOS/Source/tasks.c **** 
  94:FreeRTOS/Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
  95:FreeRTOS/Source/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the s
  96:FreeRTOS/Source/tasks.c **** 	#endif
  97:FreeRTOS/Source/tasks.c **** 
  98:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
  99:FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting;
 100:FreeRTOS/Source/tasks.c **** 	#endif
 101:FreeRTOS/Source/tasks.c **** 
 102:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 103:FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< This is used for tracing the scheduler and making debuggi
 104:FreeRTOS/Source/tasks.c **** 	#endif
 105:FreeRTOS/Source/tasks.c **** 
 106:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 107:FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 108:FreeRTOS/Source/tasks.c **** 	#endif
 109:FreeRTOS/Source/tasks.c **** 
 110:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 111:FreeRTOS/Source/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 112:FreeRTOS/Source/tasks.c **** 	#endif
 113:FreeRTOS/Source/tasks.c **** 
 114:FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 115:FreeRTOS/Source/tasks.c **** 		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilisin
 116:FreeRTOS/Source/tasks.c **** 	#endif
 117:FreeRTOS/Source/tasks.c **** 
 118:FreeRTOS/Source/tasks.c **** } tskTCB;
 119:FreeRTOS/Source/tasks.c **** 
 120:FreeRTOS/Source/tasks.c **** 
 121:FreeRTOS/Source/tasks.c **** /*
 122:FreeRTOS/Source/tasks.c ****  * Some kernel aware debuggers require data to be viewed to be global, rather
 123:FreeRTOS/Source/tasks.c ****  * than file scope.
 124:FreeRTOS/Source/tasks.c ****  */
 125:FreeRTOS/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 126:FreeRTOS/Source/tasks.c **** 	#define static
 127:FreeRTOS/Source/tasks.c **** #endif
 128:FreeRTOS/Source/tasks.c **** 
 129:FreeRTOS/Source/tasks.c **** /*lint -e956 */
 130:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 131:FreeRTOS/Source/tasks.c **** 
 132:FreeRTOS/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 133:FreeRTOS/Source/tasks.c **** 
 134:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 135:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 136:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 137:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 138:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 139:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 140:FreeRTOS/Source/tasks.c **** 
 141:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 142:FreeRTOS/Source/tasks.c **** 
 143:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but t
 144:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 145:FreeRTOS/Source/tasks.c **** 
 146:FreeRTOS/Source/tasks.c **** #endif
 147:FreeRTOS/Source/tasks.c **** 
 148:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 149:FreeRTOS/Source/tasks.c **** 
 150:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 151:FreeRTOS/Source/tasks.c **** 
 152:FreeRTOS/Source/tasks.c **** #endif
 153:FreeRTOS/Source/tasks.c **** 
 154:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 155:FreeRTOS/Source/tasks.c **** 	
 156:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;
 157:FreeRTOS/Source/tasks.c **** 	
 158:FreeRTOS/Source/tasks.c **** #endif
 159:FreeRTOS/Source/tasks.c **** 
 160:FreeRTOS/Source/tasks.c **** /* File private variables. --------------------------------*/
 161:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 162:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
 163:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 164:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 165:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 166:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 167:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 168:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 169:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 170:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0U;
 171:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static portTickType xNextTaskUnblockTime						= ( portTickType ) portMAX_DELAY;
 172:FreeRTOS/Source/tasks.c **** 
 173:FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 174:FreeRTOS/Source/tasks.c **** 
 175:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 176:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 177:FreeRTOS/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 178:FreeRTOS/Source/tasks.c **** 
 179:FreeRTOS/Source/tasks.c **** #endif
 180:FreeRTOS/Source/tasks.c **** 
 181:FreeRTOS/Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 182:FreeRTOS/Source/tasks.c **** 
 183:FreeRTOS/Source/tasks.c **** /*
 184:FreeRTOS/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 185:FreeRTOS/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 186:FreeRTOS/Source/tasks.c ****  */
 187:FreeRTOS/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 188:FreeRTOS/Source/tasks.c **** 
 189:FreeRTOS/Source/tasks.c **** /*
 190:FreeRTOS/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 191:FreeRTOS/Source/tasks.c ****  */
 192:FreeRTOS/Source/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 193:FreeRTOS/Source/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 194:FreeRTOS/Source/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 195:FreeRTOS/Source/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 196:FreeRTOS/Source/tasks.c **** 
 197:FreeRTOS/Source/tasks.c **** /*
 198:FreeRTOS/Source/tasks.c ****  * Macros and private variables used by the trace facility.
 199:FreeRTOS/Source/tasks.c ****  */
 200:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 201:FreeRTOS/Source/tasks.c **** 
 202:FreeRTOS/Source/tasks.c **** 	#define tskSIZE_OF_EACH_TRACE_LINE			( ( unsigned long ) ( sizeof( unsigned long ) + sizeof( unsig
 203:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile signed char * volatile pcTraceBuffer;
 204:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferStart;
 205:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferEnd;
 206:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static signed portBASE_TYPE xTracing = pdFALSE;
 207:FreeRTOS/Source/tasks.c **** 	static unsigned portBASE_TYPE uxPreviousTask = 255U;
 208:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatusString[ 50 ];
 209:FreeRTOS/Source/tasks.c **** 
 210:FreeRTOS/Source/tasks.c **** #endif
 211:FreeRTOS/Source/tasks.c **** 
 212:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 213:FreeRTOS/Source/tasks.c **** 
 214:FreeRTOS/Source/tasks.c **** /*
 215:FreeRTOS/Source/tasks.c ****  * Macro that writes a trace of scheduler activity to a buffer.  This trace
 216:FreeRTOS/Source/tasks.c ****  * shows which task is running when and is very useful as a debugging tool.
 217:FreeRTOS/Source/tasks.c ****  * As this macro is called each context switch it is a good idea to undefine
 218:FreeRTOS/Source/tasks.c ****  * it if not using the facility.
 219:FreeRTOS/Source/tasks.c ****  */
 220:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 221:FreeRTOS/Source/tasks.c **** 
 222:FreeRTOS/Source/tasks.c **** 	#define vWriteTraceToBuffer()																	\
 223:FreeRTOS/Source/tasks.c **** 	{																								\
 224:FreeRTOS/Source/tasks.c **** 		if( xTracing != pdFALSE )																	\
 225:FreeRTOS/Source/tasks.c **** 		{																							\
 226:FreeRTOS/Source/tasks.c **** 			if( uxPreviousTask != pxCurrentTCB->uxTCBNumber )										\
 227:FreeRTOS/Source/tasks.c **** 			{																						\
 228:FreeRTOS/Source/tasks.c **** 				if( ( pcTraceBuffer + tskSIZE_OF_EACH_TRACE_LINE ) < pcTraceBufferEnd )				\
 229:FreeRTOS/Source/tasks.c **** 				{																					\
 230:FreeRTOS/Source/tasks.c **** 					uxPreviousTask = pxCurrentTCB->uxTCBNumber;										\
 231:FreeRTOS/Source/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) xTickCount;				\
 232:FreeRTOS/Source/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );										\
 233:FreeRTOS/Source/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) uxPreviousTask;			\
 234:FreeRTOS/Source/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );										\
 235:FreeRTOS/Source/tasks.c **** 				}																					\
 236:FreeRTOS/Source/tasks.c **** 				else																				\
 237:FreeRTOS/Source/tasks.c **** 				{																					\
 238:FreeRTOS/Source/tasks.c **** 					xTracing = pdFALSE;																\
 239:FreeRTOS/Source/tasks.c **** 				}																					\
 240:FreeRTOS/Source/tasks.c **** 			}																						\
 241:FreeRTOS/Source/tasks.c **** 		}																							\
 242:FreeRTOS/Source/tasks.c **** 	}
 243:FreeRTOS/Source/tasks.c **** 
 244:FreeRTOS/Source/tasks.c **** #else
 245:FreeRTOS/Source/tasks.c **** 
 246:FreeRTOS/Source/tasks.c **** 	#define vWriteTraceToBuffer()
 247:FreeRTOS/Source/tasks.c **** 
 248:FreeRTOS/Source/tasks.c **** #endif
 249:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 250:FreeRTOS/Source/tasks.c **** 
 251:FreeRTOS/Source/tasks.c **** /*
 252:FreeRTOS/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 253:FreeRTOS/Source/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 254:FreeRTOS/Source/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 255:FreeRTOS/Source/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 256:FreeRTOS/Source/tasks.c ****  * executing task has been rescheduled.
 257:FreeRTOS/Source/tasks.c ****  */
 258:FreeRTOS/Source/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																					\
 259:FreeRTOS/Source/tasks.c **** 	if( ( pxTCB )->uxPriority > uxTopReadyPriority )																	\
 260:FreeRTOS/Source/tasks.c **** 	{																													\
 261:FreeRTOS/Source/tasks.c **** 		uxTopReadyPriority = ( pxTCB )->uxPriority;																		\
 262:FreeRTOS/Source/tasks.c **** 	}																													\
 263:FreeRTOS/Source/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGeneri
 264:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 265:FreeRTOS/Source/tasks.c **** 
 266:FreeRTOS/Source/tasks.c **** /*
 267:FreeRTOS/Source/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 268:FreeRTOS/Source/tasks.c ****  * any require waking.
 269:FreeRTOS/Source/tasks.c ****  *
 270:FreeRTOS/Source/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 271:FreeRTOS/Source/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 272:FreeRTOS/Source/tasks.c ****  * any further down the list.
 273:FreeRTOS/Source/tasks.c ****  */
 274:FreeRTOS/Source/tasks.c **** #define prvCheckDelayedTasks()															\
 275:FreeRTOS/Source/tasks.c **** {																						\
 276:FreeRTOS/Source/tasks.c **** portTickType xItemValue;																\
 277:FreeRTOS/Source/tasks.c **** 																						\
 278:FreeRTOS/Source/tasks.c **** 	/* Is the tick count greater than or equal to the wake time of the first			\
 279:FreeRTOS/Source/tasks.c **** 	task referenced from the delayed tasks list? */										\
 280:FreeRTOS/Source/tasks.c **** 	if( xTickCount >= xNextTaskUnblockTime )											\
 281:FreeRTOS/Source/tasks.c **** 	{																					\
 282:FreeRTOS/Source/tasks.c **** 		for( ;; )																		\
 283:FreeRTOS/Source/tasks.c **** 		{																				\
 284:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )						\
 285:FreeRTOS/Source/tasks.c **** 			{																			\
 286:FreeRTOS/Source/tasks.c **** 				/* The delayed list is empty.  Set xNextTaskUnblockTime to the			\
 287:FreeRTOS/Source/tasks.c **** 				maximum possible value so it is extremely unlikely that the				\
 288:FreeRTOS/Source/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass next			\
 289:FreeRTOS/Source/tasks.c **** 				time through. */														\
 290:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;									\
 291:FreeRTOS/Source/tasks.c **** 				break;																	\
 292:FreeRTOS/Source/tasks.c **** 			}																			\
 293:FreeRTOS/Source/tasks.c **** 			else																		\
 294:FreeRTOS/Source/tasks.c **** 			{																			\
 295:FreeRTOS/Source/tasks.c **** 				/* The delayed list is not empty, get the value of the item at			\
 296:FreeRTOS/Source/tasks.c **** 				the head of the delayed list.  This is the time at which the			\
 297:FreeRTOS/Source/tasks.c **** 				task at the head of the delayed list should be removed from				\
 298:FreeRTOS/Source/tasks.c **** 				the Blocked state. */													\
 299:FreeRTOS/Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );	\
 300:FreeRTOS/Source/tasks.c **** 				xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );	\
 301:FreeRTOS/Source/tasks.c **** 																						\
 302:FreeRTOS/Source/tasks.c **** 				if( xTickCount < xItemValue )											\
 303:FreeRTOS/Source/tasks.c **** 				{																		\
 304:FreeRTOS/Source/tasks.c **** 					/* It is not time to unblock this item yet, but the item			\
 305:FreeRTOS/Source/tasks.c **** 					value is the time at which the task at the head of the				\
 306:FreeRTOS/Source/tasks.c **** 					blocked list should be removed from the Blocked state -				\
 307:FreeRTOS/Source/tasks.c **** 					so record the item value in xNextTaskUnblockTime. */				\
 308:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime = xItemValue;									\
 309:FreeRTOS/Source/tasks.c **** 					break;																\
 310:FreeRTOS/Source/tasks.c **** 				}																		\
 311:FreeRTOS/Source/tasks.c **** 																						\
 312:FreeRTOS/Source/tasks.c **** 				/* It is time to remove the item from the Blocked state. */				\
 313:FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );							\
 314:FreeRTOS/Source/tasks.c **** 																						\
 315:FreeRTOS/Source/tasks.c **** 				/* Is the task waiting on an event also? */								\
 316:FreeRTOS/Source/tasks.c **** 				if( pxTCB->xEventListItem.pvContainer != NULL )							\
 317:FreeRTOS/Source/tasks.c **** 				{																		\
 318:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );							\
 319:FreeRTOS/Source/tasks.c **** 				}																		\
 320:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );										\
 321:FreeRTOS/Source/tasks.c **** 			}																			\
 322:FreeRTOS/Source/tasks.c **** 		}																				\
 323:FreeRTOS/Source/tasks.c **** 	}																					\
 324:FreeRTOS/Source/tasks.c **** }
 325:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 326:FreeRTOS/Source/tasks.c **** 
 327:FreeRTOS/Source/tasks.c **** /*
 328:FreeRTOS/Source/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 329:FreeRTOS/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 330:FreeRTOS/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 331:FreeRTOS/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 332:FreeRTOS/Source/tasks.c ****  */
 333:FreeRTOS/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( 
 334:FreeRTOS/Source/tasks.c **** 
 335:FreeRTOS/Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 336:FreeRTOS/Source/tasks.c **** extern void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed char *pcTaskName );
 337:FreeRTOS/Source/tasks.c **** extern void vApplicationTickHook( void );
 338:FreeRTOS/Source/tasks.c **** 		
 339:FreeRTOS/Source/tasks.c **** /* File private functions. --------------------------------*/
 340:FreeRTOS/Source/tasks.c **** 
 341:FreeRTOS/Source/tasks.c **** /*
 342:FreeRTOS/Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 343:FreeRTOS/Source/tasks.c ****  * into the TCB structure.
 344:FreeRTOS/Source/tasks.c ****  */
 345:FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 346:FreeRTOS/Source/tasks.c **** 
 347:FreeRTOS/Source/tasks.c **** /*
 348:FreeRTOS/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 349:FreeRTOS/Source/tasks.c ****  * automatically upon the creation of the first task.
 350:FreeRTOS/Source/tasks.c ****  */
 351:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 352:FreeRTOS/Source/tasks.c **** 
 353:FreeRTOS/Source/tasks.c **** /*
 354:FreeRTOS/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 355:FreeRTOS/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 356:FreeRTOS/Source/tasks.c ****  * creation of the first user task.
 357:FreeRTOS/Source/tasks.c ****  *
 358:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 359:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 360:FreeRTOS/Source/tasks.c ****  *
 361:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 362:FreeRTOS/Source/tasks.c ****  *
 363:FreeRTOS/Source/tasks.c ****  */
 364:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 365:FreeRTOS/Source/tasks.c **** 
 366:FreeRTOS/Source/tasks.c **** /*
 367:FreeRTOS/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 368:FreeRTOS/Source/tasks.c ****  * including the stack pointed to by the TCB.
 369:FreeRTOS/Source/tasks.c ****  *
 370:FreeRTOS/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 371:FreeRTOS/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 372:FreeRTOS/Source/tasks.c ****  */
 373:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 374:FreeRTOS/Source/tasks.c **** 
 375:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 376:FreeRTOS/Source/tasks.c **** 
 377:FreeRTOS/Source/tasks.c **** #endif
 378:FreeRTOS/Source/tasks.c **** 
 379:FreeRTOS/Source/tasks.c **** /*
 380:FreeRTOS/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 381:FreeRTOS/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 382:FreeRTOS/Source/tasks.c ****  * and its TCB deleted.
 383:FreeRTOS/Source/tasks.c ****  */
 384:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 385:FreeRTOS/Source/tasks.c **** 
 386:FreeRTOS/Source/tasks.c **** /*
 387:FreeRTOS/Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 388:FreeRTOS/Source/tasks.c ****  * either the current or the overflow delayed task list.
 389:FreeRTOS/Source/tasks.c ****  */
 390:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
 391:FreeRTOS/Source/tasks.c **** 
 392:FreeRTOS/Source/tasks.c **** /*
 393:FreeRTOS/Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 394:FreeRTOS/Source/tasks.c ****  * allocation was successful.
 395:FreeRTOS/Source/tasks.c ****  */
 396:FreeRTOS/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 397:FreeRTOS/Source/tasks.c **** 
 398:FreeRTOS/Source/tasks.c **** /*
 399:FreeRTOS/Source/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 400:FreeRTOS/Source/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 401:FreeRTOS/Source/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 402:FreeRTOS/Source/tasks.c ****  * within just that list.
 403:FreeRTOS/Source/tasks.c ****  *
 404:FreeRTOS/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 405:FreeRTOS/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 406:FreeRTOS/Source/tasks.c ****  */
 407:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 408:FreeRTOS/Source/tasks.c **** 
 409:FreeRTOS/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 410:FreeRTOS/Source/tasks.c **** 
 411:FreeRTOS/Source/tasks.c **** #endif
 412:FreeRTOS/Source/tasks.c **** 
 413:FreeRTOS/Source/tasks.c **** /*
 414:FreeRTOS/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 415:FreeRTOS/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 416:FreeRTOS/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 417:FreeRTOS/Source/tasks.c ****  */
 418:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 419:FreeRTOS/Source/tasks.c **** 
 420:FreeRTOS/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 421:FreeRTOS/Source/tasks.c **** 
 422:FreeRTOS/Source/tasks.c **** #endif
 423:FreeRTOS/Source/tasks.c **** 
 424:FreeRTOS/Source/tasks.c **** 
 425:FreeRTOS/Source/tasks.c **** /*lint +e956 */
 426:FreeRTOS/Source/tasks.c **** 
 427:FreeRTOS/Source/tasks.c **** 
 428:FreeRTOS/Source/tasks.c **** 
 429:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
 430:FreeRTOS/Source/tasks.c ****  * TASK CREATION API documented in task.h
 431:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
 432:FreeRTOS/Source/tasks.c **** 
 433:FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 434:FreeRTOS/Source/tasks.c **** {
 173              		.loc 1 434 0
 174              		.cfi_startproc
 175              		@ args = 16, pretend = 0, frame = 32
 176              		@ frame_needed = 1, uses_anonymous_args = 0
 177 0000 80B5     		push	{r7, lr}
 178              	.LCFI0:
 179              		.cfi_def_cfa_offset 8
 180              		.cfi_offset 7, -8
 181              		.cfi_offset 14, -4
 182 0002 8AB0     		sub	sp, sp, #40
 183              	.LCFI1:
 184              		.cfi_def_cfa_offset 48
 185 0004 02AF     		add	r7, sp, #8
 186              	.LCFI2:
 187              		.cfi_def_cfa 7, 40
 188 0006 F860     		str	r0, [r7, #12]
 189 0008 B960     		str	r1, [r7, #8]
 190 000a 3B60     		str	r3, [r7]
 191 000c 1346     		mov	r3, r2	@ movhi
 192 000e FB80     		strh	r3, [r7, #6]	@ movhi
 435:FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xReturn;
 436:FreeRTOS/Source/tasks.c **** tskTCB * pxNewTCB;
 437:FreeRTOS/Source/tasks.c **** 
 438:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTaskCode );
 439:FreeRTOS/Source/tasks.c **** 	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );
 440:FreeRTOS/Source/tasks.c **** 
 441:FreeRTOS/Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 442:FreeRTOS/Source/tasks.c **** 	checking that the allocation was successful. */
 443:FreeRTOS/Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 193              		.loc 1 443 0
 194 0010 FB88     		ldrh	r3, [r7, #6]
 195 0012 1846     		mov	r0, r3
 196 0014 396B     		ldr	r1, [r7, #48]
 197 0016 FFF7FEFF 		bl	prvAllocateTCBAndStack
 198 001a B861     		str	r0, [r7, #24]
 444:FreeRTOS/Source/tasks.c **** 
 445:FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 199              		.loc 1 445 0
 200 001c BB69     		ldr	r3, [r7, #24]
 201 001e 002B     		cmp	r3, #0
 202 0020 70D0     		beq	.L2
 203              	.LBB2:
 446:FreeRTOS/Source/tasks.c **** 	{
 447:FreeRTOS/Source/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 448:FreeRTOS/Source/tasks.c **** 
 449:FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 450:FreeRTOS/Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 451:FreeRTOS/Source/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 452:FreeRTOS/Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 453:FreeRTOS/Source/tasks.c **** 			{
 454:FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 455:FreeRTOS/Source/tasks.c **** 			}
 456:FreeRTOS/Source/tasks.c **** 			else
 457:FreeRTOS/Source/tasks.c **** 			{
 458:FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 459:FreeRTOS/Source/tasks.c **** 			}
 460:FreeRTOS/Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 461:FreeRTOS/Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 462:FreeRTOS/Source/tasks.c **** 
 463:FreeRTOS/Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 464:FreeRTOS/Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 465:FreeRTOS/Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 466:FreeRTOS/Source/tasks.c **** 		required by the port. */
 467:FreeRTOS/Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 468:FreeRTOS/Source/tasks.c **** 		{
 469:FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 204              		.loc 1 469 0
 205 0022 BB69     		ldr	r3, [r7, #24]
 206 0024 1A6B     		ldr	r2, [r3, #48]
 207 0026 FB88     		ldrh	r3, [r7, #6]
 208 0028 03F18043 		add	r3, r3, #1073741824
 209 002c 013B     		subs	r3, r3, #1
 210 002e 9B00     		lsls	r3, r3, #2
 211 0030 1344     		add	r3, r3, r2
 212 0032 7B61     		str	r3, [r7, #20]
 470:FreeRTOS/Source/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 213              		.loc 1 470 0
 214 0034 7B69     		ldr	r3, [r7, #20]
 215 0036 23F00703 		bic	r3, r3, #7
 216 003a 7B61     		str	r3, [r7, #20]
 471:FreeRTOS/Source/tasks.c **** 
 472:FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 473:FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) =
 474:FreeRTOS/Source/tasks.c **** 		}
 475:FreeRTOS/Source/tasks.c **** 		#else
 476:FreeRTOS/Source/tasks.c **** 		{
 477:FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 478:FreeRTOS/Source/tasks.c **** 			
 479:FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 480:FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MAS
 481:FreeRTOS/Source/tasks.c **** 
 482:FreeRTOS/Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 483:FreeRTOS/Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 484:FreeRTOS/Source/tasks.c **** 			other extreme of the stack space. */
 485:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 486:FreeRTOS/Source/tasks.c **** 		}
 487:FreeRTOS/Source/tasks.c **** 		#endif
 488:FreeRTOS/Source/tasks.c **** 
 489:FreeRTOS/Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 490:FreeRTOS/Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 217              		.loc 1 490 0
 218 003c FB88     		ldrh	r3, [r7, #6]
 219 003e 0093     		str	r3, [sp]
 220 0040 B869     		ldr	r0, [r7, #24]
 221 0042 B968     		ldr	r1, [r7, #8]
 222 0044 BA6A     		ldr	r2, [r7, #40]
 223 0046 7B6B     		ldr	r3, [r7, #52]
 224 0048 FFF7FEFF 		bl	prvInitialiseTCBVariables
 491:FreeRTOS/Source/tasks.c **** 
 492:FreeRTOS/Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 493:FreeRTOS/Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 494:FreeRTOS/Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 495:FreeRTOS/Source/tasks.c **** 		the	top of stack variable is updated. */
 496:FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 497:FreeRTOS/Source/tasks.c **** 		{
 498:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 499:FreeRTOS/Source/tasks.c **** 		}
 500:FreeRTOS/Source/tasks.c **** 		#else
 501:FreeRTOS/Source/tasks.c **** 		{
 502:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 225              		.loc 1 502 0
 226 004c 7869     		ldr	r0, [r7, #20]
 227 004e F968     		ldr	r1, [r7, #12]
 228 0050 3A68     		ldr	r2, [r7]
 229 0052 FFF7FEFF 		bl	pxPortInitialiseStack
 230 0056 0246     		mov	r2, r0
 231 0058 BB69     		ldr	r3, [r7, #24]
 232 005a 1A60     		str	r2, [r3]
 503:FreeRTOS/Source/tasks.c **** 		}
 504:FreeRTOS/Source/tasks.c **** 		#endif
 505:FreeRTOS/Source/tasks.c **** 
 506:FreeRTOS/Source/tasks.c **** 		/* Check the alignment of the initialised stack. */
 507:FreeRTOS/Source/tasks.c **** 		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT
 508:FreeRTOS/Source/tasks.c **** 
 509:FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 233              		.loc 1 509 0
 234 005c FB6A     		ldr	r3, [r7, #44]
 235 005e 002B     		cmp	r3, #0
 236 0060 02D0     		beq	.L3
 510:FreeRTOS/Source/tasks.c **** 		{
 511:FreeRTOS/Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 512:FreeRTOS/Source/tasks.c **** 			task can use this as a handle to delete the task later if
 513:FreeRTOS/Source/tasks.c **** 			required.*/
 514:FreeRTOS/Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 237              		.loc 1 514 0
 238 0062 FB6A     		ldr	r3, [r7, #44]
 239 0064 BA69     		ldr	r2, [r7, #24]
 240 0066 1A60     		str	r2, [r3]
 241              	.L3:
 515:FreeRTOS/Source/tasks.c **** 		}
 516:FreeRTOS/Source/tasks.c **** 		
 517:FreeRTOS/Source/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 518:FreeRTOS/Source/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 519:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 242              		.loc 1 519 0
 243 0068 FFF7FEFF 		bl	vPortEnterCritical
 520:FreeRTOS/Source/tasks.c **** 		{
 521:FreeRTOS/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 244              		.loc 1 521 0
 245 006c 314B     		ldr	r3, .L12
 246 006e 1B68     		ldr	r3, [r3]
 247 0070 5A1C     		adds	r2, r3, #1
 248 0072 304B     		ldr	r3, .L12
 249 0074 1A60     		str	r2, [r3]
 522:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 250              		.loc 1 522 0
 251 0076 304B     		ldr	r3, .L12+4
 252 0078 1B68     		ldr	r3, [r3]
 253 007a 002B     		cmp	r3, #0
 254 007c 09D1     		bne	.L4
 523:FreeRTOS/Source/tasks.c **** 			{
 524:FreeRTOS/Source/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 525:FreeRTOS/Source/tasks.c **** 				the suspended state - make this the current task. */
 526:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 255              		.loc 1 526 0
 256 007e 2E4B     		ldr	r3, .L12+4
 257 0080 BA69     		ldr	r2, [r7, #24]
 258 0082 1A60     		str	r2, [r3]
 527:FreeRTOS/Source/tasks.c **** 
 528:FreeRTOS/Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 259              		.loc 1 528 0
 260 0084 2B4B     		ldr	r3, .L12
 261 0086 1B68     		ldr	r3, [r3]
 262 0088 012B     		cmp	r3, #1
 263 008a 0FD1     		bne	.L6
 529:FreeRTOS/Source/tasks.c **** 				{
 530:FreeRTOS/Source/tasks.c **** 					/* This is the first task to be created so do the preliminary
 531:FreeRTOS/Source/tasks.c **** 					initialisation required.  We will not recover if this call
 532:FreeRTOS/Source/tasks.c **** 					fails, but we will report the failure. */
 533:FreeRTOS/Source/tasks.c **** 					prvInitialiseTaskLists();
 264              		.loc 1 533 0
 265 008c FFF7FEFF 		bl	prvInitialiseTaskLists
 266 0090 0CE0     		b	.L6
 267              	.L4:
 534:FreeRTOS/Source/tasks.c **** 				}
 535:FreeRTOS/Source/tasks.c **** 			}
 536:FreeRTOS/Source/tasks.c **** 			else
 537:FreeRTOS/Source/tasks.c **** 			{
 538:FreeRTOS/Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 539:FreeRTOS/Source/tasks.c **** 				current task if it is the highest priority task to be created
 540:FreeRTOS/Source/tasks.c **** 				so far. */
 541:FreeRTOS/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 268              		.loc 1 541 0
 269 0092 2A4B     		ldr	r3, .L12+8
 270 0094 1B68     		ldr	r3, [r3]
 271 0096 002B     		cmp	r3, #0
 272 0098 08D1     		bne	.L6
 542:FreeRTOS/Source/tasks.c **** 				{
 543:FreeRTOS/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 273              		.loc 1 543 0
 274 009a 274B     		ldr	r3, .L12+4
 275 009c 1B68     		ldr	r3, [r3]
 276 009e DA6A     		ldr	r2, [r3, #44]
 277 00a0 BB6A     		ldr	r3, [r7, #40]
 278 00a2 9A42     		cmp	r2, r3
 279 00a4 02D8     		bhi	.L6
 544:FreeRTOS/Source/tasks.c **** 					{
 545:FreeRTOS/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 280              		.loc 1 545 0
 281 00a6 244B     		ldr	r3, .L12+4
 282 00a8 BA69     		ldr	r2, [r7, #24]
 283 00aa 1A60     		str	r2, [r3]
 284              	.L6:
 546:FreeRTOS/Source/tasks.c **** 					}
 547:FreeRTOS/Source/tasks.c **** 				}
 548:FreeRTOS/Source/tasks.c **** 			}
 549:FreeRTOS/Source/tasks.c **** 
 550:FreeRTOS/Source/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 551:FreeRTOS/Source/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 552:FreeRTOS/Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 285              		.loc 1 552 0
 286 00ac BB69     		ldr	r3, [r7, #24]
 287 00ae DA6A     		ldr	r2, [r3, #44]
 288 00b0 234B     		ldr	r3, .L12+12
 289 00b2 1B68     		ldr	r3, [r3]
 290 00b4 9A42     		cmp	r2, r3
 291 00b6 03D9     		bls	.L7
 553:FreeRTOS/Source/tasks.c **** 			{
 554:FreeRTOS/Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 292              		.loc 1 554 0
 293 00b8 BB69     		ldr	r3, [r7, #24]
 294 00ba DA6A     		ldr	r2, [r3, #44]
 295 00bc 204B     		ldr	r3, .L12+12
 296 00be 1A60     		str	r2, [r3]
 297              	.L7:
 555:FreeRTOS/Source/tasks.c **** 			}
 556:FreeRTOS/Source/tasks.c **** 
 557:FreeRTOS/Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 558:FreeRTOS/Source/tasks.c **** 			{
 559:FreeRTOS/Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 560:FreeRTOS/Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 561:FreeRTOS/Source/tasks.c **** 			}
 562:FreeRTOS/Source/tasks.c **** 			#endif
 563:FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 298              		.loc 1 563 0
 299 00c0 204B     		ldr	r3, .L12+16
 300 00c2 1B68     		ldr	r3, [r3]
 301 00c4 5A1C     		adds	r2, r3, #1
 302 00c6 1F4B     		ldr	r3, .L12+16
 303 00c8 1A60     		str	r2, [r3]
 564:FreeRTOS/Source/tasks.c **** 
 565:FreeRTOS/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 304              		.loc 1 565 0
 305 00ca BB69     		ldr	r3, [r7, #24]
 306 00cc DA6A     		ldr	r2, [r3, #44]
 307 00ce 1E4B     		ldr	r3, .L12+20
 308 00d0 1B68     		ldr	r3, [r3]
 309 00d2 9A42     		cmp	r2, r3
 310 00d4 03D9     		bls	.L8
 311              		.loc 1 565 0 is_stmt 0 discriminator 1
 312 00d6 BB69     		ldr	r3, [r7, #24]
 313 00d8 DA6A     		ldr	r2, [r3, #44]
 314 00da 1B4B     		ldr	r3, .L12+20
 315 00dc 1A60     		str	r2, [r3]
 316              	.L8:
 317              		.loc 1 565 0 discriminator 2
 318 00de BB69     		ldr	r3, [r7, #24]
 319 00e0 DA6A     		ldr	r2, [r3, #44]
 320 00e2 1346     		mov	r3, r2
 321 00e4 9B00     		lsls	r3, r3, #2
 322 00e6 1344     		add	r3, r3, r2
 323 00e8 9B00     		lsls	r3, r3, #2
 324 00ea 184A     		ldr	r2, .L12+24
 325 00ec 1A44     		add	r2, r2, r3
 326 00ee BB69     		ldr	r3, [r7, #24]
 327 00f0 0433     		adds	r3, r3, #4
 328 00f2 1046     		mov	r0, r2
 329 00f4 1946     		mov	r1, r3
 330 00f6 FFF7FEFF 		bl	vListInsertEnd
 566:FreeRTOS/Source/tasks.c **** 
 567:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 331              		.loc 1 567 0 is_stmt 1 discriminator 2
 332 00fa 0123     		movs	r3, #1
 333 00fc FB61     		str	r3, [r7, #28]
 568:FreeRTOS/Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 569:FreeRTOS/Source/tasks.c **** 		}
 570:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 334              		.loc 1 570 0 discriminator 2
 335 00fe FFF7FEFF 		bl	vPortExitCritical
 336              	.LBE2:
 337 0102 02E0     		b	.L9
 338              	.L2:
 571:FreeRTOS/Source/tasks.c **** 	}
 572:FreeRTOS/Source/tasks.c **** 	else
 573:FreeRTOS/Source/tasks.c **** 	{
 574:FreeRTOS/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 339              		.loc 1 574 0
 340 0104 4FF0FF33 		mov	r3, #-1
 341 0108 FB61     		str	r3, [r7, #28]
 342              	.L9:
 575:FreeRTOS/Source/tasks.c **** 		traceTASK_CREATE_FAILED();
 576:FreeRTOS/Source/tasks.c **** 	}
 577:FreeRTOS/Source/tasks.c **** 
 578:FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 343              		.loc 1 578 0
 344 010a FB69     		ldr	r3, [r7, #28]
 345 010c 012B     		cmp	r3, #1
 346 010e 0BD1     		bne	.L10
 579:FreeRTOS/Source/tasks.c **** 	{
 580:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 347              		.loc 1 580 0
 348 0110 0A4B     		ldr	r3, .L12+8
 349 0112 1B68     		ldr	r3, [r3]
 350 0114 002B     		cmp	r3, #0
 351 0116 07D0     		beq	.L10
 581:FreeRTOS/Source/tasks.c **** 		{
 582:FreeRTOS/Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 583:FreeRTOS/Source/tasks.c **** 			then it should run now. */
 584:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 352              		.loc 1 584 0
 353 0118 074B     		ldr	r3, .L12+4
 354 011a 1B68     		ldr	r3, [r3]
 355 011c DA6A     		ldr	r2, [r3, #44]
 356 011e BB6A     		ldr	r3, [r7, #40]
 357 0120 9A42     		cmp	r2, r3
 358 0122 01D2     		bcs	.L10
 585:FreeRTOS/Source/tasks.c **** 			{
 586:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 359              		.loc 1 586 0
 360 0124 FFF7FEFF 		bl	vPortYieldFromISR
 361              	.L10:
 587:FreeRTOS/Source/tasks.c **** 			}
 588:FreeRTOS/Source/tasks.c **** 		}
 589:FreeRTOS/Source/tasks.c **** 	}
 590:FreeRTOS/Source/tasks.c **** 
 591:FreeRTOS/Source/tasks.c **** 	return xReturn;
 362              		.loc 1 591 0
 363 0128 FB69     		ldr	r3, [r7, #28]
 592:FreeRTOS/Source/tasks.c **** }
 364              		.loc 1 592 0
 365 012a 1846     		mov	r0, r3
 366 012c 2037     		adds	r7, r7, #32
 367 012e BD46     		mov	sp, r7
 368              		@ sp needed
 369 0130 80BD     		pop	{r7, pc}
 370              	.L13:
 371 0132 00BF     		.align	2
 372              	.L12:
 373 0134 00000000 		.word	uxCurrentNumberOfTasks
 374 0138 00000000 		.word	pxCurrentTCB
 375 013c 00000000 		.word	xSchedulerRunning
 376 0140 00000000 		.word	uxTopUsedPriority
 377 0144 00000000 		.word	uxTaskNumber
 378 0148 00000000 		.word	uxTopReadyPriority
 379 014c 00000000 		.word	pxReadyTasksLists
 380              		.cfi_endproc
 381              	.LFE110:
 383              		.section	.text.vTaskDelete,"ax",%progbits
 384              		.align	2
 385              		.global	vTaskDelete
 386              		.thumb
 387              		.thumb_func
 389              	vTaskDelete:
 390              	.LFB111:
 593:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 594:FreeRTOS/Source/tasks.c **** 
 595:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 596:FreeRTOS/Source/tasks.c **** 
 597:FreeRTOS/Source/tasks.c **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 598:FreeRTOS/Source/tasks.c **** 	{
 391              		.loc 1 598 0
 392              		.cfi_startproc
 393              		@ args = 0, pretend = 0, frame = 16
 394              		@ frame_needed = 1, uses_anonymous_args = 0
 395 0000 80B5     		push	{r7, lr}
 396              	.LCFI3:
 397              		.cfi_def_cfa_offset 8
 398              		.cfi_offset 7, -8
 399              		.cfi_offset 14, -4
 400 0002 84B0     		sub	sp, sp, #16
 401              	.LCFI4:
 402              		.cfi_def_cfa_offset 24
 403 0004 00AF     		add	r7, sp, #0
 404              	.LCFI5:
 405              		.cfi_def_cfa_register 7
 406 0006 7860     		str	r0, [r7, #4]
 599:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 600:FreeRTOS/Source/tasks.c **** 
 601:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 407              		.loc 1 601 0
 408 0008 FFF7FEFF 		bl	vPortEnterCritical
 602:FreeRTOS/Source/tasks.c **** 		{
 603:FreeRTOS/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 604:FreeRTOS/Source/tasks.c **** 			deleted. */
 605:FreeRTOS/Source/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 409              		.loc 1 605 0
 410 000c 1D4B     		ldr	r3, .L20
 411 000e 1B68     		ldr	r3, [r3]
 412 0010 7A68     		ldr	r2, [r7, #4]
 413 0012 9A42     		cmp	r2, r3
 414 0014 01D1     		bne	.L15
 606:FreeRTOS/Source/tasks.c **** 			{
 607:FreeRTOS/Source/tasks.c **** 				pxTaskToDelete = NULL;
 415              		.loc 1 607 0
 416 0016 0023     		movs	r3, #0
 417 0018 7B60     		str	r3, [r7, #4]
 418              	.L15:
 608:FreeRTOS/Source/tasks.c **** 			}
 609:FreeRTOS/Source/tasks.c **** 
 610:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 611:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 419              		.loc 1 611 0
 420 001a 7B68     		ldr	r3, [r7, #4]
 421 001c 002B     		cmp	r3, #0
 422 001e 02D1     		bne	.L16
 423              		.loc 1 611 0 is_stmt 0 discriminator 1
 424 0020 184B     		ldr	r3, .L20
 425 0022 1B68     		ldr	r3, [r3]
 426 0024 00E0     		b	.L17
 427              	.L16:
 428              		.loc 1 611 0 discriminator 2
 429 0026 7B68     		ldr	r3, [r7, #4]
 430              	.L17:
 431              		.loc 1 611 0 discriminator 3
 432 0028 FB60     		str	r3, [r7, #12]
 612:FreeRTOS/Source/tasks.c **** 
 613:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 614:FreeRTOS/Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 615:FreeRTOS/Source/tasks.c **** 			the termination list and free up any memory allocated by the
 616:FreeRTOS/Source/tasks.c **** 			scheduler for the TCB and stack. */
 617:FreeRTOS/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 433              		.loc 1 617 0 is_stmt 1 discriminator 3
 434 002a FB68     		ldr	r3, [r7, #12]
 435 002c 0433     		adds	r3, r3, #4
 436 002e 1846     		mov	r0, r3
 437 0030 FFF7FEFF 		bl	vListRemove
 618:FreeRTOS/Source/tasks.c **** 
 619:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 620:FreeRTOS/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 438              		.loc 1 620 0 discriminator 3
 439 0034 FB68     		ldr	r3, [r7, #12]
 440 0036 9B6A     		ldr	r3, [r3, #40]
 441 0038 002B     		cmp	r3, #0
 442 003a 04D0     		beq	.L18
 621:FreeRTOS/Source/tasks.c **** 			{
 622:FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 443              		.loc 1 622 0
 444 003c FB68     		ldr	r3, [r7, #12]
 445 003e 1833     		adds	r3, r3, #24
 446 0040 1846     		mov	r0, r3
 447 0042 FFF7FEFF 		bl	vListRemove
 448              	.L18:
 623:FreeRTOS/Source/tasks.c **** 			}
 624:FreeRTOS/Source/tasks.c **** 
 625:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 449              		.loc 1 625 0
 450 0046 FB68     		ldr	r3, [r7, #12]
 451 0048 0433     		adds	r3, r3, #4
 452 004a 0F48     		ldr	r0, .L20+4
 453 004c 1946     		mov	r1, r3
 454 004e FFF7FEFF 		bl	vListInsertEnd
 626:FreeRTOS/Source/tasks.c **** 
 627:FreeRTOS/Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 628:FreeRTOS/Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 629:FreeRTOS/Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 630:FreeRTOS/Source/tasks.c **** 			++uxTasksDeleted;
 455              		.loc 1 630 0
 456 0052 0E4B     		ldr	r3, .L20+8
 457 0054 1B68     		ldr	r3, [r3]
 458 0056 5A1C     		adds	r2, r3, #1
 459 0058 0C4B     		ldr	r3, .L20+8
 460 005a 1A60     		str	r2, [r3]
 631:FreeRTOS/Source/tasks.c **** 
 632:FreeRTOS/Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 633:FreeRTOS/Source/tasks.c **** 			can detect that the task lists need re-generating. */
 634:FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 461              		.loc 1 634 0
 462 005c 0C4B     		ldr	r3, .L20+12
 463 005e 1B68     		ldr	r3, [r3]
 464 0060 5A1C     		adds	r2, r3, #1
 465 0062 0B4B     		ldr	r3, .L20+12
 466 0064 1A60     		str	r2, [r3]
 635:FreeRTOS/Source/tasks.c **** 
 636:FreeRTOS/Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 637:FreeRTOS/Source/tasks.c **** 		}
 638:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 467              		.loc 1 638 0
 468 0066 FFF7FEFF 		bl	vPortExitCritical
 639:FreeRTOS/Source/tasks.c **** 
 640:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 641:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 469              		.loc 1 641 0
 470 006a 0A4B     		ldr	r3, .L20+16
 471 006c 1B68     		ldr	r3, [r3]
 472 006e 002B     		cmp	r3, #0
 473 0070 04D0     		beq	.L14
 642:FreeRTOS/Source/tasks.c **** 		{
 643:FreeRTOS/Source/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 474              		.loc 1 643 0
 475 0072 7B68     		ldr	r3, [r7, #4]
 476 0074 002B     		cmp	r3, #0
 477 0076 01D1     		bne	.L14
 644:FreeRTOS/Source/tasks.c **** 			{
 645:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 478              		.loc 1 645 0
 479 0078 FFF7FEFF 		bl	vPortYieldFromISR
 480              	.L14:
 646:FreeRTOS/Source/tasks.c **** 			}
 647:FreeRTOS/Source/tasks.c **** 		}
 648:FreeRTOS/Source/tasks.c **** 	}
 481              		.loc 1 648 0
 482 007c 1037     		adds	r7, r7, #16
 483 007e BD46     		mov	sp, r7
 484              		@ sp needed
 485 0080 80BD     		pop	{r7, pc}
 486              	.L21:
 487 0082 00BF     		.align	2
 488              	.L20:
 489 0084 00000000 		.word	pxCurrentTCB
 490 0088 00000000 		.word	xTasksWaitingTermination
 491 008c 00000000 		.word	uxTasksDeleted
 492 0090 00000000 		.word	uxTaskNumber
 493 0094 00000000 		.word	xSchedulerRunning
 494              		.cfi_endproc
 495              	.LFE111:
 497              		.section	.text.vTaskDelayUntil,"ax",%progbits
 498              		.align	2
 499              		.global	vTaskDelayUntil
 500              		.thumb
 501              		.thumb_func
 503              	vTaskDelayUntil:
 504              	.LFB112:
 649:FreeRTOS/Source/tasks.c **** 
 650:FreeRTOS/Source/tasks.c **** #endif
 651:FreeRTOS/Source/tasks.c **** 
 652:FreeRTOS/Source/tasks.c **** 
 653:FreeRTOS/Source/tasks.c **** 
 654:FreeRTOS/Source/tasks.c **** 
 655:FreeRTOS/Source/tasks.c **** 
 656:FreeRTOS/Source/tasks.c **** 
 657:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
 658:FreeRTOS/Source/tasks.c ****  * TASK CONTROL API documented in task.h
 659:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
 660:FreeRTOS/Source/tasks.c **** 
 661:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 662:FreeRTOS/Source/tasks.c **** 
 663:FreeRTOS/Source/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 664:FreeRTOS/Source/tasks.c **** 	{
 505              		.loc 1 664 0
 506              		.cfi_startproc
 507              		@ args = 0, pretend = 0, frame = 24
 508              		@ frame_needed = 1, uses_anonymous_args = 0
 509 0000 80B5     		push	{r7, lr}
 510              	.LCFI6:
 511              		.cfi_def_cfa_offset 8
 512              		.cfi_offset 7, -8
 513              		.cfi_offset 14, -4
 514 0002 86B0     		sub	sp, sp, #24
 515              	.LCFI7:
 516              		.cfi_def_cfa_offset 32
 517 0004 00AF     		add	r7, sp, #0
 518              	.LCFI8:
 519              		.cfi_def_cfa_register 7
 520 0006 7860     		str	r0, [r7, #4]
 521 0008 3960     		str	r1, [r7]
 665:FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
 666:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 522              		.loc 1 666 0
 523 000a 0023     		movs	r3, #0
 524 000c 7B61     		str	r3, [r7, #20]
 667:FreeRTOS/Source/tasks.c **** 
 668:FreeRTOS/Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 669:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 670:FreeRTOS/Source/tasks.c **** 
 671:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
 525              		.loc 1 671 0
 526 000e FFF7FEFF 		bl	vTaskSuspendAll
 672:FreeRTOS/Source/tasks.c **** 		{
 673:FreeRTOS/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 674:FreeRTOS/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 527              		.loc 1 674 0
 528 0012 7B68     		ldr	r3, [r7, #4]
 529 0014 1A68     		ldr	r2, [r3]
 530 0016 3B68     		ldr	r3, [r7]
 531 0018 1344     		add	r3, r3, r2
 532 001a 3B61     		str	r3, [r7, #16]
 675:FreeRTOS/Source/tasks.c **** 
 676:FreeRTOS/Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 533              		.loc 1 676 0
 534 001c 7B68     		ldr	r3, [r7, #4]
 535 001e 1A68     		ldr	r2, [r3]
 536 0020 1B4B     		ldr	r3, .L29
 537 0022 1B68     		ldr	r3, [r3]
 538 0024 9A42     		cmp	r2, r3
 539 0026 0CD9     		bls	.L23
 677:FreeRTOS/Source/tasks.c **** 			{
 678:FreeRTOS/Source/tasks.c **** 				/* The tick count has overflowed since this function was
 679:FreeRTOS/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 680:FreeRTOS/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 681:FreeRTOS/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 682:FreeRTOS/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 683:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 540              		.loc 1 683 0
 541 0028 7B68     		ldr	r3, [r7, #4]
 542 002a 1A68     		ldr	r2, [r3]
 543 002c 3B69     		ldr	r3, [r7, #16]
 544 002e 9A42     		cmp	r2, r3
 545 0030 13D9     		bls	.L25
 546              		.loc 1 683 0 is_stmt 0 discriminator 1
 547 0032 174B     		ldr	r3, .L29
 548 0034 1B68     		ldr	r3, [r3]
 549 0036 3A69     		ldr	r2, [r7, #16]
 550 0038 9A42     		cmp	r2, r3
 551 003a 0ED9     		bls	.L25
 684:FreeRTOS/Source/tasks.c **** 				{
 685:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 552              		.loc 1 685 0 is_stmt 1
 553 003c 0123     		movs	r3, #1
 554 003e 7B61     		str	r3, [r7, #20]
 555 0040 0BE0     		b	.L25
 556              	.L23:
 686:FreeRTOS/Source/tasks.c **** 				}
 687:FreeRTOS/Source/tasks.c **** 			}
 688:FreeRTOS/Source/tasks.c **** 			else
 689:FreeRTOS/Source/tasks.c **** 			{
 690:FreeRTOS/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 691:FreeRTOS/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 692:FreeRTOS/Source/tasks.c **** 				tick time is less than the wake time. */
 693:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 557              		.loc 1 693 0
 558 0042 7B68     		ldr	r3, [r7, #4]
 559 0044 1A68     		ldr	r2, [r3]
 560 0046 3B69     		ldr	r3, [r7, #16]
 561 0048 9A42     		cmp	r2, r3
 562 004a 04D8     		bhi	.L26
 563              		.loc 1 693 0 is_stmt 0 discriminator 1
 564 004c 104B     		ldr	r3, .L29
 565 004e 1B68     		ldr	r3, [r3]
 566 0050 3A69     		ldr	r2, [r7, #16]
 567 0052 9A42     		cmp	r2, r3
 568 0054 01D9     		bls	.L25
 569              	.L26:
 694:FreeRTOS/Source/tasks.c **** 				{
 695:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 570              		.loc 1 695 0 is_stmt 1
 571 0056 0123     		movs	r3, #1
 572 0058 7B61     		str	r3, [r7, #20]
 573              	.L25:
 696:FreeRTOS/Source/tasks.c **** 				}
 697:FreeRTOS/Source/tasks.c **** 			}
 698:FreeRTOS/Source/tasks.c **** 
 699:FreeRTOS/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 700:FreeRTOS/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 574              		.loc 1 700 0
 575 005a 7B68     		ldr	r3, [r7, #4]
 576 005c 3A69     		ldr	r2, [r7, #16]
 577 005e 1A60     		str	r2, [r3]
 701:FreeRTOS/Source/tasks.c **** 
 702:FreeRTOS/Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 578              		.loc 1 702 0
 579 0060 7B69     		ldr	r3, [r7, #20]
 580 0062 002B     		cmp	r3, #0
 581 0064 08D0     		beq	.L27
 703:FreeRTOS/Source/tasks.c **** 			{
 704:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 705:FreeRTOS/Source/tasks.c **** 
 706:FreeRTOS/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 707:FreeRTOS/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 708:FreeRTOS/Source/tasks.c **** 				both lists. */
 709:FreeRTOS/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 582              		.loc 1 709 0
 583 0066 0B4B     		ldr	r3, .L29+4
 584 0068 1B68     		ldr	r3, [r3]
 585 006a 0433     		adds	r3, r3, #4
 586 006c 1846     		mov	r0, r3
 587 006e FFF7FEFF 		bl	vListRemove
 710:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 588              		.loc 1 710 0
 589 0072 3869     		ldr	r0, [r7, #16]
 590 0074 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 591              	.L27:
 711:FreeRTOS/Source/tasks.c **** 			}
 712:FreeRTOS/Source/tasks.c **** 		}
 713:FreeRTOS/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 592              		.loc 1 713 0
 593 0078 FFF7FEFF 		bl	xTaskResumeAll
 594 007c F860     		str	r0, [r7, #12]
 714:FreeRTOS/Source/tasks.c **** 
 715:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 716:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 717:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 595              		.loc 1 717 0
 596 007e FB68     		ldr	r3, [r7, #12]
 597 0080 002B     		cmp	r3, #0
 598 0082 01D1     		bne	.L22
 718:FreeRTOS/Source/tasks.c **** 		{
 719:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 599              		.loc 1 719 0
 600 0084 FFF7FEFF 		bl	vPortYieldFromISR
 601              	.L22:
 720:FreeRTOS/Source/tasks.c **** 		}
 721:FreeRTOS/Source/tasks.c **** 	}
 602              		.loc 1 721 0
 603 0088 1837     		adds	r7, r7, #24
 604 008a BD46     		mov	sp, r7
 605              		@ sp needed
 606 008c 80BD     		pop	{r7, pc}
 607              	.L30:
 608 008e 00BF     		.align	2
 609              	.L29:
 610 0090 00000000 		.word	xTickCount
 611 0094 00000000 		.word	pxCurrentTCB
 612              		.cfi_endproc
 613              	.LFE112:
 615              		.section	.text.vTaskDelay,"ax",%progbits
 616              		.align	2
 617              		.global	vTaskDelay
 618              		.thumb
 619              		.thumb_func
 621              	vTaskDelay:
 622              	.LFB113:
 722:FreeRTOS/Source/tasks.c **** 
 723:FreeRTOS/Source/tasks.c **** #endif
 724:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 725:FreeRTOS/Source/tasks.c **** 
 726:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 727:FreeRTOS/Source/tasks.c **** 
 728:FreeRTOS/Source/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 729:FreeRTOS/Source/tasks.c **** 	{
 623              		.loc 1 729 0
 624              		.cfi_startproc
 625              		@ args = 0, pretend = 0, frame = 16
 626              		@ frame_needed = 1, uses_anonymous_args = 0
 627 0000 80B5     		push	{r7, lr}
 628              	.LCFI9:
 629              		.cfi_def_cfa_offset 8
 630              		.cfi_offset 7, -8
 631              		.cfi_offset 14, -4
 632 0002 84B0     		sub	sp, sp, #16
 633              	.LCFI10:
 634              		.cfi_def_cfa_offset 24
 635 0004 00AF     		add	r7, sp, #0
 636              	.LCFI11:
 637              		.cfi_def_cfa_register 7
 638 0006 7860     		str	r0, [r7, #4]
 730:FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
 731:FreeRTOS/Source/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 639              		.loc 1 731 0
 640 0008 0023     		movs	r3, #0
 641 000a FB60     		str	r3, [r7, #12]
 732:FreeRTOS/Source/tasks.c **** 
 733:FreeRTOS/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 734:FreeRTOS/Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 642              		.loc 1 734 0
 643 000c 7B68     		ldr	r3, [r7, #4]
 644 000e 002B     		cmp	r3, #0
 645 0010 12D0     		beq	.L32
 735:FreeRTOS/Source/tasks.c **** 		{
 736:FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 646              		.loc 1 736 0
 647 0012 FFF7FEFF 		bl	vTaskSuspendAll
 737:FreeRTOS/Source/tasks.c **** 			{
 738:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY();
 739:FreeRTOS/Source/tasks.c **** 
 740:FreeRTOS/Source/tasks.c **** 				/* A task that is removed from the event list while the
 741:FreeRTOS/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 742:FreeRTOS/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 743:FreeRTOS/Source/tasks.c **** 				is resumed.
 744:FreeRTOS/Source/tasks.c **** 
 745:FreeRTOS/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 746:FreeRTOS/Source/tasks.c **** 				executing task. */
 747:FreeRTOS/Source/tasks.c **** 
 748:FreeRTOS/Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 749:FreeRTOS/Source/tasks.c **** 				not a problem. */
 750:FreeRTOS/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 648              		.loc 1 750 0
 649 0016 0C4B     		ldr	r3, .L34
 650 0018 1A68     		ldr	r2, [r3]
 651 001a 7B68     		ldr	r3, [r7, #4]
 652 001c 1344     		add	r3, r3, r2
 653 001e BB60     		str	r3, [r7, #8]
 751:FreeRTOS/Source/tasks.c **** 
 752:FreeRTOS/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 753:FreeRTOS/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 754:FreeRTOS/Source/tasks.c **** 				both lists. */
 755:FreeRTOS/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 654              		.loc 1 755 0
 655 0020 0A4B     		ldr	r3, .L34+4
 656 0022 1B68     		ldr	r3, [r3]
 657 0024 0433     		adds	r3, r3, #4
 658 0026 1846     		mov	r0, r3
 659 0028 FFF7FEFF 		bl	vListRemove
 756:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 660              		.loc 1 756 0
 661 002c B868     		ldr	r0, [r7, #8]
 662 002e FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 757:FreeRTOS/Source/tasks.c **** 			}
 758:FreeRTOS/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 663              		.loc 1 758 0
 664 0032 FFF7FEFF 		bl	xTaskResumeAll
 665 0036 F860     		str	r0, [r7, #12]
 666              	.L32:
 759:FreeRTOS/Source/tasks.c **** 		}
 760:FreeRTOS/Source/tasks.c **** 
 761:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 762:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 763:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 667              		.loc 1 763 0
 668 0038 FB68     		ldr	r3, [r7, #12]
 669 003a 002B     		cmp	r3, #0
 670 003c 01D1     		bne	.L31
 764:FreeRTOS/Source/tasks.c **** 		{
 765:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 671              		.loc 1 765 0
 672 003e FFF7FEFF 		bl	vPortYieldFromISR
 673              	.L31:
 766:FreeRTOS/Source/tasks.c **** 		}
 767:FreeRTOS/Source/tasks.c **** 	}
 674              		.loc 1 767 0
 675 0042 1037     		adds	r7, r7, #16
 676 0044 BD46     		mov	sp, r7
 677              		@ sp needed
 678 0046 80BD     		pop	{r7, pc}
 679              	.L35:
 680              		.align	2
 681              	.L34:
 682 0048 00000000 		.word	xTickCount
 683 004c 00000000 		.word	pxCurrentTCB
 684              		.cfi_endproc
 685              	.LFE113:
 687              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 688              		.align	2
 689              		.global	uxTaskPriorityGet
 690              		.thumb
 691              		.thumb_func
 693              	uxTaskPriorityGet:
 694              	.LFB114:
 768:FreeRTOS/Source/tasks.c **** 
 769:FreeRTOS/Source/tasks.c **** #endif
 770:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 771:FreeRTOS/Source/tasks.c **** 
 772:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 773:FreeRTOS/Source/tasks.c **** 
 774:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 775:FreeRTOS/Source/tasks.c **** 	{
 695              		.loc 1 775 0
 696              		.cfi_startproc
 697              		@ args = 0, pretend = 0, frame = 16
 698              		@ frame_needed = 1, uses_anonymous_args = 0
 699 0000 80B5     		push	{r7, lr}
 700              	.LCFI12:
 701              		.cfi_def_cfa_offset 8
 702              		.cfi_offset 7, -8
 703              		.cfi_offset 14, -4
 704 0002 84B0     		sub	sp, sp, #16
 705              	.LCFI13:
 706              		.cfi_def_cfa_offset 24
 707 0004 00AF     		add	r7, sp, #0
 708              	.LCFI14:
 709              		.cfi_def_cfa_register 7
 710 0006 7860     		str	r0, [r7, #4]
 776:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 777:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 778:FreeRTOS/Source/tasks.c **** 
 779:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 711              		.loc 1 779 0
 712 0008 FFF7FEFF 		bl	vPortEnterCritical
 780:FreeRTOS/Source/tasks.c **** 		{
 781:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 782:FreeRTOS/Source/tasks.c **** 			priority of the calling function. */
 783:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 713              		.loc 1 783 0
 714 000c 7B68     		ldr	r3, [r7, #4]
 715 000e 002B     		cmp	r3, #0
 716 0010 02D1     		bne	.L37
 717              		.loc 1 783 0 is_stmt 0 discriminator 1
 718 0012 074B     		ldr	r3, .L40
 719 0014 1B68     		ldr	r3, [r3]
 720 0016 00E0     		b	.L38
 721              	.L37:
 722              		.loc 1 783 0 discriminator 2
 723 0018 7B68     		ldr	r3, [r7, #4]
 724              	.L38:
 725              		.loc 1 783 0 discriminator 3
 726 001a FB60     		str	r3, [r7, #12]
 784:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 727              		.loc 1 784 0 is_stmt 1 discriminator 3
 728 001c FB68     		ldr	r3, [r7, #12]
 729 001e DB6A     		ldr	r3, [r3, #44]
 730 0020 BB60     		str	r3, [r7, #8]
 785:FreeRTOS/Source/tasks.c **** 		}
 786:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 731              		.loc 1 786 0 discriminator 3
 732 0022 FFF7FEFF 		bl	vPortExitCritical
 787:FreeRTOS/Source/tasks.c **** 
 788:FreeRTOS/Source/tasks.c **** 		return uxReturn;
 733              		.loc 1 788 0 discriminator 3
 734 0026 BB68     		ldr	r3, [r7, #8]
 789:FreeRTOS/Source/tasks.c **** 	}
 735              		.loc 1 789 0 discriminator 3
 736 0028 1846     		mov	r0, r3
 737 002a 1037     		adds	r7, r7, #16
 738 002c BD46     		mov	sp, r7
 739              		@ sp needed
 740 002e 80BD     		pop	{r7, pc}
 741              	.L41:
 742              		.align	2
 743              	.L40:
 744 0030 00000000 		.word	pxCurrentTCB
 745              		.cfi_endproc
 746              	.LFE114:
 748              		.section	.text.vTaskPrioritySet,"ax",%progbits
 749              		.align	2
 750              		.global	vTaskPrioritySet
 751              		.thumb
 752              		.thumb_func
 754              	vTaskPrioritySet:
 755              	.LFB115:
 790:FreeRTOS/Source/tasks.c **** 
 791:FreeRTOS/Source/tasks.c **** #endif
 792:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 793:FreeRTOS/Source/tasks.c **** 
 794:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 795:FreeRTOS/Source/tasks.c **** 
 796:FreeRTOS/Source/tasks.c **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 797:FreeRTOS/Source/tasks.c **** 	{
 756              		.loc 1 797 0
 757              		.cfi_startproc
 758              		@ args = 0, pretend = 0, frame = 24
 759              		@ frame_needed = 1, uses_anonymous_args = 0
 760 0000 80B5     		push	{r7, lr}
 761              	.LCFI15:
 762              		.cfi_def_cfa_offset 8
 763              		.cfi_offset 7, -8
 764              		.cfi_offset 14, -4
 765 0002 86B0     		sub	sp, sp, #24
 766              	.LCFI16:
 767              		.cfi_def_cfa_offset 32
 768 0004 00AF     		add	r7, sp, #0
 769              	.LCFI17:
 770              		.cfi_def_cfa_register 7
 771 0006 7860     		str	r0, [r7, #4]
 772 0008 3960     		str	r1, [r7]
 798:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 799:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority;
 800:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 773              		.loc 1 800 0
 774 000a 0023     		movs	r3, #0
 775 000c 7B61     		str	r3, [r7, #20]
 801:FreeRTOS/Source/tasks.c **** 
 802:FreeRTOS/Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 803:FreeRTOS/Source/tasks.c **** 
 804:FreeRTOS/Source/tasks.c **** 		/* Ensure the new priority is valid. */
 805:FreeRTOS/Source/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 776              		.loc 1 805 0
 777 000e 3B68     		ldr	r3, [r7]
 778 0010 042B     		cmp	r3, #4
 779 0012 01D9     		bls	.L43
 806:FreeRTOS/Source/tasks.c **** 		{
 807:FreeRTOS/Source/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 780              		.loc 1 807 0
 781 0014 0423     		movs	r3, #4
 782 0016 3B60     		str	r3, [r7]
 783              	.L43:
 808:FreeRTOS/Source/tasks.c **** 		}
 809:FreeRTOS/Source/tasks.c **** 
 810:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 784              		.loc 1 810 0
 785 0018 FFF7FEFF 		bl	vPortEnterCritical
 811:FreeRTOS/Source/tasks.c **** 		{
 812:FreeRTOS/Source/tasks.c **** 			if( pxTask == pxCurrentTCB )
 786              		.loc 1 812 0
 787 001c 334B     		ldr	r3, .L54
 788 001e 1B68     		ldr	r3, [r3]
 789 0020 7A68     		ldr	r2, [r7, #4]
 790 0022 9A42     		cmp	r2, r3
 791 0024 01D1     		bne	.L44
 813:FreeRTOS/Source/tasks.c **** 			{
 814:FreeRTOS/Source/tasks.c **** 				pxTask = NULL;
 792              		.loc 1 814 0
 793 0026 0023     		movs	r3, #0
 794 0028 7B60     		str	r3, [r7, #4]
 795              	.L44:
 815:FreeRTOS/Source/tasks.c **** 			}
 816:FreeRTOS/Source/tasks.c **** 
 817:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 818:FreeRTOS/Source/tasks.c **** 			priority of the calling function. */
 819:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 796              		.loc 1 819 0
 797 002a 7B68     		ldr	r3, [r7, #4]
 798 002c 002B     		cmp	r3, #0
 799 002e 02D1     		bne	.L45
 800              		.loc 1 819 0 is_stmt 0 discriminator 1
 801 0030 2E4B     		ldr	r3, .L54
 802 0032 1B68     		ldr	r3, [r3]
 803 0034 00E0     		b	.L46
 804              	.L45:
 805              		.loc 1 819 0 discriminator 2
 806 0036 7B68     		ldr	r3, [r7, #4]
 807              	.L46:
 808              		.loc 1 819 0 discriminator 3
 809 0038 3B61     		str	r3, [r7, #16]
 820:FreeRTOS/Source/tasks.c **** 
 821:FreeRTOS/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTask, uxNewPriority );
 822:FreeRTOS/Source/tasks.c **** 
 823:FreeRTOS/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 824:FreeRTOS/Source/tasks.c **** 			{
 825:FreeRTOS/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 810              		.loc 1 825 0 is_stmt 1 discriminator 3
 811 003a 3B69     		ldr	r3, [r7, #16]
 812 003c 5B6C     		ldr	r3, [r3, #68]
 813 003e FB60     		str	r3, [r7, #12]
 826:FreeRTOS/Source/tasks.c **** 			}
 827:FreeRTOS/Source/tasks.c **** 			#else
 828:FreeRTOS/Source/tasks.c **** 			{
 829:FreeRTOS/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 830:FreeRTOS/Source/tasks.c **** 			}
 831:FreeRTOS/Source/tasks.c **** 			#endif
 832:FreeRTOS/Source/tasks.c **** 
 833:FreeRTOS/Source/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 814              		.loc 1 833 0 discriminator 3
 815 0040 FA68     		ldr	r2, [r7, #12]
 816 0042 3B68     		ldr	r3, [r7]
 817 0044 9A42     		cmp	r2, r3
 818 0046 4CD0     		beq	.L47
 834:FreeRTOS/Source/tasks.c **** 			{
 835:FreeRTOS/Source/tasks.c **** 				/* The priority change may have readied a task of higher
 836:FreeRTOS/Source/tasks.c **** 				priority than the calling task. */
 837:FreeRTOS/Source/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 819              		.loc 1 837 0
 820 0048 3A68     		ldr	r2, [r7]
 821 004a FB68     		ldr	r3, [r7, #12]
 822 004c 9A42     		cmp	r2, r3
 823 004e 05D9     		bls	.L48
 838:FreeRTOS/Source/tasks.c **** 				{
 839:FreeRTOS/Source/tasks.c **** 					if( pxTask != NULL )
 824              		.loc 1 839 0
 825 0050 7B68     		ldr	r3, [r7, #4]
 826 0052 002B     		cmp	r3, #0
 827 0054 07D0     		beq	.L50
 840:FreeRTOS/Source/tasks.c **** 					{
 841:FreeRTOS/Source/tasks.c **** 						/* The priority of another task is being raised.  If we
 842:FreeRTOS/Source/tasks.c **** 						were raising the priority of the currently running task
 843:FreeRTOS/Source/tasks.c **** 						there would be no need to switch as it must have already
 844:FreeRTOS/Source/tasks.c **** 						been the highest priority task. */
 845:FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 828              		.loc 1 845 0
 829 0056 0123     		movs	r3, #1
 830 0058 7B61     		str	r3, [r7, #20]
 831 005a 04E0     		b	.L50
 832              	.L48:
 846:FreeRTOS/Source/tasks.c **** 					}
 847:FreeRTOS/Source/tasks.c **** 				}
 848:FreeRTOS/Source/tasks.c **** 				else if( pxTask == NULL )
 833              		.loc 1 848 0
 834 005c 7B68     		ldr	r3, [r7, #4]
 835 005e 002B     		cmp	r3, #0
 836 0060 01D1     		bne	.L50
 849:FreeRTOS/Source/tasks.c **** 				{
 850:FreeRTOS/Source/tasks.c **** 					/* Setting our own priority down means there may now be another
 851:FreeRTOS/Source/tasks.c **** 					task of higher priority that is ready to execute. */
 852:FreeRTOS/Source/tasks.c **** 					xYieldRequired = pdTRUE;
 837              		.loc 1 852 0
 838 0062 0123     		movs	r3, #1
 839 0064 7B61     		str	r3, [r7, #20]
 840              	.L50:
 853:FreeRTOS/Source/tasks.c **** 				}
 854:FreeRTOS/Source/tasks.c **** 
 855:FreeRTOS/Source/tasks.c **** 
 856:FreeRTOS/Source/tasks.c **** 
 857:FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 858:FreeRTOS/Source/tasks.c **** 				{
 859:FreeRTOS/Source/tasks.c **** 					/* Only change the priority being used if the task is not
 860:FreeRTOS/Source/tasks.c **** 					currently using an inherited priority. */
 861:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 841              		.loc 1 861 0
 842 0066 3B69     		ldr	r3, [r7, #16]
 843 0068 5A6C     		ldr	r2, [r3, #68]
 844 006a 3B69     		ldr	r3, [r7, #16]
 845 006c DB6A     		ldr	r3, [r3, #44]
 846 006e 9A42     		cmp	r2, r3
 847 0070 02D1     		bne	.L51
 862:FreeRTOS/Source/tasks.c **** 					{
 863:FreeRTOS/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 848              		.loc 1 863 0
 849 0072 3B69     		ldr	r3, [r7, #16]
 850 0074 3A68     		ldr	r2, [r7]
 851 0076 DA62     		str	r2, [r3, #44]
 852              	.L51:
 864:FreeRTOS/Source/tasks.c **** 					}
 865:FreeRTOS/Source/tasks.c **** 
 866:FreeRTOS/Source/tasks.c **** 					/* The base priority gets set whatever. */
 867:FreeRTOS/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 853              		.loc 1 867 0
 854 0078 3B69     		ldr	r3, [r7, #16]
 855 007a 3A68     		ldr	r2, [r7]
 856 007c 5A64     		str	r2, [r3, #68]
 868:FreeRTOS/Source/tasks.c **** 				}
 869:FreeRTOS/Source/tasks.c **** 				#else
 870:FreeRTOS/Source/tasks.c **** 				{
 871:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 872:FreeRTOS/Source/tasks.c **** 				}
 873:FreeRTOS/Source/tasks.c **** 				#endif
 874:FreeRTOS/Source/tasks.c **** 
 875:FreeRTOS/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 857              		.loc 1 875 0
 858 007e 3B68     		ldr	r3, [r7]
 859 0080 C3F10502 		rsb	r2, r3, #5
 860 0084 3B69     		ldr	r3, [r7, #16]
 861 0086 9A61     		str	r2, [r3, #24]
 876:FreeRTOS/Source/tasks.c **** 
 877:FreeRTOS/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
 878:FreeRTOS/Source/tasks.c **** 				nothing more than change it's priority variable. However, if
 879:FreeRTOS/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
 880:FreeRTOS/Source/tasks.c **** 				in the queue appropriate to its new priority. */
 881:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 862              		.loc 1 881 0
 863 0088 3B69     		ldr	r3, [r7, #16]
 864 008a 5969     		ldr	r1, [r3, #20]
 865 008c FA68     		ldr	r2, [r7, #12]
 866 008e 1346     		mov	r3, r2
 867 0090 9B00     		lsls	r3, r3, #2
 868 0092 1344     		add	r3, r3, r2
 869 0094 9B00     		lsls	r3, r3, #2
 870 0096 164A     		ldr	r2, .L54+4
 871 0098 1344     		add	r3, r3, r2
 872 009a 9942     		cmp	r1, r3
 873 009c 1CD1     		bne	.L52
 882:FreeRTOS/Source/tasks.c **** 				{
 883:FreeRTOS/Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
 884:FreeRTOS/Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
 885:FreeRTOS/Source/tasks.c **** 					can do this even if the scheduler is suspended. */
 886:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 874              		.loc 1 886 0
 875 009e 3B69     		ldr	r3, [r7, #16]
 876 00a0 0433     		adds	r3, r3, #4
 877 00a2 1846     		mov	r0, r3
 878 00a4 FFF7FEFF 		bl	vListRemove
 887:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 879              		.loc 1 887 0
 880 00a8 3B69     		ldr	r3, [r7, #16]
 881 00aa DA6A     		ldr	r2, [r3, #44]
 882 00ac 114B     		ldr	r3, .L54+8
 883 00ae 1B68     		ldr	r3, [r3]
 884 00b0 9A42     		cmp	r2, r3
 885 00b2 03D9     		bls	.L53
 886              		.loc 1 887 0 is_stmt 0 discriminator 1
 887 00b4 3B69     		ldr	r3, [r7, #16]
 888 00b6 DA6A     		ldr	r2, [r3, #44]
 889 00b8 0E4B     		ldr	r3, .L54+8
 890 00ba 1A60     		str	r2, [r3]
 891              	.L53:
 892              		.loc 1 887 0 discriminator 2
 893 00bc 3B69     		ldr	r3, [r7, #16]
 894 00be DA6A     		ldr	r2, [r3, #44]
 895 00c0 1346     		mov	r3, r2
 896 00c2 9B00     		lsls	r3, r3, #2
 897 00c4 1344     		add	r3, r3, r2
 898 00c6 9B00     		lsls	r3, r3, #2
 899 00c8 094A     		ldr	r2, .L54+4
 900 00ca 1A44     		add	r2, r2, r3
 901 00cc 3B69     		ldr	r3, [r7, #16]
 902 00ce 0433     		adds	r3, r3, #4
 903 00d0 1046     		mov	r0, r2
 904 00d2 1946     		mov	r1, r3
 905 00d4 FFF7FEFF 		bl	vListInsertEnd
 906              	.L52:
 888:FreeRTOS/Source/tasks.c **** 				}
 889:FreeRTOS/Source/tasks.c **** 
 890:FreeRTOS/Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
 907              		.loc 1 890 0 is_stmt 1
 908 00d8 7B69     		ldr	r3, [r7, #20]
 909 00da 012B     		cmp	r3, #1
 910 00dc 01D1     		bne	.L47
 891:FreeRTOS/Source/tasks.c **** 				{
 892:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
 911              		.loc 1 892 0
 912 00de FFF7FEFF 		bl	vPortYieldFromISR
 913              	.L47:
 893:FreeRTOS/Source/tasks.c **** 				}
 894:FreeRTOS/Source/tasks.c **** 			}
 895:FreeRTOS/Source/tasks.c **** 		}
 896:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 914              		.loc 1 896 0
 915 00e2 FFF7FEFF 		bl	vPortExitCritical
 897:FreeRTOS/Source/tasks.c **** 	}
 916              		.loc 1 897 0
 917 00e6 1837     		adds	r7, r7, #24
 918 00e8 BD46     		mov	sp, r7
 919              		@ sp needed
 920 00ea 80BD     		pop	{r7, pc}
 921              	.L55:
 922              		.align	2
 923              	.L54:
 924 00ec 00000000 		.word	pxCurrentTCB
 925 00f0 00000000 		.word	pxReadyTasksLists
 926 00f4 00000000 		.word	uxTopReadyPriority
 927              		.cfi_endproc
 928              	.LFE115:
 930              		.section	.text.vTaskSuspend,"ax",%progbits
 931              		.align	2
 932              		.global	vTaskSuspend
 933              		.thumb
 934              		.thumb_func
 936              	vTaskSuspend:
 937              	.LFB116:
 898:FreeRTOS/Source/tasks.c **** 
 899:FreeRTOS/Source/tasks.c **** #endif
 900:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 901:FreeRTOS/Source/tasks.c **** 
 902:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 903:FreeRTOS/Source/tasks.c **** 
 904:FreeRTOS/Source/tasks.c **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
 905:FreeRTOS/Source/tasks.c **** 	{
 938              		.loc 1 905 0
 939              		.cfi_startproc
 940              		@ args = 0, pretend = 0, frame = 16
 941              		@ frame_needed = 1, uses_anonymous_args = 0
 942 0000 80B5     		push	{r7, lr}
 943              	.LCFI18:
 944              		.cfi_def_cfa_offset 8
 945              		.cfi_offset 7, -8
 946              		.cfi_offset 14, -4
 947 0002 84B0     		sub	sp, sp, #16
 948              	.LCFI19:
 949              		.cfi_def_cfa_offset 24
 950 0004 00AF     		add	r7, sp, #0
 951              	.LCFI20:
 952              		.cfi_def_cfa_register 7
 953 0006 7860     		str	r0, [r7, #4]
 906:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 907:FreeRTOS/Source/tasks.c **** 
 908:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 954              		.loc 1 908 0
 955 0008 FFF7FEFF 		bl	vPortEnterCritical
 909:FreeRTOS/Source/tasks.c **** 		{
 910:FreeRTOS/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 911:FreeRTOS/Source/tasks.c **** 			suspended. */
 912:FreeRTOS/Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 956              		.loc 1 912 0
 957 000c 1E4B     		ldr	r3, .L64
 958 000e 1B68     		ldr	r3, [r3]
 959 0010 7A68     		ldr	r2, [r7, #4]
 960 0012 9A42     		cmp	r2, r3
 961 0014 01D1     		bne	.L57
 913:FreeRTOS/Source/tasks.c **** 			{
 914:FreeRTOS/Source/tasks.c **** 				pxTaskToSuspend = NULL;
 962              		.loc 1 914 0
 963 0016 0023     		movs	r3, #0
 964 0018 7B60     		str	r3, [r7, #4]
 965              	.L57:
 915:FreeRTOS/Source/tasks.c **** 			}
 916:FreeRTOS/Source/tasks.c **** 
 917:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
 918:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 966              		.loc 1 918 0
 967 001a 7B68     		ldr	r3, [r7, #4]
 968 001c 002B     		cmp	r3, #0
 969 001e 02D1     		bne	.L58
 970              		.loc 1 918 0 is_stmt 0 discriminator 1
 971 0020 194B     		ldr	r3, .L64
 972 0022 1B68     		ldr	r3, [r3]
 973 0024 00E0     		b	.L59
 974              	.L58:
 975              		.loc 1 918 0 discriminator 2
 976 0026 7B68     		ldr	r3, [r7, #4]
 977              	.L59:
 978              		.loc 1 918 0 discriminator 3
 979 0028 FB60     		str	r3, [r7, #12]
 919:FreeRTOS/Source/tasks.c **** 
 920:FreeRTOS/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
 921:FreeRTOS/Source/tasks.c **** 
 922:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
 923:FreeRTOS/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 980              		.loc 1 923 0 is_stmt 1 discriminator 3
 981 002a FB68     		ldr	r3, [r7, #12]
 982 002c 0433     		adds	r3, r3, #4
 983 002e 1846     		mov	r0, r3
 984 0030 FFF7FEFF 		bl	vListRemove
 924:FreeRTOS/Source/tasks.c **** 
 925:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 926:FreeRTOS/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 985              		.loc 1 926 0 discriminator 3
 986 0034 FB68     		ldr	r3, [r7, #12]
 987 0036 9B6A     		ldr	r3, [r3, #40]
 988 0038 002B     		cmp	r3, #0
 989 003a 04D0     		beq	.L60
 927:FreeRTOS/Source/tasks.c **** 			{
 928:FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 990              		.loc 1 928 0
 991 003c FB68     		ldr	r3, [r7, #12]
 992 003e 1833     		adds	r3, r3, #24
 993 0040 1846     		mov	r0, r3
 994 0042 FFF7FEFF 		bl	vListRemove
 995              	.L60:
 929:FreeRTOS/Source/tasks.c **** 			}
 930:FreeRTOS/Source/tasks.c **** 
 931:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 996              		.loc 1 931 0
 997 0046 FB68     		ldr	r3, [r7, #12]
 998 0048 0433     		adds	r3, r3, #4
 999 004a 1048     		ldr	r0, .L64+4
 1000 004c 1946     		mov	r1, r3
 1001 004e FFF7FEFF 		bl	vListInsertEnd
 932:FreeRTOS/Source/tasks.c **** 		}
 933:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 1002              		.loc 1 933 0
 1003 0052 FFF7FEFF 		bl	vPortExitCritical
 934:FreeRTOS/Source/tasks.c **** 
 935:FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 1004              		.loc 1 935 0
 1005 0056 7B68     		ldr	r3, [r7, #4]
 1006 0058 002B     		cmp	r3, #0
 1007 005a 12D1     		bne	.L56
 936:FreeRTOS/Source/tasks.c **** 		{
 937:FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 1008              		.loc 1 937 0
 1009 005c 0C4B     		ldr	r3, .L64+8
 1010 005e 1B68     		ldr	r3, [r3]
 1011 0060 002B     		cmp	r3, #0
 1012 0062 02D0     		beq	.L62
 938:FreeRTOS/Source/tasks.c **** 			{
 939:FreeRTOS/Source/tasks.c **** 				/* We have just suspended the current task. */
 940:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 1013              		.loc 1 940 0
 1014 0064 FFF7FEFF 		bl	vPortYieldFromISR
 1015 0068 0BE0     		b	.L56
 1016              	.L62:
 941:FreeRTOS/Source/tasks.c **** 			}
 942:FreeRTOS/Source/tasks.c **** 			else
 943:FreeRTOS/Source/tasks.c **** 			{
 944:FreeRTOS/Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
 945:FreeRTOS/Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
 946:FreeRTOS/Source/tasks.c **** 				must be adjusted to point to a different task. */
 947:FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 1017              		.loc 1 947 0
 1018 006a 084B     		ldr	r3, .L64+4
 1019 006c 1A68     		ldr	r2, [r3]
 1020 006e 094B     		ldr	r3, .L64+12
 1021 0070 1B68     		ldr	r3, [r3]
 1022 0072 9A42     		cmp	r2, r3
 1023 0074 03D1     		bne	.L63
 948:FreeRTOS/Source/tasks.c **** 				{
 949:FreeRTOS/Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
 950:FreeRTOS/Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
 951:FreeRTOS/Source/tasks.c **** 					be set to point to it no matter what its relative priority
 952:FreeRTOS/Source/tasks.c **** 					is. */
 953:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = NULL;
 1024              		.loc 1 953 0
 1025 0076 044B     		ldr	r3, .L64
 1026 0078 0022     		movs	r2, #0
 1027 007a 1A60     		str	r2, [r3]
 1028 007c 01E0     		b	.L56
 1029              	.L63:
 954:FreeRTOS/Source/tasks.c **** 				}
 955:FreeRTOS/Source/tasks.c **** 				else
 956:FreeRTOS/Source/tasks.c **** 				{
 957:FreeRTOS/Source/tasks.c **** 					vTaskSwitchContext();
 1030              		.loc 1 957 0
 1031 007e FFF7FEFF 		bl	vTaskSwitchContext
 1032              	.L56:
 958:FreeRTOS/Source/tasks.c **** 				}
 959:FreeRTOS/Source/tasks.c **** 			}
 960:FreeRTOS/Source/tasks.c **** 		}
 961:FreeRTOS/Source/tasks.c **** 	}
 1033              		.loc 1 961 0
 1034 0082 1037     		adds	r7, r7, #16
 1035 0084 BD46     		mov	sp, r7
 1036              		@ sp needed
 1037 0086 80BD     		pop	{r7, pc}
 1038              	.L65:
 1039              		.align	2
 1040              	.L64:
 1041 0088 00000000 		.word	pxCurrentTCB
 1042 008c 00000000 		.word	xSuspendedTaskList
 1043 0090 00000000 		.word	xSchedulerRunning
 1044 0094 00000000 		.word	uxCurrentNumberOfTasks
 1045              		.cfi_endproc
 1046              	.LFE116:
 1048              		.section	.text.xTaskIsTaskSuspended,"ax",%progbits
 1049              		.align	2
 1050              		.global	xTaskIsTaskSuspended
 1051              		.thumb
 1052              		.thumb_func
 1054              	xTaskIsTaskSuspended:
 1055              	.LFB117:
 962:FreeRTOS/Source/tasks.c **** 
 963:FreeRTOS/Source/tasks.c **** #endif
 964:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 965:FreeRTOS/Source/tasks.c **** 
 966:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 967:FreeRTOS/Source/tasks.c **** 
 968:FreeRTOS/Source/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
 969:FreeRTOS/Source/tasks.c **** 	{
 1056              		.loc 1 969 0
 1057              		.cfi_startproc
 1058              		@ args = 0, pretend = 0, frame = 16
 1059              		@ frame_needed = 1, uses_anonymous_args = 0
 1060              		@ link register save eliminated.
 1061 0000 80B4     		push	{r7}
 1062              	.LCFI21:
 1063              		.cfi_def_cfa_offset 4
 1064              		.cfi_offset 7, -4
 1065 0002 85B0     		sub	sp, sp, #20
 1066              	.LCFI22:
 1067              		.cfi_def_cfa_offset 24
 1068 0004 00AF     		add	r7, sp, #0
 1069              	.LCFI23:
 1070              		.cfi_def_cfa_register 7
 1071 0006 7860     		str	r0, [r7, #4]
 970:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 1072              		.loc 1 970 0
 1073 0008 0023     		movs	r3, #0
 1074 000a FB60     		str	r3, [r7, #12]
 971:FreeRTOS/Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 1075              		.loc 1 971 0
 1076 000c 7B68     		ldr	r3, [r7, #4]
 1077 000e BB60     		str	r3, [r7, #8]
 972:FreeRTOS/Source/tasks.c **** 
 973:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
 974:FreeRTOS/Source/tasks.c **** 		configASSERT( xTask );
 975:FreeRTOS/Source/tasks.c **** 
 976:FreeRTOS/Source/tasks.c **** 		/* Is the task we are attempting to resume actually in the
 977:FreeRTOS/Source/tasks.c **** 		suspended list? */
 978:FreeRTOS/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 1078              		.loc 1 978 0
 1079 0010 BB68     		ldr	r3, [r7, #8]
 1080 0012 5A69     		ldr	r2, [r3, #20]
 1081 0014 0A4B     		ldr	r3, .L69
 1082 0016 9A42     		cmp	r2, r3
 1083 0018 0AD1     		bne	.L67
 979:FreeRTOS/Source/tasks.c **** 		{
 980:FreeRTOS/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
 981:FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 1084              		.loc 1 981 0
 1085 001a BB68     		ldr	r3, [r7, #8]
 1086 001c 9A6A     		ldr	r2, [r3, #40]
 1087 001e 094B     		ldr	r3, .L69+4
 1088 0020 9A42     		cmp	r2, r3
 1089 0022 05D0     		beq	.L67
 982:FreeRTOS/Source/tasks.c **** 			{
 983:FreeRTOS/Source/tasks.c **** 				/* Is it in the suspended list because it is in the
 984:FreeRTOS/Source/tasks.c **** 				Suspended state?  It is possible to be in the suspended
 985:FreeRTOS/Source/tasks.c **** 				list because it is blocked on a task with no timeout
 986:FreeRTOS/Source/tasks.c **** 				specified. */
 987:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 1090              		.loc 1 987 0
 1091 0024 BB68     		ldr	r3, [r7, #8]
 1092 0026 9B6A     		ldr	r3, [r3, #40]
 1093 0028 002B     		cmp	r3, #0
 1094 002a 01D1     		bne	.L67
 988:FreeRTOS/Source/tasks.c **** 				{
 989:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
 1095              		.loc 1 989 0
 1096 002c 0123     		movs	r3, #1
 1097 002e FB60     		str	r3, [r7, #12]
 1098              	.L67:
 990:FreeRTOS/Source/tasks.c **** 				}
 991:FreeRTOS/Source/tasks.c **** 			}
 992:FreeRTOS/Source/tasks.c **** 		}
 993:FreeRTOS/Source/tasks.c **** 
 994:FreeRTOS/Source/tasks.c **** 		return xReturn;
 1099              		.loc 1 994 0
 1100 0030 FB68     		ldr	r3, [r7, #12]
 995:FreeRTOS/Source/tasks.c **** 	}
 1101              		.loc 1 995 0
 1102 0032 1846     		mov	r0, r3
 1103 0034 1437     		adds	r7, r7, #20
 1104 0036 BD46     		mov	sp, r7
 1105              		@ sp needed
 1106 0038 5DF8047B 		ldr	r7, [sp], #4
 1107 003c 7047     		bx	lr
 1108              	.L70:
 1109 003e 00BF     		.align	2
 1110              	.L69:
 1111 0040 00000000 		.word	xSuspendedTaskList
 1112 0044 00000000 		.word	xPendingReadyList
 1113              		.cfi_endproc
 1114              	.LFE117:
 1116              		.section	.text.vTaskResume,"ax",%progbits
 1117              		.align	2
 1118              		.global	vTaskResume
 1119              		.thumb
 1120              		.thumb_func
 1122              	vTaskResume:
 1123              	.LFB118:
 996:FreeRTOS/Source/tasks.c **** 
 997:FreeRTOS/Source/tasks.c **** #endif
 998:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 999:FreeRTOS/Source/tasks.c **** 
1000:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1001:FreeRTOS/Source/tasks.c **** 
1002:FreeRTOS/Source/tasks.c **** 	void vTaskResume( xTaskHandle pxTaskToResume )
1003:FreeRTOS/Source/tasks.c **** 	{
 1124              		.loc 1 1003 0
 1125              		.cfi_startproc
 1126              		@ args = 0, pretend = 0, frame = 16
 1127              		@ frame_needed = 1, uses_anonymous_args = 0
 1128 0000 80B5     		push	{r7, lr}
 1129              	.LCFI24:
 1130              		.cfi_def_cfa_offset 8
 1131              		.cfi_offset 7, -8
 1132              		.cfi_offset 14, -4
 1133 0002 84B0     		sub	sp, sp, #16
 1134              	.LCFI25:
 1135              		.cfi_def_cfa_offset 24
 1136 0004 00AF     		add	r7, sp, #0
 1137              	.LCFI26:
 1138              		.cfi_def_cfa_register 7
 1139 0006 7860     		str	r0, [r7, #4]
1004:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1005:FreeRTOS/Source/tasks.c **** 
1006:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1007:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskToResume );
1008:FreeRTOS/Source/tasks.c **** 
1009:FreeRTOS/Source/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
1010:FreeRTOS/Source/tasks.c **** 		it in the ready list. */
1011:FreeRTOS/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1140              		.loc 1 1011 0
 1141 0008 7B68     		ldr	r3, [r7, #4]
 1142 000a FB60     		str	r3, [r7, #12]
1012:FreeRTOS/Source/tasks.c **** 
1013:FreeRTOS/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1014:FreeRTOS/Source/tasks.c **** 		currently executing task. */
1015:FreeRTOS/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1143              		.loc 1 1015 0
 1144 000c FB68     		ldr	r3, [r7, #12]
 1145 000e 002B     		cmp	r3, #0
 1146 0010 34D0     		beq	.L71
 1147              		.loc 1 1015 0 is_stmt 0 discriminator 1
 1148 0012 1C4B     		ldr	r3, .L75
 1149 0014 1B68     		ldr	r3, [r3]
 1150 0016 FA68     		ldr	r2, [r7, #12]
 1151 0018 9A42     		cmp	r2, r3
 1152 001a 2FD0     		beq	.L71
1016:FreeRTOS/Source/tasks.c **** 		{
1017:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
 1153              		.loc 1 1017 0 is_stmt 1
 1154 001c FFF7FEFF 		bl	vPortEnterCritical
1018:FreeRTOS/Source/tasks.c **** 			{
1019:FreeRTOS/Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1155              		.loc 1 1019 0
 1156 0020 F868     		ldr	r0, [r7, #12]
 1157 0022 FFF7FEFF 		bl	xTaskIsTaskSuspended
 1158 0026 0346     		mov	r3, r0
 1159 0028 012B     		cmp	r3, #1
 1160 002a 25D1     		bne	.L73
1020:FreeRTOS/Source/tasks.c **** 				{
1021:FreeRTOS/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1022:FreeRTOS/Source/tasks.c **** 
1023:FreeRTOS/Source/tasks.c **** 					/* As we are in a critical section we can access the ready
1024:FreeRTOS/Source/tasks.c **** 					lists even if the scheduler is suspended. */
1025:FreeRTOS/Source/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 1161              		.loc 1 1025 0
 1162 002c FB68     		ldr	r3, [r7, #12]
 1163 002e 0433     		adds	r3, r3, #4
 1164 0030 1846     		mov	r0, r3
 1165 0032 FFF7FEFF 		bl	vListRemove
1026:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1166              		.loc 1 1026 0
 1167 0036 FB68     		ldr	r3, [r7, #12]
 1168 0038 DA6A     		ldr	r2, [r3, #44]
 1169 003a 134B     		ldr	r3, .L75+4
 1170 003c 1B68     		ldr	r3, [r3]
 1171 003e 9A42     		cmp	r2, r3
 1172 0040 03D9     		bls	.L74
 1173              		.loc 1 1026 0 is_stmt 0 discriminator 1
 1174 0042 FB68     		ldr	r3, [r7, #12]
 1175 0044 DA6A     		ldr	r2, [r3, #44]
 1176 0046 104B     		ldr	r3, .L75+4
 1177 0048 1A60     		str	r2, [r3]
 1178              	.L74:
 1179              		.loc 1 1026 0 discriminator 2
 1180 004a FB68     		ldr	r3, [r7, #12]
 1181 004c DA6A     		ldr	r2, [r3, #44]
 1182 004e 1346     		mov	r3, r2
 1183 0050 9B00     		lsls	r3, r3, #2
 1184 0052 1344     		add	r3, r3, r2
 1185 0054 9B00     		lsls	r3, r3, #2
 1186 0056 0D4A     		ldr	r2, .L75+8
 1187 0058 1A44     		add	r2, r2, r3
 1188 005a FB68     		ldr	r3, [r7, #12]
 1189 005c 0433     		adds	r3, r3, #4
 1190 005e 1046     		mov	r0, r2
 1191 0060 1946     		mov	r1, r3
 1192 0062 FFF7FEFF 		bl	vListInsertEnd
1027:FreeRTOS/Source/tasks.c **** 
1028:FreeRTOS/Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
1029:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1193              		.loc 1 1029 0 is_stmt 1 discriminator 2
 1194 0066 FB68     		ldr	r3, [r7, #12]
 1195 0068 DA6A     		ldr	r2, [r3, #44]
 1196 006a 064B     		ldr	r3, .L75
 1197 006c 1B68     		ldr	r3, [r3]
 1198 006e DB6A     		ldr	r3, [r3, #44]
 1199 0070 9A42     		cmp	r2, r3
 1200 0072 01D3     		bcc	.L73
1030:FreeRTOS/Source/tasks.c **** 					{
1031:FreeRTOS/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
1032:FreeRTOS/Source/tasks.c **** 						will leave the lists in the correct state for the next yield. */
1033:FreeRTOS/Source/tasks.c **** 						portYIELD_WITHIN_API();
 1201              		.loc 1 1033 0
 1202 0074 FFF7FEFF 		bl	vPortYieldFromISR
 1203              	.L73:
1034:FreeRTOS/Source/tasks.c **** 					}
1035:FreeRTOS/Source/tasks.c **** 				}
1036:FreeRTOS/Source/tasks.c **** 			}
1037:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
 1204              		.loc 1 1037 0
 1205 0078 FFF7FEFF 		bl	vPortExitCritical
 1206              	.L71:
1038:FreeRTOS/Source/tasks.c **** 		}
1039:FreeRTOS/Source/tasks.c **** 	}
 1207              		.loc 1 1039 0
 1208 007c 1037     		adds	r7, r7, #16
 1209 007e BD46     		mov	sp, r7
 1210              		@ sp needed
 1211 0080 80BD     		pop	{r7, pc}
 1212              	.L76:
 1213 0082 00BF     		.align	2
 1214              	.L75:
 1215 0084 00000000 		.word	pxCurrentTCB
 1216 0088 00000000 		.word	uxTopReadyPriority
 1217 008c 00000000 		.word	pxReadyTasksLists
 1218              		.cfi_endproc
 1219              	.LFE118:
 1221              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1222              		.align	2
 1223              		.global	xTaskResumeFromISR
 1224              		.thumb
 1225              		.thumb_func
 1227              	xTaskResumeFromISR:
 1228              	.LFB119:
1040:FreeRTOS/Source/tasks.c **** 
1041:FreeRTOS/Source/tasks.c **** #endif
1042:FreeRTOS/Source/tasks.c **** 
1043:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1044:FreeRTOS/Source/tasks.c **** 
1045:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1046:FreeRTOS/Source/tasks.c **** 
1047:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
1048:FreeRTOS/Source/tasks.c **** 	{
 1229              		.loc 1 1048 0
 1230              		.cfi_startproc
 1231              		@ args = 0, pretend = 0, frame = 16
 1232              		@ frame_needed = 1, uses_anonymous_args = 0
 1233 0000 80B5     		push	{r7, lr}
 1234              	.LCFI27:
 1235              		.cfi_def_cfa_offset 8
 1236              		.cfi_offset 7, -8
 1237              		.cfi_offset 14, -4
 1238 0002 84B0     		sub	sp, sp, #16
 1239              	.LCFI28:
 1240              		.cfi_def_cfa_offset 24
 1241 0004 00AF     		add	r7, sp, #0
 1242              	.LCFI29:
 1243              		.cfi_def_cfa_register 7
 1244 0006 7860     		str	r0, [r7, #4]
1049:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 1245              		.loc 1 1049 0
 1246 0008 0023     		movs	r3, #0
 1247 000a FB60     		str	r3, [r7, #12]
1050:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1051:FreeRTOS/Source/tasks.c **** 
1052:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskToResume );
1053:FreeRTOS/Source/tasks.c **** 
1054:FreeRTOS/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1248              		.loc 1 1054 0
 1249 000c 7B68     		ldr	r3, [r7, #4]
 1250 000e BB60     		str	r3, [r7, #8]
1055:FreeRTOS/Source/tasks.c **** 
1056:FreeRTOS/Source/tasks.c **** 		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1251              		.loc 1 1056 0
 1252 0010 B868     		ldr	r0, [r7, #8]
 1253 0012 FFF7FEFF 		bl	xTaskIsTaskSuspended
 1254 0016 0346     		mov	r3, r0
 1255 0018 012B     		cmp	r3, #1
 1256 001a 32D1     		bne	.L78
1057:FreeRTOS/Source/tasks.c **** 		{
1058:FreeRTOS/Source/tasks.c **** 			traceTASK_RESUME_FROM_ISR( pxTCB );
1059:FreeRTOS/Source/tasks.c **** 
1060:FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1257              		.loc 1 1060 0
 1258 001c 1B4B     		ldr	r3, .L82
 1259 001e 1B68     		ldr	r3, [r3]
 1260 0020 002B     		cmp	r3, #0
 1261 0022 28D1     		bne	.L79
1061:FreeRTOS/Source/tasks.c **** 			{
1062:FreeRTOS/Source/tasks.c **** 				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 1262              		.loc 1 1062 0
 1263 0024 BB68     		ldr	r3, [r7, #8]
 1264 0026 DA6A     		ldr	r2, [r3, #44]
 1265 0028 194B     		ldr	r3, .L82+4
 1266 002a 1B68     		ldr	r3, [r3]
 1267 002c DB6A     		ldr	r3, [r3, #44]
 1268 002e 9A42     		cmp	r2, r3
 1269 0030 34BF     		ite	cc
 1270 0032 0023     		movcc	r3, #0
 1271 0034 0123     		movcs	r3, #1
 1272 0036 DBB2     		uxtb	r3, r3
 1273 0038 FB60     		str	r3, [r7, #12]
1063:FreeRTOS/Source/tasks.c **** 				vListRemove(  &( pxTCB->xGenericListItem ) );
 1274              		.loc 1 1063 0
 1275 003a BB68     		ldr	r3, [r7, #8]
 1276 003c 0433     		adds	r3, r3, #4
 1277 003e 1846     		mov	r0, r3
 1278 0040 FFF7FEFF 		bl	vListRemove
1064:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 1279              		.loc 1 1064 0
 1280 0044 BB68     		ldr	r3, [r7, #8]
 1281 0046 DA6A     		ldr	r2, [r3, #44]
 1282 0048 124B     		ldr	r3, .L82+8
 1283 004a 1B68     		ldr	r3, [r3]
 1284 004c 9A42     		cmp	r2, r3
 1285 004e 03D9     		bls	.L80
 1286              		.loc 1 1064 0 is_stmt 0 discriminator 1
 1287 0050 BB68     		ldr	r3, [r7, #8]
 1288 0052 DA6A     		ldr	r2, [r3, #44]
 1289 0054 0F4B     		ldr	r3, .L82+8
 1290 0056 1A60     		str	r2, [r3]
 1291              	.L80:
 1292              		.loc 1 1064 0 discriminator 2
 1293 0058 BB68     		ldr	r3, [r7, #8]
 1294 005a DA6A     		ldr	r2, [r3, #44]
 1295 005c 1346     		mov	r3, r2
 1296 005e 9B00     		lsls	r3, r3, #2
 1297 0060 1344     		add	r3, r3, r2
 1298 0062 9B00     		lsls	r3, r3, #2
 1299 0064 0C4A     		ldr	r2, .L82+12
 1300 0066 1A44     		add	r2, r2, r3
 1301 0068 BB68     		ldr	r3, [r7, #8]
 1302 006a 0433     		adds	r3, r3, #4
 1303 006c 1046     		mov	r0, r2
 1304 006e 1946     		mov	r1, r3
 1305 0070 FFF7FEFF 		bl	vListInsertEnd
 1306 0074 05E0     		b	.L78
 1307              	.L79:
1065:FreeRTOS/Source/tasks.c **** 			}
1066:FreeRTOS/Source/tasks.c **** 			else
1067:FreeRTOS/Source/tasks.c **** 			{
1068:FreeRTOS/Source/tasks.c **** 				/* We cannot access the delayed or ready lists, so will hold this
1069:FreeRTOS/Source/tasks.c **** 				task pending until the scheduler is resumed, at which point a
1070:FreeRTOS/Source/tasks.c **** 				yield will be performed if necessary. */
1071:FreeRTOS/Source/tasks.c **** 				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1308              		.loc 1 1071 0 is_stmt 1
 1309 0076 BB68     		ldr	r3, [r7, #8]
 1310 0078 1833     		adds	r3, r3, #24
 1311 007a 0848     		ldr	r0, .L82+16
 1312 007c 1946     		mov	r1, r3
 1313 007e FFF7FEFF 		bl	vListInsertEnd
 1314              	.L78:
1072:FreeRTOS/Source/tasks.c **** 			}
1073:FreeRTOS/Source/tasks.c **** 		}
1074:FreeRTOS/Source/tasks.c **** 
1075:FreeRTOS/Source/tasks.c **** 		return xYieldRequired;
 1315              		.loc 1 1075 0
 1316 0082 FB68     		ldr	r3, [r7, #12]
1076:FreeRTOS/Source/tasks.c **** 	}
 1317              		.loc 1 1076 0
 1318 0084 1846     		mov	r0, r3
 1319 0086 1037     		adds	r7, r7, #16
 1320 0088 BD46     		mov	sp, r7
 1321              		@ sp needed
 1322 008a 80BD     		pop	{r7, pc}
 1323              	.L83:
 1324              		.align	2
 1325              	.L82:
 1326 008c 00000000 		.word	uxSchedulerSuspended
 1327 0090 00000000 		.word	pxCurrentTCB
 1328 0094 00000000 		.word	uxTopReadyPriority
 1329 0098 00000000 		.word	pxReadyTasksLists
 1330 009c 00000000 		.word	xPendingReadyList
 1331              		.cfi_endproc
 1332              	.LFE119:
 1334              		.section	.rodata
 1335              		.align	2
 1336              	.LC0:
 1337 0000 49444C45 		.ascii	"IDLE\000"
 1337      00
 1338              		.section	.text.vTaskStartScheduler,"ax",%progbits
 1339              		.align	2
 1340              		.global	vTaskStartScheduler
 1341              		.thumb
 1342              		.thumb_func
 1344              	vTaskStartScheduler:
 1345              	.LFB120:
1077:FreeRTOS/Source/tasks.c **** 
1078:FreeRTOS/Source/tasks.c **** #endif
1079:FreeRTOS/Source/tasks.c **** 
1080:FreeRTOS/Source/tasks.c **** 
1081:FreeRTOS/Source/tasks.c **** 
1082:FreeRTOS/Source/tasks.c **** 
1083:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1084:FreeRTOS/Source/tasks.c ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1085:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1086:FreeRTOS/Source/tasks.c **** 
1087:FreeRTOS/Source/tasks.c **** 
1088:FreeRTOS/Source/tasks.c **** void vTaskStartScheduler( void )
1089:FreeRTOS/Source/tasks.c **** {
 1346              		.loc 1 1089 0
 1347              		.cfi_startproc
 1348              		@ args = 0, pretend = 0, frame = 8
 1349              		@ frame_needed = 1, uses_anonymous_args = 0
 1350 0000 80B5     		push	{r7, lr}
 1351              	.LCFI30:
 1352              		.cfi_def_cfa_offset 8
 1353              		.cfi_offset 7, -8
 1354              		.cfi_offset 14, -4
 1355 0002 86B0     		sub	sp, sp, #24
 1356              	.LCFI31:
 1357              		.cfi_def_cfa_offset 32
 1358 0004 04AF     		add	r7, sp, #16
 1359              	.LCFI32:
 1360              		.cfi_def_cfa 7, 16
1090:FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1091:FreeRTOS/Source/tasks.c **** 
1092:FreeRTOS/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1093:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1094:FreeRTOS/Source/tasks.c **** 	{
1095:FreeRTOS/Source/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1096:FreeRTOS/Source/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1097:FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 1361              		.loc 1 1097 0
 1362 0006 0023     		movs	r3, #0
 1363 0008 0093     		str	r3, [sp]
 1364 000a 114B     		ldr	r3, .L86
 1365 000c 0193     		str	r3, [sp, #4]
 1366 000e 0023     		movs	r3, #0
 1367 0010 0293     		str	r3, [sp, #8]
 1368 0012 0023     		movs	r3, #0
 1369 0014 0393     		str	r3, [sp, #12]
 1370 0016 0F48     		ldr	r0, .L86+4
 1371 0018 0F49     		ldr	r1, .L86+8
 1372 001a 4FF48072 		mov	r2, #256
 1373 001e 0023     		movs	r3, #0
 1374 0020 FFF7FEFF 		bl	xTaskGenericCreate
 1375 0024 7860     		str	r0, [r7, #4]
1098:FreeRTOS/Source/tasks.c **** 	}
1099:FreeRTOS/Source/tasks.c **** 	#else
1100:FreeRTOS/Source/tasks.c **** 	{
1101:FreeRTOS/Source/tasks.c **** 		/* Create the idle task without storing its handle. */
1102:FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1103:FreeRTOS/Source/tasks.c **** 	}
1104:FreeRTOS/Source/tasks.c **** 	#endif
1105:FreeRTOS/Source/tasks.c **** 
1106:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1107:FreeRTOS/Source/tasks.c **** 	{
1108:FreeRTOS/Source/tasks.c **** 		if( xReturn == pdPASS )
1109:FreeRTOS/Source/tasks.c **** 		{
1110:FreeRTOS/Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1111:FreeRTOS/Source/tasks.c **** 		}
1112:FreeRTOS/Source/tasks.c **** 	}
1113:FreeRTOS/Source/tasks.c **** 	#endif
1114:FreeRTOS/Source/tasks.c **** 
1115:FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 1376              		.loc 1 1115 0
 1377 0026 7B68     		ldr	r3, [r7, #4]
 1378 0028 012B     		cmp	r3, #1
 1379 002a 0DD1     		bne	.L84
1116:FreeRTOS/Source/tasks.c **** 	{
1117:FreeRTOS/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1118:FreeRTOS/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1119:FreeRTOS/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1120:FreeRTOS/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1121:FreeRTOS/Source/tasks.c **** 		starts to run.
1122:FreeRTOS/Source/tasks.c **** 
1123:FreeRTOS/Source/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1124:FreeRTOS/Source/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1125:FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
 1380              		.loc 1 1125 0
 1381              	@ 1125 "FreeRTOS/Source/tasks.c" 1
 1382 002c 4FF0BF00 			mov r0, #191								
 1383 0030 80F31188 		msr basepri, r0							
 1384              	
 1385              	@ 0 "" 2
1126:FreeRTOS/Source/tasks.c **** 
1127:FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1386              		.loc 1 1127 0
 1387              		.thumb
 1388 0034 094B     		ldr	r3, .L86+12
 1389 0036 0122     		movs	r2, #1
 1390 0038 1A60     		str	r2, [r3]
1128:FreeRTOS/Source/tasks.c **** 		xTickCount = ( portTickType ) 0U;
 1391              		.loc 1 1128 0
 1392 003a 094B     		ldr	r3, .L86+16
 1393 003c 0022     		movs	r2, #0
 1394 003e 1A60     		str	r2, [r3]
1129:FreeRTOS/Source/tasks.c **** 
1130:FreeRTOS/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1131:FreeRTOS/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1132:FreeRTOS/Source/tasks.c **** 		the run time counter time base. */
1133:FreeRTOS/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
 1395              		.loc 1 1133 0
 1396 0040 FFF7FEFF 		bl	init_us_timer
1134:FreeRTOS/Source/tasks.c **** 		
1135:FreeRTOS/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1136:FreeRTOS/Source/tasks.c **** 		portable interface. */
1137:FreeRTOS/Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 1397              		.loc 1 1137 0
 1398 0044 FFF7FEFF 		bl	xPortStartScheduler
 1399              	.L84:
1138:FreeRTOS/Source/tasks.c **** 		{
1139:FreeRTOS/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1140:FreeRTOS/Source/tasks.c **** 			function will not return. */
1141:FreeRTOS/Source/tasks.c **** 		}
1142:FreeRTOS/Source/tasks.c **** 		else
1143:FreeRTOS/Source/tasks.c **** 		{
1144:FreeRTOS/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1145:FreeRTOS/Source/tasks.c **** 		}
1146:FreeRTOS/Source/tasks.c **** 	}
1147:FreeRTOS/Source/tasks.c **** 
1148:FreeRTOS/Source/tasks.c **** 	/* This line will only be reached if the kernel could not be started. */
1149:FreeRTOS/Source/tasks.c **** 	configASSERT( xReturn );
1150:FreeRTOS/Source/tasks.c **** }
 1400              		.loc 1 1150 0
 1401 0048 0837     		adds	r7, r7, #8
 1402 004a BD46     		mov	sp, r7
 1403              		@ sp needed
 1404 004c 80BD     		pop	{r7, pc}
 1405              	.L87:
 1406 004e 00BF     		.align	2
 1407              	.L86:
 1408 0050 00000000 		.word	xIdleTaskHandle
 1409 0054 00000000 		.word	prvIdleTask
 1410 0058 00000000 		.word	.LC0
 1411 005c 00000000 		.word	xSchedulerRunning
 1412 0060 00000000 		.word	xTickCount
 1413              		.cfi_endproc
 1414              	.LFE120:
 1416              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1417              		.align	2
 1418              		.global	vTaskEndScheduler
 1419              		.thumb
 1420              		.thumb_func
 1422              	vTaskEndScheduler:
 1423              	.LFB121:
1151:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1152:FreeRTOS/Source/tasks.c **** 
1153:FreeRTOS/Source/tasks.c **** void vTaskEndScheduler( void )
1154:FreeRTOS/Source/tasks.c **** {
 1424              		.loc 1 1154 0
 1425              		.cfi_startproc
 1426              		@ args = 0, pretend = 0, frame = 0
 1427              		@ frame_needed = 1, uses_anonymous_args = 0
 1428 0000 80B5     		push	{r7, lr}
 1429              	.LCFI33:
 1430              		.cfi_def_cfa_offset 8
 1431              		.cfi_offset 7, -8
 1432              		.cfi_offset 14, -4
 1433 0002 00AF     		add	r7, sp, #0
 1434              	.LCFI34:
 1435              		.cfi_def_cfa_register 7
1155:FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1156:FreeRTOS/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1157:FreeRTOS/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1158:FreeRTOS/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
 1436              		.loc 1 1158 0
 1437              	@ 1158 "FreeRTOS/Source/tasks.c" 1
 1438 0004 4FF0BF00 			mov r0, #191								
 1439 0008 80F31188 		msr basepri, r0							
 1440              	
 1441              	@ 0 "" 2
1159:FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1442              		.loc 1 1159 0
 1443              		.thumb
 1444 000c 024B     		ldr	r3, .L89
 1445 000e 0022     		movs	r2, #0
 1446 0010 1A60     		str	r2, [r3]
1160:FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
 1447              		.loc 1 1160 0
 1448 0012 FFF7FEFF 		bl	vPortEndScheduler
1161:FreeRTOS/Source/tasks.c **** }
 1449              		.loc 1 1161 0
 1450 0016 80BD     		pop	{r7, pc}
 1451              	.L90:
 1452              		.align	2
 1453              	.L89:
 1454 0018 00000000 		.word	xSchedulerRunning
 1455              		.cfi_endproc
 1456              	.LFE121:
 1458              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1459              		.align	2
 1460              		.global	vTaskSuspendAll
 1461              		.thumb
 1462              		.thumb_func
 1464              	vTaskSuspendAll:
 1465              	.LFB122:
1162:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1163:FreeRTOS/Source/tasks.c **** 
1164:FreeRTOS/Source/tasks.c **** void vTaskSuspendAll( void )
1165:FreeRTOS/Source/tasks.c **** {
 1466              		.loc 1 1165 0
 1467              		.cfi_startproc
 1468              		@ args = 0, pretend = 0, frame = 0
 1469              		@ frame_needed = 1, uses_anonymous_args = 0
 1470              		@ link register save eliminated.
 1471 0000 80B4     		push	{r7}
 1472              	.LCFI35:
 1473              		.cfi_def_cfa_offset 4
 1474              		.cfi_offset 7, -4
 1475 0002 00AF     		add	r7, sp, #0
 1476              	.LCFI36:
 1477              		.cfi_def_cfa_register 7
1166:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1167:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE. */
1168:FreeRTOS/Source/tasks.c **** 	++uxSchedulerSuspended;
 1478              		.loc 1 1168 0
 1479 0004 044B     		ldr	r3, .L92
 1480 0006 1B68     		ldr	r3, [r3]
 1481 0008 5A1C     		adds	r2, r3, #1
 1482 000a 034B     		ldr	r3, .L92
 1483 000c 1A60     		str	r2, [r3]
1169:FreeRTOS/Source/tasks.c **** }
 1484              		.loc 1 1169 0
 1485 000e BD46     		mov	sp, r7
 1486              		@ sp needed
 1487 0010 5DF8047B 		ldr	r7, [sp], #4
 1488 0014 7047     		bx	lr
 1489              	.L93:
 1490 0016 00BF     		.align	2
 1491              	.L92:
 1492 0018 00000000 		.word	uxSchedulerSuspended
 1493              		.cfi_endproc
 1494              	.LFE122:
 1496              		.section	.text.xTaskResumeAll,"ax",%progbits
 1497              		.align	2
 1498              		.global	xTaskResumeAll
 1499              		.thumb
 1500              		.thumb_func
 1502              	xTaskResumeAll:
 1503              	.LFB123:
1170:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1171:FreeRTOS/Source/tasks.c **** 
1172:FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1173:FreeRTOS/Source/tasks.c **** {
 1504              		.loc 1 1173 0
 1505              		.cfi_startproc
 1506              		@ args = 0, pretend = 0, frame = 8
 1507              		@ frame_needed = 1, uses_anonymous_args = 0
 1508 0000 90B5     		push	{r4, r7, lr}
 1509              	.LCFI37:
 1510              		.cfi_def_cfa_offset 12
 1511              		.cfi_offset 4, -12
 1512              		.cfi_offset 7, -8
 1513              		.cfi_offset 14, -4
 1514 0002 83B0     		sub	sp, sp, #12
 1515              	.LCFI38:
 1516              		.cfi_def_cfa_offset 24
 1517 0004 00AF     		add	r7, sp, #0
 1518              	.LCFI39:
 1519              		.cfi_def_cfa_register 7
1174:FreeRTOS/Source/tasks.c **** register tskTCB *pxTCB;
1175:FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 1520              		.loc 1 1175 0
 1521 0006 0023     		movs	r3, #0
 1522 0008 7B60     		str	r3, [r7, #4]
1176:FreeRTOS/Source/tasks.c **** 
1177:FreeRTOS/Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1178:FreeRTOS/Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
1179:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
1180:FreeRTOS/Source/tasks.c **** 
1181:FreeRTOS/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1182:FreeRTOS/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1183:FreeRTOS/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1184:FreeRTOS/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1185:FreeRTOS/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1186:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 1523              		.loc 1 1186 0
 1524 000a FFF7FEFF 		bl	vPortEnterCritical
1187:FreeRTOS/Source/tasks.c **** 	{
1188:FreeRTOS/Source/tasks.c **** 		--uxSchedulerSuspended;
 1525              		.loc 1 1188 0
 1526 000e 314B     		ldr	r3, .L104
 1527 0010 1B68     		ldr	r3, [r3]
 1528 0012 5A1E     		subs	r2, r3, #1
 1529 0014 2F4B     		ldr	r3, .L104
 1530 0016 1A60     		str	r2, [r3]
1189:FreeRTOS/Source/tasks.c **** 
1190:FreeRTOS/Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1531              		.loc 1 1190 0
 1532 0018 2E4B     		ldr	r3, .L104
 1533 001a 1B68     		ldr	r3, [r3]
 1534 001c 002B     		cmp	r3, #0
 1535 001e 52D1     		bne	.L95
1191:FreeRTOS/Source/tasks.c **** 		{
1192:FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 1536              		.loc 1 1192 0
 1537 0020 2D4B     		ldr	r3, .L104+4
 1538 0022 1B68     		ldr	r3, [r3]
 1539 0024 002B     		cmp	r3, #0
 1540 0026 4ED0     		beq	.L95
 1541              	.LBB3:
1193:FreeRTOS/Source/tasks.c **** 			{
1194:FreeRTOS/Source/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
 1542              		.loc 1 1194 0
 1543 0028 0023     		movs	r3, #0
 1544 002a 3B60     		str	r3, [r7]
1195:FreeRTOS/Source/tasks.c **** 
1196:FreeRTOS/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1197:FreeRTOS/Source/tasks.c **** 				appropriate ready list. */
1198:FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1545              		.loc 1 1198 0
 1546 002c 27E0     		b	.L96
 1547              	.L98:
1199:FreeRTOS/Source/tasks.c **** 				{
1200:FreeRTOS/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 1548              		.loc 1 1200 0
 1549 002e 2B4B     		ldr	r3, .L104+8
 1550 0030 DB68     		ldr	r3, [r3, #12]
 1551 0032 DC68     		ldr	r4, [r3, #12]
1201:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
 1552              		.loc 1 1201 0
 1553 0034 04F11803 		add	r3, r4, #24
 1554 0038 1846     		mov	r0, r3
 1555 003a FFF7FEFF 		bl	vListRemove
1202:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1556              		.loc 1 1202 0
 1557 003e 231D     		adds	r3, r4, #4
 1558 0040 1846     		mov	r0, r3
 1559 0042 FFF7FEFF 		bl	vListRemove
1203:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1560              		.loc 1 1203 0
 1561 0046 E26A     		ldr	r2, [r4, #44]
 1562 0048 254B     		ldr	r3, .L104+12
 1563 004a 1B68     		ldr	r3, [r3]
 1564 004c 9A42     		cmp	r2, r3
 1565 004e 02D9     		bls	.L97
 1566              		.loc 1 1203 0 is_stmt 0 discriminator 1
 1567 0050 E26A     		ldr	r2, [r4, #44]
 1568 0052 234B     		ldr	r3, .L104+12
 1569 0054 1A60     		str	r2, [r3]
 1570              	.L97:
 1571              		.loc 1 1203 0 discriminator 2
 1572 0056 E26A     		ldr	r2, [r4, #44]
 1573 0058 1346     		mov	r3, r2
 1574 005a 9B00     		lsls	r3, r3, #2
 1575 005c 1344     		add	r3, r3, r2
 1576 005e 9B00     		lsls	r3, r3, #2
 1577 0060 204A     		ldr	r2, .L104+16
 1578 0062 1A44     		add	r2, r2, r3
 1579 0064 231D     		adds	r3, r4, #4
 1580 0066 1046     		mov	r0, r2
 1581 0068 1946     		mov	r1, r3
 1582 006a FFF7FEFF 		bl	vListInsertEnd
1204:FreeRTOS/Source/tasks.c **** 
1205:FreeRTOS/Source/tasks.c **** 					/* If we have moved a task that has a priority higher than
1206:FreeRTOS/Source/tasks.c **** 					the current task then we should yield. */
1207:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1583              		.loc 1 1207 0 is_stmt 1 discriminator 2
 1584 006e E26A     		ldr	r2, [r4, #44]
 1585 0070 1D4B     		ldr	r3, .L104+20
 1586 0072 1B68     		ldr	r3, [r3]
 1587 0074 DB6A     		ldr	r3, [r3, #44]
 1588 0076 9A42     		cmp	r2, r3
 1589 0078 01D3     		bcc	.L96
1208:FreeRTOS/Source/tasks.c **** 					{
1209:FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1590              		.loc 1 1209 0
 1591 007a 0123     		movs	r3, #1
 1592 007c 3B60     		str	r3, [r7]
 1593              	.L96:
1198:FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1594              		.loc 1 1198 0 discriminator 1
 1595 007e 174B     		ldr	r3, .L104+8
 1596 0080 1B68     		ldr	r3, [r3]
 1597 0082 002B     		cmp	r3, #0
 1598 0084 D3D1     		bne	.L98
1210:FreeRTOS/Source/tasks.c **** 					}
1211:FreeRTOS/Source/tasks.c **** 				}
1212:FreeRTOS/Source/tasks.c **** 
1213:FreeRTOS/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1214:FreeRTOS/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1215:FreeRTOS/Source/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1216:FreeRTOS/Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1599              		.loc 1 1216 0
 1600 0086 194B     		ldr	r3, .L104+24
 1601 0088 1B68     		ldr	r3, [r3]
 1602 008a 002B     		cmp	r3, #0
 1603 008c 0DD0     		beq	.L99
1217:FreeRTOS/Source/tasks.c **** 				{
1218:FreeRTOS/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1604              		.loc 1 1218 0
 1605 008e 06E0     		b	.L100
 1606              	.L101:
1219:FreeRTOS/Source/tasks.c **** 					{
1220:FreeRTOS/Source/tasks.c **** 						vTaskIncrementTick();
 1607              		.loc 1 1220 0
 1608 0090 FFF7FEFF 		bl	vTaskIncrementTick
1221:FreeRTOS/Source/tasks.c **** 						--uxMissedTicks;
 1609              		.loc 1 1221 0
 1610 0094 154B     		ldr	r3, .L104+24
 1611 0096 1B68     		ldr	r3, [r3]
 1612 0098 5A1E     		subs	r2, r3, #1
 1613 009a 144B     		ldr	r3, .L104+24
 1614 009c 1A60     		str	r2, [r3]
 1615              	.L100:
1218:FreeRTOS/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1616              		.loc 1 1218 0 discriminator 1
 1617 009e 134B     		ldr	r3, .L104+24
 1618 00a0 1B68     		ldr	r3, [r3]
 1619 00a2 002B     		cmp	r3, #0
 1620 00a4 F4D1     		bne	.L101
1222:FreeRTOS/Source/tasks.c **** 					}
1223:FreeRTOS/Source/tasks.c **** 
1224:FreeRTOS/Source/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1225:FreeRTOS/Source/tasks.c **** 					to ensure the highest priority task that is ready to run is
1226:FreeRTOS/Source/tasks.c **** 					the task actually running. */
1227:FreeRTOS/Source/tasks.c **** 					#if configUSE_PREEMPTION == 1
1228:FreeRTOS/Source/tasks.c **** 					{
1229:FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1621              		.loc 1 1229 0
 1622 00a6 0123     		movs	r3, #1
 1623 00a8 3B60     		str	r3, [r7]
 1624              	.L99:
1230:FreeRTOS/Source/tasks.c **** 					}
1231:FreeRTOS/Source/tasks.c **** 					#endif
1232:FreeRTOS/Source/tasks.c **** 				}
1233:FreeRTOS/Source/tasks.c **** 
1234:FreeRTOS/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1625              		.loc 1 1234 0
 1626 00aa 3B68     		ldr	r3, [r7]
 1627 00ac 012B     		cmp	r3, #1
 1628 00ae 03D0     		beq	.L102
 1629              		.loc 1 1234 0 is_stmt 0 discriminator 1
 1630 00b0 0F4B     		ldr	r3, .L104+28
 1631 00b2 1B68     		ldr	r3, [r3]
 1632 00b4 012B     		cmp	r3, #1
 1633 00b6 06D1     		bne	.L95
 1634              	.L102:
1235:FreeRTOS/Source/tasks.c **** 				{
1236:FreeRTOS/Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
 1635              		.loc 1 1236 0 is_stmt 1
 1636 00b8 0123     		movs	r3, #1
 1637 00ba 7B60     		str	r3, [r7, #4]
1237:FreeRTOS/Source/tasks.c **** 					xMissedYield = pdFALSE;
 1638              		.loc 1 1237 0
 1639 00bc 0C4B     		ldr	r3, .L104+28
 1640 00be 0022     		movs	r2, #0
 1641 00c0 1A60     		str	r2, [r3]
1238:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
 1642              		.loc 1 1238 0
 1643 00c2 FFF7FEFF 		bl	vPortYieldFromISR
 1644              	.L95:
 1645              	.LBE3:
1239:FreeRTOS/Source/tasks.c **** 				}
1240:FreeRTOS/Source/tasks.c **** 			}
1241:FreeRTOS/Source/tasks.c **** 		}
1242:FreeRTOS/Source/tasks.c **** 	}
1243:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 1646              		.loc 1 1243 0
 1647 00c6 FFF7FEFF 		bl	vPortExitCritical
1244:FreeRTOS/Source/tasks.c **** 
1245:FreeRTOS/Source/tasks.c **** 	return xAlreadyYielded;
 1648              		.loc 1 1245 0
 1649 00ca 7B68     		ldr	r3, [r7, #4]
1246:FreeRTOS/Source/tasks.c **** }
 1650              		.loc 1 1246 0
 1651 00cc 1846     		mov	r0, r3
 1652 00ce 0C37     		adds	r7, r7, #12
 1653 00d0 BD46     		mov	sp, r7
 1654              		@ sp needed
 1655 00d2 90BD     		pop	{r4, r7, pc}
 1656              	.L105:
 1657              		.align	2
 1658              	.L104:
 1659 00d4 00000000 		.word	uxSchedulerSuspended
 1660 00d8 00000000 		.word	uxCurrentNumberOfTasks
 1661 00dc 00000000 		.word	xPendingReadyList
 1662 00e0 00000000 		.word	uxTopReadyPriority
 1663 00e4 00000000 		.word	pxReadyTasksLists
 1664 00e8 00000000 		.word	pxCurrentTCB
 1665 00ec 00000000 		.word	uxMissedTicks
 1666 00f0 00000000 		.word	xMissedYield
 1667              		.cfi_endproc
 1668              	.LFE123:
 1670              		.section	.text.xTaskGetTickCount,"ax",%progbits
 1671              		.align	2
 1672              		.global	xTaskGetTickCount
 1673              		.thumb
 1674              		.thumb_func
 1676              	xTaskGetTickCount:
 1677              	.LFB124:
1247:FreeRTOS/Source/tasks.c **** 
1248:FreeRTOS/Source/tasks.c **** 
1249:FreeRTOS/Source/tasks.c **** 
1250:FreeRTOS/Source/tasks.c **** 
1251:FreeRTOS/Source/tasks.c **** 
1252:FreeRTOS/Source/tasks.c **** 
1253:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1254:FreeRTOS/Source/tasks.c ****  * PUBLIC TASK UTILITIES documented in task.h
1255:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1256:FreeRTOS/Source/tasks.c **** 
1257:FreeRTOS/Source/tasks.c **** 
1258:FreeRTOS/Source/tasks.c **** 
1259:FreeRTOS/Source/tasks.c **** portTickType xTaskGetTickCount( void )
1260:FreeRTOS/Source/tasks.c **** {
 1678              		.loc 1 1260 0
 1679              		.cfi_startproc
 1680              		@ args = 0, pretend = 0, frame = 8
 1681              		@ frame_needed = 1, uses_anonymous_args = 0
 1682 0000 80B5     		push	{r7, lr}
 1683              	.LCFI40:
 1684              		.cfi_def_cfa_offset 8
 1685              		.cfi_offset 7, -8
 1686              		.cfi_offset 14, -4
 1687 0002 82B0     		sub	sp, sp, #8
 1688              	.LCFI41:
 1689              		.cfi_def_cfa_offset 16
 1690 0004 00AF     		add	r7, sp, #0
 1691              	.LCFI42:
 1692              		.cfi_def_cfa_register 7
1261:FreeRTOS/Source/tasks.c **** portTickType xTicks;
1262:FreeRTOS/Source/tasks.c **** 
1263:FreeRTOS/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1264:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 1693              		.loc 1 1264 0
 1694 0006 FFF7FEFF 		bl	vPortEnterCritical
1265:FreeRTOS/Source/tasks.c **** 	{
1266:FreeRTOS/Source/tasks.c **** 		xTicks = xTickCount;
 1695              		.loc 1 1266 0
 1696 000a 054B     		ldr	r3, .L108
 1697 000c 1B68     		ldr	r3, [r3]
 1698 000e 7B60     		str	r3, [r7, #4]
1267:FreeRTOS/Source/tasks.c **** 	}
1268:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 1699              		.loc 1 1268 0
 1700 0010 FFF7FEFF 		bl	vPortExitCritical
1269:FreeRTOS/Source/tasks.c **** 
1270:FreeRTOS/Source/tasks.c **** 	return xTicks;
 1701              		.loc 1 1270 0
 1702 0014 7B68     		ldr	r3, [r7, #4]
1271:FreeRTOS/Source/tasks.c **** }
 1703              		.loc 1 1271 0
 1704 0016 1846     		mov	r0, r3
 1705 0018 0837     		adds	r7, r7, #8
 1706 001a BD46     		mov	sp, r7
 1707              		@ sp needed
 1708 001c 80BD     		pop	{r7, pc}
 1709              	.L109:
 1710 001e 00BF     		.align	2
 1711              	.L108:
 1712 0020 00000000 		.word	xTickCount
 1713              		.cfi_endproc
 1714              	.LFE124:
 1716              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 1717              		.align	2
 1718              		.global	xTaskGetTickCountFromISR
 1719              		.thumb
 1720              		.thumb_func
 1722              	xTaskGetTickCountFromISR:
 1723              	.LFB125:
1272:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1273:FreeRTOS/Source/tasks.c **** 
1274:FreeRTOS/Source/tasks.c **** portTickType xTaskGetTickCountFromISR( void )
1275:FreeRTOS/Source/tasks.c **** {
 1724              		.loc 1 1275 0
 1725              		.cfi_startproc
 1726              		@ args = 0, pretend = 0, frame = 8
 1727              		@ frame_needed = 1, uses_anonymous_args = 0
 1728              		@ link register save eliminated.
 1729 0000 80B4     		push	{r7}
 1730              	.LCFI43:
 1731              		.cfi_def_cfa_offset 4
 1732              		.cfi_offset 7, -4
 1733 0002 83B0     		sub	sp, sp, #12
 1734              	.LCFI44:
 1735              		.cfi_def_cfa_offset 16
 1736 0004 00AF     		add	r7, sp, #0
 1737              	.LCFI45:
 1738              		.cfi_def_cfa_register 7
1276:FreeRTOS/Source/tasks.c **** portTickType xReturn;
1277:FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1278:FreeRTOS/Source/tasks.c **** 
1279:FreeRTOS/Source/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1739              		.loc 1 1279 0
 1740 0006 0023     		movs	r3, #0
 1741 0008 7B60     		str	r3, [r7, #4]
 1742              	@ 1279 "FreeRTOS/Source/tasks.c" 1
 1743 000a 4FF0BF00 			mov r0, #191								
 1744 000e 80F31188 		msr basepri, r0							
 1745              	
 1746              	@ 0 "" 2
1280:FreeRTOS/Source/tasks.c **** 	xReturn = xTickCount;
 1747              		.loc 1 1280 0
 1748              		.thumb
 1749 0012 074B     		ldr	r3, .L112
 1750 0014 1B68     		ldr	r3, [r3]
 1751 0016 3B60     		str	r3, [r7]
1281:FreeRTOS/Source/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1752              		.loc 1 1281 0
 1753              	@ 1281 "FreeRTOS/Source/tasks.c" 1
 1754 0018 4FF00000 			mov r0, #0					
 1755 001c 80F31188 		msr basepri, r0				
 1756              	
 1757              	@ 0 "" 2
1282:FreeRTOS/Source/tasks.c **** 
1283:FreeRTOS/Source/tasks.c **** 	return xReturn;
 1758              		.loc 1 1283 0
 1759              		.thumb
 1760 0020 3B68     		ldr	r3, [r7]
1284:FreeRTOS/Source/tasks.c **** }
 1761              		.loc 1 1284 0
 1762 0022 1846     		mov	r0, r3
 1763 0024 0C37     		adds	r7, r7, #12
 1764 0026 BD46     		mov	sp, r7
 1765              		@ sp needed
 1766 0028 5DF8047B 		ldr	r7, [sp], #4
 1767 002c 7047     		bx	lr
 1768              	.L113:
 1769 002e 00BF     		.align	2
 1770              	.L112:
 1771 0030 00000000 		.word	xTickCount
 1772              		.cfi_endproc
 1773              	.LFE125:
 1775              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 1776              		.align	2
 1777              		.global	uxTaskGetNumberOfTasks
 1778              		.thumb
 1779              		.thumb_func
 1781              	uxTaskGetNumberOfTasks:
 1782              	.LFB126:
1285:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1286:FreeRTOS/Source/tasks.c **** 
1287:FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1288:FreeRTOS/Source/tasks.c **** {
 1783              		.loc 1 1288 0
 1784              		.cfi_startproc
 1785              		@ args = 0, pretend = 0, frame = 0
 1786              		@ frame_needed = 1, uses_anonymous_args = 0
 1787              		@ link register save eliminated.
 1788 0000 80B4     		push	{r7}
 1789              	.LCFI46:
 1790              		.cfi_def_cfa_offset 4
 1791              		.cfi_offset 7, -4
 1792 0002 00AF     		add	r7, sp, #0
 1793              	.LCFI47:
 1794              		.cfi_def_cfa_register 7
1289:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1290:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE. */
1291:FreeRTOS/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 1795              		.loc 1 1291 0
 1796 0004 034B     		ldr	r3, .L116
 1797 0006 1B68     		ldr	r3, [r3]
1292:FreeRTOS/Source/tasks.c **** }
 1798              		.loc 1 1292 0
 1799 0008 1846     		mov	r0, r3
 1800 000a BD46     		mov	sp, r7
 1801              		@ sp needed
 1802 000c 5DF8047B 		ldr	r7, [sp], #4
 1803 0010 7047     		bx	lr
 1804              	.L117:
 1805 0012 00BF     		.align	2
 1806              	.L116:
 1807 0014 00000000 		.word	uxCurrentNumberOfTasks
 1808              		.cfi_endproc
 1809              	.LFE126:
 1811              		.section	.rodata
 1812 0005 000000   		.align	2
 1813              	.LC1:
 1814 0008 0D0A00   		.ascii	"\015\012\000"
 1815              		.section	.text.vTaskGetRunTimeStats,"ax",%progbits
 1816              		.align	2
 1817              		.global	vTaskGetRunTimeStats
 1818              		.thumb
 1819              		.thumb_func
 1821              	vTaskGetRunTimeStats:
 1822              	.LFB127:
1293:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1294:FreeRTOS/Source/tasks.c **** 
1295:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1296:FreeRTOS/Source/tasks.c **** 
1297:FreeRTOS/Source/tasks.c **** 	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1298:FreeRTOS/Source/tasks.c **** 	{
1299:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1300:FreeRTOS/Source/tasks.c **** 
1301:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1302:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1303:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
1304:FreeRTOS/Source/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1305:FreeRTOS/Source/tasks.c **** 	}
1306:FreeRTOS/Source/tasks.c **** 
1307:FreeRTOS/Source/tasks.c **** #endif
1308:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1309:FreeRTOS/Source/tasks.c **** 
1310:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1311:FreeRTOS/Source/tasks.c **** 
1312:FreeRTOS/Source/tasks.c **** 	void vTaskList( signed char *pcWriteBuffer )
1313:FreeRTOS/Source/tasks.c **** 	{
1314:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1315:FreeRTOS/Source/tasks.c **** 
1316:FreeRTOS/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1317:FreeRTOS/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1318:FreeRTOS/Source/tasks.c **** 
1319:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
1320:FreeRTOS/Source/tasks.c **** 		{
1321:FreeRTOS/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1322:FreeRTOS/Source/tasks.c **** 			report the task name, state and stack high water mark. */
1323:FreeRTOS/Source/tasks.c **** 
1324:FreeRTOS/Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
1325:FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1326:FreeRTOS/Source/tasks.c **** 
1327:FreeRTOS/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1328:FreeRTOS/Source/tasks.c **** 
1329:FreeRTOS/Source/tasks.c **** 			do
1330:FreeRTOS/Source/tasks.c **** 			{
1331:FreeRTOS/Source/tasks.c **** 				uxQueue--;
1332:FreeRTOS/Source/tasks.c **** 
1333:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1334:FreeRTOS/Source/tasks.c **** 				{
1335:FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
1336:FreeRTOS/Source/tasks.c **** 				}
1337:FreeRTOS/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1338:FreeRTOS/Source/tasks.c **** 
1339:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1340:FreeRTOS/Source/tasks.c **** 			{
1341:FreeRTOS/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
1342:FreeRTOS/Source/tasks.c **** 			}
1343:FreeRTOS/Source/tasks.c **** 
1344:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1345:FreeRTOS/Source/tasks.c **** 			{
1346:FreeRTOS/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
1347:FreeRTOS/Source/tasks.c **** 			}
1348:FreeRTOS/Source/tasks.c **** 
1349:FreeRTOS/Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1350:FreeRTOS/Source/tasks.c **** 			{
1351:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1352:FreeRTOS/Source/tasks.c **** 				{
1353:FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
1354:FreeRTOS/Source/tasks.c **** 				}
1355:FreeRTOS/Source/tasks.c **** 			}
1356:FreeRTOS/Source/tasks.c **** 			#endif
1357:FreeRTOS/Source/tasks.c **** 
1358:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1359:FreeRTOS/Source/tasks.c **** 			{
1360:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1361:FreeRTOS/Source/tasks.c **** 				{
1362:FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
1363:FreeRTOS/Source/tasks.c **** 				}
1364:FreeRTOS/Source/tasks.c **** 			}
1365:FreeRTOS/Source/tasks.c **** 			#endif
1366:FreeRTOS/Source/tasks.c **** 		}
1367:FreeRTOS/Source/tasks.c **** 		xTaskResumeAll();
1368:FreeRTOS/Source/tasks.c **** 	}
1369:FreeRTOS/Source/tasks.c **** 
1370:FreeRTOS/Source/tasks.c **** #endif
1371:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1372:FreeRTOS/Source/tasks.c **** 
1373:FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1374:FreeRTOS/Source/tasks.c **** 
1375:FreeRTOS/Source/tasks.c **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1376:FreeRTOS/Source/tasks.c **** 	{
 1823              		.loc 1 1376 0
 1824              		.cfi_startproc
 1825              		@ args = 0, pretend = 0, frame = 16
 1826              		@ frame_needed = 1, uses_anonymous_args = 0
 1827 0000 90B5     		push	{r4, r7, lr}
 1828              	.LCFI48:
 1829              		.cfi_def_cfa_offset 12
 1830              		.cfi_offset 4, -12
 1831              		.cfi_offset 7, -8
 1832              		.cfi_offset 14, -4
 1833 0002 85B0     		sub	sp, sp, #20
 1834              	.LCFI49:
 1835              		.cfi_def_cfa_offset 32
 1836 0004 00AF     		add	r7, sp, #0
 1837              	.LCFI50:
 1838              		.cfi_def_cfa_register 7
 1839 0006 7860     		str	r0, [r7, #4]
1377:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1378:FreeRTOS/Source/tasks.c **** 	unsigned long ulTotalRunTime;
1379:FreeRTOS/Source/tasks.c **** 
1380:FreeRTOS/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1381:FreeRTOS/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1382:FreeRTOS/Source/tasks.c **** 
1383:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
 1840              		.loc 1 1383 0
 1841 0008 FFF7FEFF 		bl	vTaskSuspendAll
1384:FreeRTOS/Source/tasks.c **** 		{
1385:FreeRTOS/Source/tasks.c **** 			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1386:FreeRTOS/Source/tasks.c **** 				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1387:FreeRTOS/Source/tasks.c **** 			#else
1388:FreeRTOS/Source/tasks.c **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
 1842              		.loc 1 1388 0
 1843 000c FFF7FEFF 		bl	get_us_time
 1844 0010 0246     		mov	r2, r0
 1845 0012 0B46     		mov	r3, r1
 1846 0014 1346     		mov	r3, r2
 1847 0016 BB60     		str	r3, [r7, #8]
1389:FreeRTOS/Source/tasks.c **** 			#endif
1390:FreeRTOS/Source/tasks.c **** 
1391:FreeRTOS/Source/tasks.c **** 			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
1392:FreeRTOS/Source/tasks.c **** 			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
1393:FreeRTOS/Source/tasks.c **** 			ulTotalRunTime /= 100UL;
 1848              		.loc 1 1393 0
 1849 0018 BA68     		ldr	r2, [r7, #8]
 1850 001a 334B     		ldr	r3, .L125
 1851 001c A3FB0213 		umull	r1, r3, r3, r2
 1852 0020 5B09     		lsrs	r3, r3, #5
 1853 0022 BB60     		str	r3, [r7, #8]
1394:FreeRTOS/Source/tasks.c **** 			
1395:FreeRTOS/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1396:FreeRTOS/Source/tasks.c **** 			generating a table of run timer percentages in the provided
1397:FreeRTOS/Source/tasks.c **** 			buffer. */
1398:FreeRTOS/Source/tasks.c **** 
1399:FreeRTOS/Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
 1854              		.loc 1 1399 0
 1855 0024 7B68     		ldr	r3, [r7, #4]
 1856 0026 0022     		movs	r2, #0
 1857 0028 1A70     		strb	r2, [r3]
1400:FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
 1858              		.loc 1 1400 0
 1859 002a 7C68     		ldr	r4, [r7, #4]
 1860 002c 2046     		mov	r0, r4
 1861 002e FFF7FEFF 		bl	strlen
 1862 0032 0346     		mov	r3, r0
 1863 0034 2344     		add	r3, r3, r4
 1864 0036 2D4A     		ldr	r2, .L125+4
 1865 0038 1188     		ldrh	r1, [r2]	@ unaligned
 1866 003a 9278     		ldrb	r2, [r2, #2]
 1867 003c 1980     		strh	r1, [r3]	@ unaligned
 1868 003e 9A70     		strb	r2, [r3, #2]
1401:FreeRTOS/Source/tasks.c **** 
1402:FreeRTOS/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
 1869              		.loc 1 1402 0
 1870 0040 2B4B     		ldr	r3, .L125+8
 1871 0042 1B68     		ldr	r3, [r3]
 1872 0044 0133     		adds	r3, r3, #1
 1873 0046 FB60     		str	r3, [r7, #12]
 1874              	.L120:
1403:FreeRTOS/Source/tasks.c **** 
1404:FreeRTOS/Source/tasks.c **** 			do
1405:FreeRTOS/Source/tasks.c **** 			{
1406:FreeRTOS/Source/tasks.c **** 				uxQueue--;
 1875              		.loc 1 1406 0
 1876 0048 FB68     		ldr	r3, [r7, #12]
 1877 004a 013B     		subs	r3, r3, #1
 1878 004c FB60     		str	r3, [r7, #12]
1407:FreeRTOS/Source/tasks.c **** 
1408:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
 1879              		.loc 1 1408 0
 1880 004e 2949     		ldr	r1, .L125+12
 1881 0050 FA68     		ldr	r2, [r7, #12]
 1882 0052 1346     		mov	r3, r2
 1883 0054 9B00     		lsls	r3, r3, #2
 1884 0056 1344     		add	r3, r3, r2
 1885 0058 9B00     		lsls	r3, r3, #2
 1886 005a 0B44     		add	r3, r3, r1
 1887 005c 1B68     		ldr	r3, [r3]
 1888 005e 002B     		cmp	r3, #0
 1889 0060 0CD0     		beq	.L119
1409:FreeRTOS/Source/tasks.c **** 				{
1410:FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
 1890              		.loc 1 1410 0
 1891 0062 FA68     		ldr	r2, [r7, #12]
 1892 0064 1346     		mov	r3, r2
 1893 0066 9B00     		lsls	r3, r3, #2
 1894 0068 1344     		add	r3, r3, r2
 1895 006a 9B00     		lsls	r3, r3, #2
 1896 006c 214A     		ldr	r2, .L125+12
 1897 006e 1344     		add	r3, r3, r2
 1898 0070 7868     		ldr	r0, [r7, #4]
 1899 0072 1946     		mov	r1, r3
 1900 0074 BA68     		ldr	r2, [r7, #8]
 1901 0076 5223     		movs	r3, #82
 1902 0078 FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 1903              	.L119:
1411:FreeRTOS/Source/tasks.c **** 				}
1412:FreeRTOS/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
 1904              		.loc 1 1412 0
 1905 007c FB68     		ldr	r3, [r7, #12]
 1906 007e 002B     		cmp	r3, #0
 1907 0080 E2D1     		bne	.L120
1413:FreeRTOS/Source/tasks.c **** 
1414:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
 1908              		.loc 1 1414 0
 1909 0082 1D4B     		ldr	r3, .L125+16
 1910 0084 1B68     		ldr	r3, [r3]
 1911 0086 1B68     		ldr	r3, [r3]
 1912 0088 002B     		cmp	r3, #0
 1913 008a 07D0     		beq	.L121
1415:FreeRTOS/Source/tasks.c **** 			{
1416:FreeRTOS/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
 1914              		.loc 1 1416 0
 1915 008c 1A4B     		ldr	r3, .L125+16
 1916 008e 1B68     		ldr	r3, [r3]
 1917 0090 7868     		ldr	r0, [r7, #4]
 1918 0092 1946     		mov	r1, r3
 1919 0094 BA68     		ldr	r2, [r7, #8]
 1920 0096 4223     		movs	r3, #66
 1921 0098 FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 1922              	.L121:
1417:FreeRTOS/Source/tasks.c **** 			}
1418:FreeRTOS/Source/tasks.c **** 
1419:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
 1923              		.loc 1 1419 0
 1924 009c 174B     		ldr	r3, .L125+20
 1925 009e 1B68     		ldr	r3, [r3]
 1926 00a0 1B68     		ldr	r3, [r3]
 1927 00a2 002B     		cmp	r3, #0
 1928 00a4 07D0     		beq	.L122
1420:FreeRTOS/Source/tasks.c **** 			{
1421:FreeRTOS/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
 1929              		.loc 1 1421 0
 1930 00a6 154B     		ldr	r3, .L125+20
 1931 00a8 1B68     		ldr	r3, [r3]
 1932 00aa 7868     		ldr	r0, [r7, #4]
 1933 00ac 1946     		mov	r1, r3
 1934 00ae BA68     		ldr	r2, [r7, #8]
 1935 00b0 4223     		movs	r3, #66
 1936 00b2 FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 1937              	.L122:
1422:FreeRTOS/Source/tasks.c **** 			}
1423:FreeRTOS/Source/tasks.c **** 
1424:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1425:FreeRTOS/Source/tasks.c **** 			{
1426:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
 1938              		.loc 1 1426 0
 1939 00b6 124B     		ldr	r3, .L125+24
 1940 00b8 1B68     		ldr	r3, [r3]
 1941 00ba 002B     		cmp	r3, #0
 1942 00bc 05D0     		beq	.L123
1427:FreeRTOS/Source/tasks.c **** 				{
1428:FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTim
 1943              		.loc 1 1428 0
 1944 00be 7868     		ldr	r0, [r7, #4]
 1945 00c0 0F49     		ldr	r1, .L125+24
 1946 00c2 BA68     		ldr	r2, [r7, #8]
 1947 00c4 4423     		movs	r3, #68
 1948 00c6 FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 1949              	.L123:
1429:FreeRTOS/Source/tasks.c **** 				}
1430:FreeRTOS/Source/tasks.c **** 			}
1431:FreeRTOS/Source/tasks.c **** 			#endif
1432:FreeRTOS/Source/tasks.c **** 
1433:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1434:FreeRTOS/Source/tasks.c **** 			{
1435:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
 1950              		.loc 1 1435 0
 1951 00ca 0E4B     		ldr	r3, .L125+28
 1952 00cc 1B68     		ldr	r3, [r3]
 1953 00ce 002B     		cmp	r3, #0
 1954 00d0 05D0     		beq	.L124
1436:FreeRTOS/Source/tasks.c **** 				{
1437:FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime, tsk
 1955              		.loc 1 1437 0
 1956 00d2 7868     		ldr	r0, [r7, #4]
 1957 00d4 0B49     		ldr	r1, .L125+28
 1958 00d6 BA68     		ldr	r2, [r7, #8]
 1959 00d8 5323     		movs	r3, #83
 1960 00da FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 1961              	.L124:
1438:FreeRTOS/Source/tasks.c **** 				}
1439:FreeRTOS/Source/tasks.c **** 			}
1440:FreeRTOS/Source/tasks.c **** 			#endif
1441:FreeRTOS/Source/tasks.c **** 		}
1442:FreeRTOS/Source/tasks.c **** 		xTaskResumeAll();
 1962              		.loc 1 1442 0
 1963 00de FFF7FEFF 		bl	xTaskResumeAll
1443:FreeRTOS/Source/tasks.c **** 	}
 1964              		.loc 1 1443 0
 1965 00e2 1437     		adds	r7, r7, #20
 1966 00e4 BD46     		mov	sp, r7
 1967              		@ sp needed
 1968 00e6 90BD     		pop	{r4, r7, pc}
 1969              	.L126:
 1970              		.align	2
 1971              	.L125:
 1972 00e8 1F85EB51 		.word	1374389535
 1973 00ec 08000000 		.word	.LC1
 1974 00f0 00000000 		.word	uxTopUsedPriority
 1975 00f4 00000000 		.word	pxReadyTasksLists
 1976 00f8 00000000 		.word	pxDelayedTaskList
 1977 00fc 00000000 		.word	pxOverflowDelayedTaskList
 1978 0100 00000000 		.word	xTasksWaitingTermination
 1979 0104 00000000 		.word	xSuspendedTaskList
 1980              		.cfi_endproc
 1981              	.LFE127:
 1983              		.section	.text.xTaskGetIdleTaskHandle,"ax",%progbits
 1984              		.align	2
 1985              		.global	xTaskGetIdleTaskHandle
 1986              		.thumb
 1987              		.thumb_func
 1989              	xTaskGetIdleTaskHandle:
 1990              	.LFB128:
1444:FreeRTOS/Source/tasks.c **** 
1445:FreeRTOS/Source/tasks.c **** #endif
1446:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1447:FreeRTOS/Source/tasks.c **** 
1448:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1449:FreeRTOS/Source/tasks.c **** 
1450:FreeRTOS/Source/tasks.c **** 	void vTaskStartTrace( signed char * pcBuffer, unsigned long ulBufferSize )
1451:FreeRTOS/Source/tasks.c **** 	{
1452:FreeRTOS/Source/tasks.c **** 		configASSERT( pcBuffer );
1453:FreeRTOS/Source/tasks.c **** 		configASSERT( ulBufferSize );
1454:FreeRTOS/Source/tasks.c **** 
1455:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1456:FreeRTOS/Source/tasks.c **** 		{
1457:FreeRTOS/Source/tasks.c **** 			pcTraceBuffer = ( signed char * )pcBuffer;
1458:FreeRTOS/Source/tasks.c **** 			pcTraceBufferStart = pcBuffer;
1459:FreeRTOS/Source/tasks.c **** 			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
1460:FreeRTOS/Source/tasks.c **** 			xTracing = pdTRUE;
1461:FreeRTOS/Source/tasks.c **** 		}
1462:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1463:FreeRTOS/Source/tasks.c **** 	}
1464:FreeRTOS/Source/tasks.c **** 
1465:FreeRTOS/Source/tasks.c **** #endif
1466:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1467:FreeRTOS/Source/tasks.c **** 
1468:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1469:FreeRTOS/Source/tasks.c **** 
1470:FreeRTOS/Source/tasks.c **** 	unsigned long ulTaskEndTrace( void )
1471:FreeRTOS/Source/tasks.c **** 	{
1472:FreeRTOS/Source/tasks.c **** 	unsigned long ulBufferLength;
1473:FreeRTOS/Source/tasks.c **** 
1474:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1475:FreeRTOS/Source/tasks.c **** 			xTracing = pdFALSE;
1476:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1477:FreeRTOS/Source/tasks.c **** 
1478:FreeRTOS/Source/tasks.c **** 		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
1479:FreeRTOS/Source/tasks.c **** 
1480:FreeRTOS/Source/tasks.c **** 		return ulBufferLength;
1481:FreeRTOS/Source/tasks.c **** 	}
1482:FreeRTOS/Source/tasks.c **** 
1483:FreeRTOS/Source/tasks.c **** #endif
1484:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1485:FreeRTOS/Source/tasks.c **** 
1486:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1487:FreeRTOS/Source/tasks.c **** 
1488:FreeRTOS/Source/tasks.c **** 	xTaskHandle xTaskGetIdleTaskHandle( void )
1489:FreeRTOS/Source/tasks.c **** 	{
 1991              		.loc 1 1489 0
 1992              		.cfi_startproc
 1993              		@ args = 0, pretend = 0, frame = 0
 1994              		@ frame_needed = 1, uses_anonymous_args = 0
 1995              		@ link register save eliminated.
 1996 0000 80B4     		push	{r7}
 1997              	.LCFI51:
 1998              		.cfi_def_cfa_offset 4
 1999              		.cfi_offset 7, -4
 2000 0002 00AF     		add	r7, sp, #0
 2001              	.LCFI52:
 2002              		.cfi_def_cfa_register 7
1490:FreeRTOS/Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1491:FreeRTOS/Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1492:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1493:FreeRTOS/Source/tasks.c **** 		return xIdleTaskHandle;
 2003              		.loc 1 1493 0
 2004 0004 034B     		ldr	r3, .L129
 2005 0006 1B68     		ldr	r3, [r3]
1494:FreeRTOS/Source/tasks.c **** 	}
 2006              		.loc 1 1494 0
 2007 0008 1846     		mov	r0, r3
 2008 000a BD46     		mov	sp, r7
 2009              		@ sp needed
 2010 000c 5DF8047B 		ldr	r7, [sp], #4
 2011 0010 7047     		bx	lr
 2012              	.L130:
 2013 0012 00BF     		.align	2
 2014              	.L129:
 2015 0014 00000000 		.word	xIdleTaskHandle
 2016              		.cfi_endproc
 2017              	.LFE128:
 2019              		.section	.text.vTaskIncrementTick,"ax",%progbits
 2020              		.align	2
 2021              		.global	vTaskIncrementTick
 2022              		.thumb
 2023              		.thumb_func
 2025              	vTaskIncrementTick:
 2026              	.LFB129:
1495:FreeRTOS/Source/tasks.c **** 	
1496:FreeRTOS/Source/tasks.c **** #endif
1497:FreeRTOS/Source/tasks.c **** 
1498:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1499:FreeRTOS/Source/tasks.c ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1500:FreeRTOS/Source/tasks.c ****  * documented in task.h
1501:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1502:FreeRTOS/Source/tasks.c **** 
1503:FreeRTOS/Source/tasks.c **** void vTaskIncrementTick( void )
1504:FreeRTOS/Source/tasks.c **** {
 2027              		.loc 1 1504 0
 2028              		.cfi_startproc
 2029              		@ args = 0, pretend = 0, frame = 16
 2030              		@ frame_needed = 1, uses_anonymous_args = 0
 2031 0000 80B5     		push	{r7, lr}
 2032              	.LCFI53:
 2033              		.cfi_def_cfa_offset 8
 2034              		.cfi_offset 7, -8
 2035              		.cfi_offset 14, -4
 2036 0002 84B0     		sub	sp, sp, #16
 2037              	.LCFI54:
 2038              		.cfi_def_cfa_offset 24
 2039 0004 00AF     		add	r7, sp, #0
 2040              	.LCFI55:
 2041              		.cfi_def_cfa_register 7
1505:FreeRTOS/Source/tasks.c **** tskTCB * pxTCB;
1506:FreeRTOS/Source/tasks.c **** 
1507:FreeRTOS/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1508:FreeRTOS/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1509:FreeRTOS/Source/tasks.c **** 	tasks to be unblocked. */
1510:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2042              		.loc 1 1510 0
 2043 0006 404B     		ldr	r3, .L142
 2044 0008 1B68     		ldr	r3, [r3]
 2045 000a 002B     		cmp	r3, #0
 2046 000c 73D1     		bne	.L132
1511:FreeRTOS/Source/tasks.c **** 	{
1512:FreeRTOS/Source/tasks.c **** 		++xTickCount;
 2047              		.loc 1 1512 0
 2048 000e 3F4B     		ldr	r3, .L142+4
 2049 0010 1B68     		ldr	r3, [r3]
 2050 0012 5A1C     		adds	r2, r3, #1
 2051 0014 3D4B     		ldr	r3, .L142+4
 2052 0016 1A60     		str	r2, [r3]
1513:FreeRTOS/Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0U )
 2053              		.loc 1 1513 0
 2054 0018 3C4B     		ldr	r3, .L142+4
 2055 001a 1B68     		ldr	r3, [r3]
 2056 001c 002B     		cmp	r3, #0
 2057 001e 21D1     		bne	.L133
 2058              	.LBB4:
1514:FreeRTOS/Source/tasks.c **** 		{
1515:FreeRTOS/Source/tasks.c **** 			xList *pxTemp;
1516:FreeRTOS/Source/tasks.c **** 
1517:FreeRTOS/Source/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1518:FreeRTOS/Source/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1519:FreeRTOS/Source/tasks.c **** 			an error! */
1520:FreeRTOS/Source/tasks.c **** 			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
1521:FreeRTOS/Source/tasks.c **** 			
1522:FreeRTOS/Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
 2059              		.loc 1 1522 0
 2060 0020 3B4B     		ldr	r3, .L142+8
 2061 0022 1B68     		ldr	r3, [r3]
 2062 0024 FB60     		str	r3, [r7, #12]
1523:FreeRTOS/Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 2063              		.loc 1 1523 0
 2064 0026 3B4B     		ldr	r3, .L142+12
 2065 0028 1A68     		ldr	r2, [r3]
 2066 002a 394B     		ldr	r3, .L142+8
 2067 002c 1A60     		str	r2, [r3]
1524:FreeRTOS/Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 2068              		.loc 1 1524 0
 2069 002e 394B     		ldr	r3, .L142+12
 2070 0030 FA68     		ldr	r2, [r7, #12]
 2071 0032 1A60     		str	r2, [r3]
1525:FreeRTOS/Source/tasks.c **** 			xNumOfOverflows++;
 2072              		.loc 1 1525 0
 2073 0034 384B     		ldr	r3, .L142+16
 2074 0036 1B68     		ldr	r3, [r3]
 2075 0038 5A1C     		adds	r2, r3, #1
 2076 003a 374B     		ldr	r3, .L142+16
 2077 003c 1A60     		str	r2, [r3]
1526:FreeRTOS/Source/tasks.c **** 	
1527:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2078              		.loc 1 1527 0
 2079 003e 344B     		ldr	r3, .L142+8
 2080 0040 1B68     		ldr	r3, [r3]
 2081 0042 1B68     		ldr	r3, [r3]
 2082 0044 002B     		cmp	r3, #0
 2083 0046 04D1     		bne	.L134
1528:FreeRTOS/Source/tasks.c **** 			{
1529:FreeRTOS/Source/tasks.c **** 				/* The new current delayed list is empty.  Set
1530:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime to the maximum possible value so it is
1531:FreeRTOS/Source/tasks.c **** 				extremely unlikely that the	
1532:FreeRTOS/Source/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
1533:FreeRTOS/Source/tasks.c **** 				there is an item in the delayed list. */
1534:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;
 2084              		.loc 1 1534 0
 2085 0048 344B     		ldr	r3, .L142+20
 2086 004a 4FF0FF32 		mov	r2, #-1
 2087 004e 1A60     		str	r2, [r3]
 2088 0050 08E0     		b	.L133
 2089              	.L134:
1535:FreeRTOS/Source/tasks.c **** 			}
1536:FreeRTOS/Source/tasks.c **** 			else
1537:FreeRTOS/Source/tasks.c **** 			{
1538:FreeRTOS/Source/tasks.c **** 				/* The new current delayed list is not empty, get the value of
1539:FreeRTOS/Source/tasks.c **** 				the item at the head of the delayed list.  This is the time at
1540:FreeRTOS/Source/tasks.c **** 				which the task at the head of the delayed list should be removed
1541:FreeRTOS/Source/tasks.c **** 				from the Blocked state. */
1542:FreeRTOS/Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 2090              		.loc 1 1542 0
 2091 0052 2F4B     		ldr	r3, .L142+8
 2092 0054 1B68     		ldr	r3, [r3]
 2093 0056 DB68     		ldr	r3, [r3, #12]
 2094 0058 DB68     		ldr	r3, [r3, #12]
 2095 005a BB60     		str	r3, [r7, #8]
1543:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 2096              		.loc 1 1543 0
 2097 005c BB68     		ldr	r3, [r7, #8]
 2098 005e 5A68     		ldr	r2, [r3, #4]
 2099 0060 2E4B     		ldr	r3, .L142+20
 2100 0062 1A60     		str	r2, [r3]
 2101              	.L133:
 2102              	.LBE4:
 2103              	.LBB5:
1544:FreeRTOS/Source/tasks.c **** 			}
1545:FreeRTOS/Source/tasks.c **** 		}
1546:FreeRTOS/Source/tasks.c **** 
1547:FreeRTOS/Source/tasks.c **** 		/* See if this tick has made a timeout expire. */
1548:FreeRTOS/Source/tasks.c **** 		prvCheckDelayedTasks();
 2104              		.loc 1 1548 0
 2105 0064 294B     		ldr	r3, .L142+4
 2106 0066 1A68     		ldr	r2, [r3]
 2107 0068 2C4B     		ldr	r3, .L142+20
 2108 006a 1B68     		ldr	r3, [r3]
 2109 006c 9A42     		cmp	r2, r3
 2110 006e 41D3     		bcc	.L135
 2111              	.L140:
 2112              		.loc 1 1548 0 is_stmt 0 discriminator 1
 2113 0070 274B     		ldr	r3, .L142+8
 2114 0072 1B68     		ldr	r3, [r3]
 2115 0074 1B68     		ldr	r3, [r3]
 2116 0076 002B     		cmp	r3, #0
 2117 0078 04D1     		bne	.L136
 2118 007a 284B     		ldr	r3, .L142+20
 2119 007c 4FF0FF32 		mov	r2, #-1
 2120 0080 1A60     		str	r2, [r3]
 2121 0082 37E0     		b	.L135
 2122              	.L136:
 2123              		.loc 1 1548 0 discriminator 2
 2124 0084 224B     		ldr	r3, .L142+8
 2125 0086 1B68     		ldr	r3, [r3]
 2126 0088 DB68     		ldr	r3, [r3, #12]
 2127 008a DB68     		ldr	r3, [r3, #12]
 2128 008c BB60     		str	r3, [r7, #8]
 2129 008e BB68     		ldr	r3, [r7, #8]
 2130 0090 5B68     		ldr	r3, [r3, #4]
 2131 0092 7B60     		str	r3, [r7, #4]
 2132 0094 1D4B     		ldr	r3, .L142+4
 2133 0096 1A68     		ldr	r2, [r3]
 2134 0098 7B68     		ldr	r3, [r7, #4]
 2135 009a 9A42     		cmp	r2, r3
 2136 009c 03D2     		bcs	.L137
 2137              		.loc 1 1548 0 discriminator 1
 2138 009e 1F4B     		ldr	r3, .L142+20
 2139 00a0 7A68     		ldr	r2, [r7, #4]
 2140 00a2 1A60     		str	r2, [r3]
 2141 00a4 26E0     		b	.L135
 2142              	.L137:
 2143              		.loc 1 1548 0 discriminator 2
 2144 00a6 BB68     		ldr	r3, [r7, #8]
 2145 00a8 0433     		adds	r3, r3, #4
 2146 00aa 1846     		mov	r0, r3
 2147 00ac FFF7FEFF 		bl	vListRemove
 2148 00b0 BB68     		ldr	r3, [r7, #8]
 2149 00b2 9B6A     		ldr	r3, [r3, #40]
 2150 00b4 002B     		cmp	r3, #0
 2151 00b6 04D0     		beq	.L138
 2152              		.loc 1 1548 0 discriminator 1
 2153 00b8 BB68     		ldr	r3, [r7, #8]
 2154 00ba 1833     		adds	r3, r3, #24
 2155 00bc 1846     		mov	r0, r3
 2156 00be FFF7FEFF 		bl	vListRemove
 2157              	.L138:
 2158              		.loc 1 1548 0 discriminator 2
 2159 00c2 BB68     		ldr	r3, [r7, #8]
 2160 00c4 DA6A     		ldr	r2, [r3, #44]
 2161 00c6 164B     		ldr	r3, .L142+24
 2162 00c8 1B68     		ldr	r3, [r3]
 2163 00ca 9A42     		cmp	r2, r3
 2164 00cc 03D9     		bls	.L139
 2165              		.loc 1 1548 0 discriminator 1
 2166 00ce BB68     		ldr	r3, [r7, #8]
 2167 00d0 DA6A     		ldr	r2, [r3, #44]
 2168 00d2 134B     		ldr	r3, .L142+24
 2169 00d4 1A60     		str	r2, [r3]
 2170              	.L139:
 2171              		.loc 1 1548 0 discriminator 2
 2172 00d6 BB68     		ldr	r3, [r7, #8]
 2173 00d8 DA6A     		ldr	r2, [r3, #44]
 2174 00da 1346     		mov	r3, r2
 2175 00dc 9B00     		lsls	r3, r3, #2
 2176 00de 1344     		add	r3, r3, r2
 2177 00e0 9B00     		lsls	r3, r3, #2
 2178 00e2 104A     		ldr	r2, .L142+28
 2179 00e4 1A44     		add	r2, r2, r3
 2180 00e6 BB68     		ldr	r3, [r7, #8]
 2181 00e8 0433     		adds	r3, r3, #4
 2182 00ea 1046     		mov	r0, r2
 2183 00ec 1946     		mov	r1, r3
 2184 00ee FFF7FEFF 		bl	vListInsertEnd
 2185 00f2 BDE7     		b	.L140
 2186              	.L135:
 2187              	.LBE5:
 2188 00f4 04E0     		b	.L131
 2189              	.L132:
1549:FreeRTOS/Source/tasks.c **** 	}
1550:FreeRTOS/Source/tasks.c **** 	else
1551:FreeRTOS/Source/tasks.c **** 	{
1552:FreeRTOS/Source/tasks.c **** 		++uxMissedTicks;
 2190              		.loc 1 1552 0 is_stmt 1
 2191 00f6 0C4B     		ldr	r3, .L142+32
 2192 00f8 1B68     		ldr	r3, [r3]
 2193 00fa 5A1C     		adds	r2, r3, #1
 2194 00fc 0A4B     		ldr	r3, .L142+32
 2195 00fe 1A60     		str	r2, [r3]
 2196              	.L131:
1553:FreeRTOS/Source/tasks.c **** 
1554:FreeRTOS/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1555:FreeRTOS/Source/tasks.c **** 		scheduler is locked. */
1556:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1557:FreeRTOS/Source/tasks.c **** 		{
1558:FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
1559:FreeRTOS/Source/tasks.c **** 		}
1560:FreeRTOS/Source/tasks.c **** 		#endif
1561:FreeRTOS/Source/tasks.c **** 	}
1562:FreeRTOS/Source/tasks.c **** 
1563:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1564:FreeRTOS/Source/tasks.c **** 	{
1565:FreeRTOS/Source/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1566:FreeRTOS/Source/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1567:FreeRTOS/Source/tasks.c **** 		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
1568:FreeRTOS/Source/tasks.c **** 		{
1569:FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
1570:FreeRTOS/Source/tasks.c **** 		}
1571:FreeRTOS/Source/tasks.c **** 	}
1572:FreeRTOS/Source/tasks.c **** 	#endif
1573:FreeRTOS/Source/tasks.c **** 
1574:FreeRTOS/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1575:FreeRTOS/Source/tasks.c **** }
 2197              		.loc 1 1575 0
 2198 0100 1037     		adds	r7, r7, #16
 2199 0102 BD46     		mov	sp, r7
 2200              		@ sp needed
 2201 0104 80BD     		pop	{r7, pc}
 2202              	.L143:
 2203 0106 00BF     		.align	2
 2204              	.L142:
 2205 0108 00000000 		.word	uxSchedulerSuspended
 2206 010c 00000000 		.word	xTickCount
 2207 0110 00000000 		.word	pxDelayedTaskList
 2208 0114 00000000 		.word	pxOverflowDelayedTaskList
 2209 0118 00000000 		.word	xNumOfOverflows
 2210 011c 00000000 		.word	xNextTaskUnblockTime
 2211 0120 00000000 		.word	uxTopReadyPriority
 2212 0124 00000000 		.word	pxReadyTasksLists
 2213 0128 00000000 		.word	uxMissedTicks
 2214              		.cfi_endproc
 2215              	.LFE129:
 2217              		.section	.text.vTaskSetApplicationTaskTag,"ax",%progbits
 2218              		.align	2
 2219              		.global	vTaskSetApplicationTaskTag
 2220              		.thumb
 2221              		.thumb_func
 2223              	vTaskSetApplicationTaskTag:
 2224              	.LFB130:
1576:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1577:FreeRTOS/Source/tasks.c **** 
1578:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1579:FreeRTOS/Source/tasks.c **** 
1580:FreeRTOS/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1581:FreeRTOS/Source/tasks.c **** 	{
 2225              		.loc 1 1581 0
 2226              		.cfi_startproc
 2227              		@ args = 0, pretend = 0, frame = 16
 2228              		@ frame_needed = 1, uses_anonymous_args = 0
 2229 0000 80B5     		push	{r7, lr}
 2230              	.LCFI56:
 2231              		.cfi_def_cfa_offset 8
 2232              		.cfi_offset 7, -8
 2233              		.cfi_offset 14, -4
 2234 0002 84B0     		sub	sp, sp, #16
 2235              	.LCFI57:
 2236              		.cfi_def_cfa_offset 24
 2237 0004 00AF     		add	r7, sp, #0
 2238              	.LCFI58:
 2239              		.cfi_def_cfa_register 7
 2240 0006 7860     		str	r0, [r7, #4]
 2241 0008 3960     		str	r1, [r7]
1582:FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1583:FreeRTOS/Source/tasks.c **** 
1584:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1585:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
 2242              		.loc 1 1585 0
 2243 000a 7B68     		ldr	r3, [r7, #4]
 2244 000c 002B     		cmp	r3, #0
 2245 000e 03D1     		bne	.L145
1586:FreeRTOS/Source/tasks.c **** 		{
1587:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
 2246              		.loc 1 1587 0
 2247 0010 074B     		ldr	r3, .L147
 2248 0012 1B68     		ldr	r3, [r3]
 2249 0014 FB60     		str	r3, [r7, #12]
 2250 0016 01E0     		b	.L146
 2251              	.L145:
1588:FreeRTOS/Source/tasks.c **** 		}
1589:FreeRTOS/Source/tasks.c **** 		else
1590:FreeRTOS/Source/tasks.c **** 		{
1591:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
 2252              		.loc 1 1591 0
 2253 0018 7B68     		ldr	r3, [r7, #4]
 2254 001a FB60     		str	r3, [r7, #12]
 2255              	.L146:
1592:FreeRTOS/Source/tasks.c **** 		}
1593:FreeRTOS/Source/tasks.c **** 
1594:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1595:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1596:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 2256              		.loc 1 1596 0
 2257 001c FFF7FEFF 		bl	vPortEnterCritical
1597:FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
 2258              		.loc 1 1597 0
 2259 0020 FB68     		ldr	r3, [r7, #12]
 2260 0022 3A68     		ldr	r2, [r7]
 2261 0024 9A64     		str	r2, [r3, #72]
1598:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 2262              		.loc 1 1598 0
 2263 0026 FFF7FEFF 		bl	vPortExitCritical
1599:FreeRTOS/Source/tasks.c **** 	}
 2264              		.loc 1 1599 0
 2265 002a 1037     		adds	r7, r7, #16
 2266 002c BD46     		mov	sp, r7
 2267              		@ sp needed
 2268 002e 80BD     		pop	{r7, pc}
 2269              	.L148:
 2270              		.align	2
 2271              	.L147:
 2272 0030 00000000 		.word	pxCurrentTCB
 2273              		.cfi_endproc
 2274              	.LFE130:
 2276              		.section	.text.xTaskGetApplicationTaskTag,"ax",%progbits
 2277              		.align	2
 2278              		.global	xTaskGetApplicationTaskTag
 2279              		.thumb
 2280              		.thumb_func
 2282              	xTaskGetApplicationTaskTag:
 2283              	.LFB131:
1600:FreeRTOS/Source/tasks.c **** 
1601:FreeRTOS/Source/tasks.c **** #endif
1602:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1603:FreeRTOS/Source/tasks.c **** 
1604:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1605:FreeRTOS/Source/tasks.c **** 
1606:FreeRTOS/Source/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1607:FreeRTOS/Source/tasks.c **** 	{
 2284              		.loc 1 1607 0
 2285              		.cfi_startproc
 2286              		@ args = 0, pretend = 0, frame = 16
 2287              		@ frame_needed = 1, uses_anonymous_args = 0
 2288 0000 80B5     		push	{r7, lr}
 2289              	.LCFI59:
 2290              		.cfi_def_cfa_offset 8
 2291              		.cfi_offset 7, -8
 2292              		.cfi_offset 14, -4
 2293 0002 84B0     		sub	sp, sp, #16
 2294              	.LCFI60:
 2295              		.cfi_def_cfa_offset 24
 2296 0004 00AF     		add	r7, sp, #0
 2297              	.LCFI61:
 2298              		.cfi_def_cfa_register 7
 2299 0006 7860     		str	r0, [r7, #4]
1608:FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1609:FreeRTOS/Source/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1610:FreeRTOS/Source/tasks.c **** 
1611:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1612:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
 2300              		.loc 1 1612 0
 2301 0008 7B68     		ldr	r3, [r7, #4]
 2302 000a 002B     		cmp	r3, #0
 2303 000c 03D1     		bne	.L150
1613:FreeRTOS/Source/tasks.c **** 		{
1614:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
 2304              		.loc 1 1614 0
 2305 000e 094B     		ldr	r3, .L153
 2306 0010 1B68     		ldr	r3, [r3]
 2307 0012 FB60     		str	r3, [r7, #12]
 2308 0014 01E0     		b	.L151
 2309              	.L150:
1615:FreeRTOS/Source/tasks.c **** 		}
1616:FreeRTOS/Source/tasks.c **** 		else
1617:FreeRTOS/Source/tasks.c **** 		{
1618:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
 2310              		.loc 1 1618 0
 2311 0016 7B68     		ldr	r3, [r7, #4]
 2312 0018 FB60     		str	r3, [r7, #12]
 2313              	.L151:
1619:FreeRTOS/Source/tasks.c **** 		}
1620:FreeRTOS/Source/tasks.c **** 
1621:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1622:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1623:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 2314              		.loc 1 1623 0
 2315 001a FFF7FEFF 		bl	vPortEnterCritical
1624:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
 2316              		.loc 1 1624 0
 2317 001e FB68     		ldr	r3, [r7, #12]
 2318 0020 9B6C     		ldr	r3, [r3, #72]
 2319 0022 BB60     		str	r3, [r7, #8]
1625:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 2320              		.loc 1 1625 0
 2321 0024 FFF7FEFF 		bl	vPortExitCritical
1626:FreeRTOS/Source/tasks.c **** 
1627:FreeRTOS/Source/tasks.c **** 		return xReturn;
 2322              		.loc 1 1627 0
 2323 0028 BB68     		ldr	r3, [r7, #8]
1628:FreeRTOS/Source/tasks.c **** 	}
 2324              		.loc 1 1628 0
 2325 002a 1846     		mov	r0, r3
 2326 002c 1037     		adds	r7, r7, #16
 2327 002e BD46     		mov	sp, r7
 2328              		@ sp needed
 2329 0030 80BD     		pop	{r7, pc}
 2330              	.L154:
 2331 0032 00BF     		.align	2
 2332              	.L153:
 2333 0034 00000000 		.word	pxCurrentTCB
 2334              		.cfi_endproc
 2335              	.LFE131:
 2337              		.section	.text.xTaskCallApplicationTaskHook,"ax",%progbits
 2338              		.align	2
 2339              		.global	xTaskCallApplicationTaskHook
 2340              		.thumb
 2341              		.thumb_func
 2343              	xTaskCallApplicationTaskHook:
 2344              	.LFB132:
1629:FreeRTOS/Source/tasks.c **** 
1630:FreeRTOS/Source/tasks.c **** #endif
1631:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1632:FreeRTOS/Source/tasks.c **** 
1633:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1634:FreeRTOS/Source/tasks.c **** 
1635:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1636:FreeRTOS/Source/tasks.c **** 	{
 2345              		.loc 1 1636 0
 2346              		.cfi_startproc
 2347              		@ args = 0, pretend = 0, frame = 16
 2348              		@ frame_needed = 1, uses_anonymous_args = 0
 2349 0000 80B5     		push	{r7, lr}
 2350              	.LCFI62:
 2351              		.cfi_def_cfa_offset 8
 2352              		.cfi_offset 7, -8
 2353              		.cfi_offset 14, -4
 2354 0002 84B0     		sub	sp, sp, #16
 2355              	.LCFI63:
 2356              		.cfi_def_cfa_offset 24
 2357 0004 00AF     		add	r7, sp, #0
 2358              	.LCFI64:
 2359              		.cfi_def_cfa_register 7
 2360 0006 7860     		str	r0, [r7, #4]
 2361 0008 3960     		str	r1, [r7]
1637:FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1638:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn;
1639:FreeRTOS/Source/tasks.c **** 
1640:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1641:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
 2362              		.loc 1 1641 0
 2363 000a 7B68     		ldr	r3, [r7, #4]
 2364 000c 002B     		cmp	r3, #0
 2365 000e 03D1     		bne	.L156
1642:FreeRTOS/Source/tasks.c **** 		{
1643:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
 2366              		.loc 1 1643 0
 2367 0010 0B4B     		ldr	r3, .L161
 2368 0012 1B68     		ldr	r3, [r3]
 2369 0014 FB60     		str	r3, [r7, #12]
 2370 0016 01E0     		b	.L157
 2371              	.L156:
1644:FreeRTOS/Source/tasks.c **** 		}
1645:FreeRTOS/Source/tasks.c **** 		else
1646:FreeRTOS/Source/tasks.c **** 		{
1647:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
 2372              		.loc 1 1647 0
 2373 0018 7B68     		ldr	r3, [r7, #4]
 2374 001a FB60     		str	r3, [r7, #12]
 2375              	.L157:
1648:FreeRTOS/Source/tasks.c **** 		}
1649:FreeRTOS/Source/tasks.c **** 
1650:FreeRTOS/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
 2376              		.loc 1 1650 0
 2377 001c FB68     		ldr	r3, [r7, #12]
 2378 001e 9B6C     		ldr	r3, [r3, #72]
 2379 0020 002B     		cmp	r3, #0
 2380 0022 05D0     		beq	.L158
1651:FreeRTOS/Source/tasks.c **** 		{
1652:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
 2381              		.loc 1 1652 0
 2382 0024 FB68     		ldr	r3, [r7, #12]
 2383 0026 9B6C     		ldr	r3, [r3, #72]
 2384 0028 3868     		ldr	r0, [r7]
 2385 002a 9847     		blx	r3
 2386 002c B860     		str	r0, [r7, #8]
 2387 002e 01E0     		b	.L159
 2388              	.L158:
1653:FreeRTOS/Source/tasks.c **** 		}
1654:FreeRTOS/Source/tasks.c **** 		else
1655:FreeRTOS/Source/tasks.c **** 		{
1656:FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
 2389              		.loc 1 1656 0
 2390 0030 0023     		movs	r3, #0
 2391 0032 BB60     		str	r3, [r7, #8]
 2392              	.L159:
1657:FreeRTOS/Source/tasks.c **** 		}
1658:FreeRTOS/Source/tasks.c **** 
1659:FreeRTOS/Source/tasks.c **** 		return xReturn;
 2393              		.loc 1 1659 0
 2394 0034 BB68     		ldr	r3, [r7, #8]
1660:FreeRTOS/Source/tasks.c **** 	}
 2395              		.loc 1 1660 0
 2396 0036 1846     		mov	r0, r3
 2397 0038 1037     		adds	r7, r7, #16
 2398 003a BD46     		mov	sp, r7
 2399              		@ sp needed
 2400 003c 80BD     		pop	{r7, pc}
 2401              	.L162:
 2402 003e 00BF     		.align	2
 2403              	.L161:
 2404 0040 00000000 		.word	pxCurrentTCB
 2405              		.cfi_endproc
 2406              	.LFE132:
 2408              		.section	.text.vTaskSwitchContext,"ax",%progbits
 2409              		.align	2
 2410              		.global	vTaskSwitchContext
 2411              		.thumb
 2412              		.thumb_func
 2414              	vTaskSwitchContext:
 2415              	.LFB133:
1661:FreeRTOS/Source/tasks.c **** 
1662:FreeRTOS/Source/tasks.c **** #endif
1663:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1664:FreeRTOS/Source/tasks.c **** 
1665:FreeRTOS/Source/tasks.c **** void vTaskSwitchContext( void )
1666:FreeRTOS/Source/tasks.c **** {
 2416              		.loc 1 1666 0
 2417              		.cfi_startproc
 2418              		@ args = 0, pretend = 0, frame = 8
 2419              		@ frame_needed = 1, uses_anonymous_args = 0
 2420 0000 80B5     		push	{r7, lr}
 2421              	.LCFI65:
 2422              		.cfi_def_cfa_offset 8
 2423              		.cfi_offset 7, -8
 2424              		.cfi_offset 14, -4
 2425 0002 82B0     		sub	sp, sp, #8
 2426              	.LCFI66:
 2427              		.cfi_def_cfa_offset 16
 2428 0004 00AF     		add	r7, sp, #0
 2429              	.LCFI67:
 2430              		.cfi_def_cfa_register 7
1667:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 2431              		.loc 1 1667 0
 2432 0006 284B     		ldr	r3, .L169
 2433 0008 1B68     		ldr	r3, [r3]
 2434 000a 002B     		cmp	r3, #0
 2435 000c 03D0     		beq	.L164
1668:FreeRTOS/Source/tasks.c **** 	{
1669:FreeRTOS/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1670:FreeRTOS/Source/tasks.c **** 		switch. */
1671:FreeRTOS/Source/tasks.c **** 		xMissedYield = pdTRUE;
 2436              		.loc 1 1671 0
 2437 000e 274B     		ldr	r3, .L169+4
 2438 0010 0122     		movs	r2, #1
 2439 0012 1A60     		str	r2, [r3]
 2440 0014 45E0     		b	.L163
 2441              	.L164:
 2442              	.LBB6:
1672:FreeRTOS/Source/tasks.c **** 	}
1673:FreeRTOS/Source/tasks.c **** 	else
1674:FreeRTOS/Source/tasks.c **** 	{
1675:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
1676:FreeRTOS/Source/tasks.c **** 	
1677:FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1678:FreeRTOS/Source/tasks.c **** 		{
1679:FreeRTOS/Source/tasks.c **** 			unsigned long ulTempCounter;
1680:FreeRTOS/Source/tasks.c **** 			
1681:FreeRTOS/Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1682:FreeRTOS/Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
1683:FreeRTOS/Source/tasks.c **** 				#else
1684:FreeRTOS/Source/tasks.c **** 					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
 2443              		.loc 1 1684 0
 2444 0016 FFF7FEFF 		bl	get_us_time
 2445 001a 0246     		mov	r2, r0
 2446 001c 0B46     		mov	r3, r1
 2447 001e 1346     		mov	r3, r2
 2448 0020 7B60     		str	r3, [r7, #4]
1685:FreeRTOS/Source/tasks.c **** 				#endif
1686:FreeRTOS/Source/tasks.c **** 	
1687:FreeRTOS/Source/tasks.c **** 				/* Add the amount of time the task has been running to the accumulated
1688:FreeRTOS/Source/tasks.c **** 				time so far.  The time the task started running was stored in
1689:FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime.  Note that there is no overflow protection here
1690:FreeRTOS/Source/tasks.c **** 				so count values are only valid until the timer overflows.  Generally
1691:FreeRTOS/Source/tasks.c **** 				this will be about 1 hour assuming a 1uS timer increment. */
1692:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
 2449              		.loc 1 1692 0
 2450 0022 234B     		ldr	r3, .L169+8
 2451 0024 1B68     		ldr	r3, [r3]
 2452 0026 D96C     		ldr	r1, [r3, #76]
 2453 0028 224A     		ldr	r2, .L169+12
 2454 002a 1268     		ldr	r2, [r2]
 2455 002c 7868     		ldr	r0, [r7, #4]
 2456 002e 821A     		subs	r2, r0, r2
 2457 0030 0A44     		add	r2, r2, r1
 2458 0032 DA64     		str	r2, [r3, #76]
1693:FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime = ulTempCounter;
 2459              		.loc 1 1693 0
 2460 0034 1F4B     		ldr	r3, .L169+12
 2461 0036 7A68     		ldr	r2, [r7, #4]
 2462 0038 1A60     		str	r2, [r3]
 2463              	.LBE6:
1694:FreeRTOS/Source/tasks.c **** 		}
1695:FreeRTOS/Source/tasks.c **** 		#endif
1696:FreeRTOS/Source/tasks.c **** 	
1697:FreeRTOS/Source/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
1698:FreeRTOS/Source/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1699:FreeRTOS/Source/tasks.c **** 	
1700:FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */
1701:FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2464              		.loc 1 1701 0
 2465 003a 04E0     		b	.L166
 2466              	.L167:
1702:FreeRTOS/Source/tasks.c **** 		{
1703:FreeRTOS/Source/tasks.c **** 			configASSERT( uxTopReadyPriority );
1704:FreeRTOS/Source/tasks.c **** 			--uxTopReadyPriority;
 2467              		.loc 1 1704 0
 2468 003c 1E4B     		ldr	r3, .L169+16
 2469 003e 1B68     		ldr	r3, [r3]
 2470 0040 5A1E     		subs	r2, r3, #1
 2471 0042 1D4B     		ldr	r3, .L169+16
 2472 0044 1A60     		str	r2, [r3]
 2473              	.L166:
1701:FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2474              		.loc 1 1701 0 discriminator 1
 2475 0046 1C4B     		ldr	r3, .L169+16
 2476 0048 1A68     		ldr	r2, [r3]
 2477 004a 1C49     		ldr	r1, .L169+20
 2478 004c 1346     		mov	r3, r2
 2479 004e 9B00     		lsls	r3, r3, #2
 2480 0050 1344     		add	r3, r3, r2
 2481 0052 9B00     		lsls	r3, r3, #2
 2482 0054 0B44     		add	r3, r3, r1
 2483 0056 1B68     		ldr	r3, [r3]
 2484 0058 002B     		cmp	r3, #0
 2485 005a EFD0     		beq	.L167
 2486              	.LBB7:
1705:FreeRTOS/Source/tasks.c **** 		}
1706:FreeRTOS/Source/tasks.c **** 	
1707:FreeRTOS/Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
1708:FreeRTOS/Source/tasks.c **** 		same priority get an equal share of the processor time. */
1709:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 2487              		.loc 1 1709 0
 2488 005c 164B     		ldr	r3, .L169+16
 2489 005e 1A68     		ldr	r2, [r3]
 2490 0060 1346     		mov	r3, r2
 2491 0062 9B00     		lsls	r3, r3, #2
 2492 0064 1344     		add	r3, r3, r2
 2493 0066 9B00     		lsls	r3, r3, #2
 2494 0068 144A     		ldr	r2, .L169+20
 2495 006a 1344     		add	r3, r3, r2
 2496 006c 3B60     		str	r3, [r7]
 2497 006e 3B68     		ldr	r3, [r7]
 2498 0070 5B68     		ldr	r3, [r3, #4]
 2499 0072 5A68     		ldr	r2, [r3, #4]
 2500 0074 3B68     		ldr	r3, [r7]
 2501 0076 5A60     		str	r2, [r3, #4]
 2502 0078 3B68     		ldr	r3, [r7]
 2503 007a 5A68     		ldr	r2, [r3, #4]
 2504 007c 3B68     		ldr	r3, [r7]
 2505 007e 0833     		adds	r3, r3, #8
 2506 0080 9A42     		cmp	r2, r3
 2507 0082 04D1     		bne	.L168
 2508              		.loc 1 1709 0 is_stmt 0 discriminator 1
 2509 0084 3B68     		ldr	r3, [r7]
 2510 0086 5B68     		ldr	r3, [r3, #4]
 2511 0088 5A68     		ldr	r2, [r3, #4]
 2512 008a 3B68     		ldr	r3, [r7]
 2513 008c 5A60     		str	r2, [r3, #4]
 2514              	.L168:
 2515              		.loc 1 1709 0 discriminator 2
 2516 008e 3B68     		ldr	r3, [r7]
 2517 0090 5B68     		ldr	r3, [r3, #4]
 2518 0092 DA68     		ldr	r2, [r3, #12]
 2519 0094 064B     		ldr	r3, .L169+8
 2520 0096 1A60     		str	r2, [r3]
 2521              	.LBE7:
1710:FreeRTOS/Source/tasks.c **** 	
1711:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 2522              		.loc 1 1711 0 is_stmt 1 discriminator 2
 2523 0098 094B     		ldr	r3, .L169+24
 2524 009a 054A     		ldr	r2, .L169+8
 2525 009c 1268     		ldr	r2, [r2]
 2526 009e 926C     		ldr	r2, [r2, #72]
 2527 00a0 DA60     		str	r2, [r3, #12]
 2528              	.L163:
1712:FreeRTOS/Source/tasks.c **** 		vWriteTraceToBuffer();
1713:FreeRTOS/Source/tasks.c **** 	}
1714:FreeRTOS/Source/tasks.c **** }
 2529              		.loc 1 1714 0
 2530 00a2 0837     		adds	r7, r7, #8
 2531 00a4 BD46     		mov	sp, r7
 2532              		@ sp needed
 2533 00a6 80BD     		pop	{r7, pc}
 2534              	.L170:
 2535              		.align	2
 2536              	.L169:
 2537 00a8 00000000 		.word	uxSchedulerSuspended
 2538 00ac 00000000 		.word	xMissedYield
 2539 00b0 00000000 		.word	pxCurrentTCB
 2540 00b4 00000000 		.word	ulTaskSwitchedInTime
 2541 00b8 00000000 		.word	uxTopReadyPriority
 2542 00bc 00000000 		.word	pxReadyTasksLists
 2543 00c0 00740040 		.word	1073771520
 2544              		.cfi_endproc
 2545              	.LFE133:
 2547              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2548              		.align	2
 2549              		.global	vTaskPlaceOnEventList
 2550              		.thumb
 2551              		.thumb_func
 2553              	vTaskPlaceOnEventList:
 2554              	.LFB134:
1715:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1716:FreeRTOS/Source/tasks.c **** 
1717:FreeRTOS/Source/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1718:FreeRTOS/Source/tasks.c **** {
 2555              		.loc 1 1718 0
 2556              		.cfi_startproc
 2557              		@ args = 0, pretend = 0, frame = 16
 2558              		@ frame_needed = 1, uses_anonymous_args = 0
 2559 0000 80B5     		push	{r7, lr}
 2560              	.LCFI68:
 2561              		.cfi_def_cfa_offset 8
 2562              		.cfi_offset 7, -8
 2563              		.cfi_offset 14, -4
 2564 0002 84B0     		sub	sp, sp, #16
 2565              	.LCFI69:
 2566              		.cfi_def_cfa_offset 24
 2567 0004 00AF     		add	r7, sp, #0
 2568              	.LCFI70:
 2569              		.cfi_def_cfa_register 7
 2570 0006 7860     		str	r0, [r7, #4]
 2571 0008 3960     		str	r1, [r7]
1719:FreeRTOS/Source/tasks.c **** portTickType xTimeToWake;
1720:FreeRTOS/Source/tasks.c **** 
1721:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
1722:FreeRTOS/Source/tasks.c **** 
1723:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1724:FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED. */
1725:FreeRTOS/Source/tasks.c **** 
1726:FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1727:FreeRTOS/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1728:FreeRTOS/Source/tasks.c **** 	is the first to be woken by the event. */
1729:FreeRTOS/Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2572              		.loc 1 1729 0
 2573 000a 124B     		ldr	r3, .L174
 2574 000c 1B68     		ldr	r3, [r3]
 2575 000e 1833     		adds	r3, r3, #24
 2576 0010 7868     		ldr	r0, [r7, #4]
 2577 0012 1946     		mov	r1, r3
 2578 0014 FFF7FEFF 		bl	vListInsert
1730:FreeRTOS/Source/tasks.c **** 
1731:FreeRTOS/Source/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1732:FreeRTOS/Source/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1733:FreeRTOS/Source/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1734:FreeRTOS/Source/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2579              		.loc 1 1734 0
 2580 0018 0E4B     		ldr	r3, .L174
 2581 001a 1B68     		ldr	r3, [r3]
 2582 001c 0433     		adds	r3, r3, #4
 2583 001e 1846     		mov	r0, r3
 2584 0020 FFF7FEFF 		bl	vListRemove
1735:FreeRTOS/Source/tasks.c **** 
1736:FreeRTOS/Source/tasks.c **** 
1737:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1738:FreeRTOS/Source/tasks.c **** 	{
1739:FreeRTOS/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 2585              		.loc 1 1739 0
 2586 0024 3B68     		ldr	r3, [r7]
 2587 0026 B3F1FF3F 		cmp	r3, #-1
 2588 002a 07D1     		bne	.L172
1740:FreeRTOS/Source/tasks.c **** 		{
1741:FreeRTOS/Source/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1742:FreeRTOS/Source/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1743:FreeRTOS/Source/tasks.c **** 			indefinitely. */
1744:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 2589              		.loc 1 1744 0
 2590 002c 094B     		ldr	r3, .L174
 2591 002e 1B68     		ldr	r3, [r3]
 2592 0030 0433     		adds	r3, r3, #4
 2593 0032 0948     		ldr	r0, .L174+4
 2594 0034 1946     		mov	r1, r3
 2595 0036 FFF7FEFF 		bl	vListInsertEnd
 2596 003a 07E0     		b	.L171
 2597              	.L172:
1745:FreeRTOS/Source/tasks.c **** 		}
1746:FreeRTOS/Source/tasks.c **** 		else
1747:FreeRTOS/Source/tasks.c **** 		{
1748:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1749:FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1750:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 2598              		.loc 1 1750 0
 2599 003c 074B     		ldr	r3, .L174+8
 2600 003e 1A68     		ldr	r2, [r3]
 2601 0040 3B68     		ldr	r3, [r7]
 2602 0042 1344     		add	r3, r3, r2
 2603 0044 FB60     		str	r3, [r7, #12]
1751:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2604              		.loc 1 1751 0
 2605 0046 F868     		ldr	r0, [r7, #12]
 2606 0048 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 2607              	.L171:
1752:FreeRTOS/Source/tasks.c **** 		}
1753:FreeRTOS/Source/tasks.c **** 	}
1754:FreeRTOS/Source/tasks.c **** 	#else
1755:FreeRTOS/Source/tasks.c **** 	{
1756:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1757:FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1758:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1759:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1760:FreeRTOS/Source/tasks.c **** 	}
1761:FreeRTOS/Source/tasks.c **** 	#endif
1762:FreeRTOS/Source/tasks.c **** }
 2608              		.loc 1 1762 0
 2609 004c 1037     		adds	r7, r7, #16
 2610 004e BD46     		mov	sp, r7
 2611              		@ sp needed
 2612 0050 80BD     		pop	{r7, pc}
 2613              	.L175:
 2614 0052 00BF     		.align	2
 2615              	.L174:
 2616 0054 00000000 		.word	pxCurrentTCB
 2617 0058 00000000 		.word	xSuspendedTaskList
 2618 005c 00000000 		.word	xTickCount
 2619              		.cfi_endproc
 2620              	.LFE134:
 2622              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2623              		.align	2
 2624              		.global	xTaskRemoveFromEventList
 2625              		.thumb
 2626              		.thumb_func
 2628              	xTaskRemoveFromEventList:
 2629              	.LFB135:
1763:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1764:FreeRTOS/Source/tasks.c **** 
1765:FreeRTOS/Source/tasks.c **** #if configUSE_TIMERS == 1
1766:FreeRTOS/Source/tasks.c **** 
1767:FreeRTOS/Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
1768:FreeRTOS/Source/tasks.c **** 	{
1769:FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
1770:FreeRTOS/Source/tasks.c **** 
1771:FreeRTOS/Source/tasks.c **** 		configASSERT( pxEventList );
1772:FreeRTOS/Source/tasks.c **** 
1773:FreeRTOS/Source/tasks.c **** 		/* This function should not be called by application code hence the
1774:FreeRTOS/Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1775:FreeRTOS/Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
1776:FreeRTOS/Source/tasks.c **** 		it should be called from a critical section. */
1777:FreeRTOS/Source/tasks.c **** 
1778:FreeRTOS/Source/tasks.c **** 	
1779:FreeRTOS/Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
1780:FreeRTOS/Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
1781:FreeRTOS/Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
1782:FreeRTOS/Source/tasks.c **** 		can be used in place of vListInsert. */
1783:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1784:FreeRTOS/Source/tasks.c **** 
1785:FreeRTOS/Source/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
1786:FreeRTOS/Source/tasks.c **** 		blocked list as the same list item is used for both lists.  This
1787:FreeRTOS/Source/tasks.c **** 		function is called form a critical section. */
1788:FreeRTOS/Source/tasks.c **** 		vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
1789:FreeRTOS/Source/tasks.c **** 
1790:FreeRTOS/Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
1791:FreeRTOS/Source/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
1792:FreeRTOS/Source/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
1793:FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
1794:FreeRTOS/Source/tasks.c **** 	}
1795:FreeRTOS/Source/tasks.c **** 	
1796:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TIMERS */
1797:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1798:FreeRTOS/Source/tasks.c **** 
1799:FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1800:FreeRTOS/Source/tasks.c **** {
 2630              		.loc 1 1800 0
 2631              		.cfi_startproc
 2632              		@ args = 0, pretend = 0, frame = 16
 2633              		@ frame_needed = 1, uses_anonymous_args = 0
 2634 0000 80B5     		push	{r7, lr}
 2635              	.LCFI71:
 2636              		.cfi_def_cfa_offset 8
 2637              		.cfi_offset 7, -8
 2638              		.cfi_offset 14, -4
 2639 0002 84B0     		sub	sp, sp, #16
 2640              	.LCFI72:
 2641              		.cfi_def_cfa_offset 24
 2642 0004 00AF     		add	r7, sp, #0
 2643              	.LCFI73:
 2644              		.cfi_def_cfa_register 7
 2645 0006 7860     		str	r0, [r7, #4]
1801:FreeRTOS/Source/tasks.c **** tskTCB *pxUnblockedTCB;
1802:FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1803:FreeRTOS/Source/tasks.c **** 
1804:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1805:FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1806:FreeRTOS/Source/tasks.c **** 
1807:FreeRTOS/Source/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1808:FreeRTOS/Source/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1809:FreeRTOS/Source/tasks.c **** 	it to the ready list.
1810:FreeRTOS/Source/tasks.c **** 
1811:FreeRTOS/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
1812:FreeRTOS/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1813:FreeRTOS/Source/tasks.c **** 	means we can always expect exclusive access to the event list here.
1814:FreeRTOS/Source/tasks.c **** 	
1815:FreeRTOS/Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
1816:FreeRTOS/Source/tasks.c **** 	pxEventList is not empty. */
1817:FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2646              		.loc 1 1817 0
 2647 0008 7B68     		ldr	r3, [r7, #4]
 2648 000a DB68     		ldr	r3, [r3, #12]
 2649 000c DB68     		ldr	r3, [r3, #12]
 2650 000e BB60     		str	r3, [r7, #8]
1818:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
1819:FreeRTOS/Source/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2651              		.loc 1 1819 0
 2652 0010 BB68     		ldr	r3, [r7, #8]
 2653 0012 1833     		adds	r3, r3, #24
 2654 0014 1846     		mov	r0, r3
 2655 0016 FFF7FEFF 		bl	vListRemove
1820:FreeRTOS/Source/tasks.c **** 
1821:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2656              		.loc 1 1821 0
 2657 001a 1C4B     		ldr	r3, .L183
 2658 001c 1B68     		ldr	r3, [r3]
 2659 001e 002B     		cmp	r3, #0
 2660 0020 1DD1     		bne	.L177
1822:FreeRTOS/Source/tasks.c **** 	{
1823:FreeRTOS/Source/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2661              		.loc 1 1823 0
 2662 0022 BB68     		ldr	r3, [r7, #8]
 2663 0024 0433     		adds	r3, r3, #4
 2664 0026 1846     		mov	r0, r3
 2665 0028 FFF7FEFF 		bl	vListRemove
1824:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2666              		.loc 1 1824 0
 2667 002c BB68     		ldr	r3, [r7, #8]
 2668 002e DA6A     		ldr	r2, [r3, #44]
 2669 0030 174B     		ldr	r3, .L183+4
 2670 0032 1B68     		ldr	r3, [r3]
 2671 0034 9A42     		cmp	r2, r3
 2672 0036 03D9     		bls	.L178
 2673              		.loc 1 1824 0 is_stmt 0 discriminator 1
 2674 0038 BB68     		ldr	r3, [r7, #8]
 2675 003a DA6A     		ldr	r2, [r3, #44]
 2676 003c 144B     		ldr	r3, .L183+4
 2677 003e 1A60     		str	r2, [r3]
 2678              	.L178:
 2679              		.loc 1 1824 0 discriminator 2
 2680 0040 BB68     		ldr	r3, [r7, #8]
 2681 0042 DA6A     		ldr	r2, [r3, #44]
 2682 0044 1346     		mov	r3, r2
 2683 0046 9B00     		lsls	r3, r3, #2
 2684 0048 1344     		add	r3, r3, r2
 2685 004a 9B00     		lsls	r3, r3, #2
 2686 004c 114A     		ldr	r2, .L183+8
 2687 004e 1A44     		add	r2, r2, r3
 2688 0050 BB68     		ldr	r3, [r7, #8]
 2689 0052 0433     		adds	r3, r3, #4
 2690 0054 1046     		mov	r0, r2
 2691 0056 1946     		mov	r1, r3
 2692 0058 FFF7FEFF 		bl	vListInsertEnd
 2693 005c 05E0     		b	.L179
 2694              	.L177:
1825:FreeRTOS/Source/tasks.c **** 	}
1826:FreeRTOS/Source/tasks.c **** 	else
1827:FreeRTOS/Source/tasks.c **** 	{
1828:FreeRTOS/Source/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1829:FreeRTOS/Source/tasks.c **** 		task pending until the scheduler is resumed. */
1830:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2695              		.loc 1 1830 0 is_stmt 1
 2696 005e BB68     		ldr	r3, [r7, #8]
 2697 0060 1833     		adds	r3, r3, #24
 2698 0062 0D48     		ldr	r0, .L183+12
 2699 0064 1946     		mov	r1, r3
 2700 0066 FFF7FEFF 		bl	vListInsertEnd
 2701              	.L179:
1831:FreeRTOS/Source/tasks.c **** 	}
1832:FreeRTOS/Source/tasks.c **** 
1833:FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2702              		.loc 1 1833 0
 2703 006a BB68     		ldr	r3, [r7, #8]
 2704 006c DA6A     		ldr	r2, [r3, #44]
 2705 006e 0B4B     		ldr	r3, .L183+16
 2706 0070 1B68     		ldr	r3, [r3]
 2707 0072 DB6A     		ldr	r3, [r3, #44]
 2708 0074 9A42     		cmp	r2, r3
 2709 0076 02D3     		bcc	.L180
1834:FreeRTOS/Source/tasks.c **** 	{
1835:FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has
1836:FreeRTOS/Source/tasks.c **** 		a higher priority than the calling task.  This allows
1837:FreeRTOS/Source/tasks.c **** 		the calling task to know if it should force a context
1838:FreeRTOS/Source/tasks.c **** 		switch now. */
1839:FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
 2710              		.loc 1 1839 0
 2711 0078 0123     		movs	r3, #1
 2712 007a FB60     		str	r3, [r7, #12]
 2713 007c 01E0     		b	.L181
 2714              	.L180:
1840:FreeRTOS/Source/tasks.c **** 	}
1841:FreeRTOS/Source/tasks.c **** 	else
1842:FreeRTOS/Source/tasks.c **** 	{
1843:FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
 2715              		.loc 1 1843 0
 2716 007e 0023     		movs	r3, #0
 2717 0080 FB60     		str	r3, [r7, #12]
 2718              	.L181:
1844:FreeRTOS/Source/tasks.c **** 	}
1845:FreeRTOS/Source/tasks.c **** 
1846:FreeRTOS/Source/tasks.c **** 	return xReturn;
 2719              		.loc 1 1846 0
 2720 0082 FB68     		ldr	r3, [r7, #12]
1847:FreeRTOS/Source/tasks.c **** }
 2721              		.loc 1 1847 0
 2722 0084 1846     		mov	r0, r3
 2723 0086 1037     		adds	r7, r7, #16
 2724 0088 BD46     		mov	sp, r7
 2725              		@ sp needed
 2726 008a 80BD     		pop	{r7, pc}
 2727              	.L184:
 2728              		.align	2
 2729              	.L183:
 2730 008c 00000000 		.word	uxSchedulerSuspended
 2731 0090 00000000 		.word	uxTopReadyPriority
 2732 0094 00000000 		.word	pxReadyTasksLists
 2733 0098 00000000 		.word	xPendingReadyList
 2734 009c 00000000 		.word	pxCurrentTCB
 2735              		.cfi_endproc
 2736              	.LFE135:
 2738              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 2739              		.align	2
 2740              		.global	vTaskSetTimeOutState
 2741              		.thumb
 2742              		.thumb_func
 2744              	vTaskSetTimeOutState:
 2745              	.LFB136:
1848:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1849:FreeRTOS/Source/tasks.c **** 
1850:FreeRTOS/Source/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1851:FreeRTOS/Source/tasks.c **** {
 2746              		.loc 1 1851 0
 2747              		.cfi_startproc
 2748              		@ args = 0, pretend = 0, frame = 8
 2749              		@ frame_needed = 1, uses_anonymous_args = 0
 2750              		@ link register save eliminated.
 2751 0000 80B4     		push	{r7}
 2752              	.LCFI74:
 2753              		.cfi_def_cfa_offset 4
 2754              		.cfi_offset 7, -4
 2755 0002 83B0     		sub	sp, sp, #12
 2756              	.LCFI75:
 2757              		.cfi_def_cfa_offset 16
 2758 0004 00AF     		add	r7, sp, #0
 2759              	.LCFI76:
 2760              		.cfi_def_cfa_register 7
 2761 0006 7860     		str	r0, [r7, #4]
1852:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
1853:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2762              		.loc 1 1853 0
 2763 0008 064B     		ldr	r3, .L186
 2764 000a 1A68     		ldr	r2, [r3]
 2765 000c 7B68     		ldr	r3, [r7, #4]
 2766 000e 1A60     		str	r2, [r3]
1854:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2767              		.loc 1 1854 0
 2768 0010 054B     		ldr	r3, .L186+4
 2769 0012 1A68     		ldr	r2, [r3]
 2770 0014 7B68     		ldr	r3, [r7, #4]
 2771 0016 5A60     		str	r2, [r3, #4]
1855:FreeRTOS/Source/tasks.c **** }
 2772              		.loc 1 1855 0
 2773 0018 0C37     		adds	r7, r7, #12
 2774 001a BD46     		mov	sp, r7
 2775              		@ sp needed
 2776 001c 5DF8047B 		ldr	r7, [sp], #4
 2777 0020 7047     		bx	lr
 2778              	.L187:
 2779 0022 00BF     		.align	2
 2780              	.L186:
 2781 0024 00000000 		.word	xNumOfOverflows
 2782 0028 00000000 		.word	xTickCount
 2783              		.cfi_endproc
 2784              	.LFE136:
 2786              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 2787              		.align	2
 2788              		.global	xTaskCheckForTimeOut
 2789              		.thumb
 2790              		.thumb_func
 2792              	xTaskCheckForTimeOut:
 2793              	.LFB137:
1856:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1857:FreeRTOS/Source/tasks.c **** 
1858:FreeRTOS/Source/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
1859:FreeRTOS/Source/tasks.c **** {
 2794              		.loc 1 1859 0
 2795              		.cfi_startproc
 2796              		@ args = 0, pretend = 0, frame = 16
 2797              		@ frame_needed = 1, uses_anonymous_args = 0
 2798 0000 80B5     		push	{r7, lr}
 2799              	.LCFI77:
 2800              		.cfi_def_cfa_offset 8
 2801              		.cfi_offset 7, -8
 2802              		.cfi_offset 14, -4
 2803 0002 84B0     		sub	sp, sp, #16
 2804              	.LCFI78:
 2805              		.cfi_def_cfa_offset 24
 2806 0004 00AF     		add	r7, sp, #0
 2807              	.LCFI79:
 2808              		.cfi_def_cfa_register 7
 2809 0006 7860     		str	r0, [r7, #4]
 2810 0008 3960     		str	r1, [r7]
1860:FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1861:FreeRTOS/Source/tasks.c **** 
1862:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
1863:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTicksToWait );
1864:FreeRTOS/Source/tasks.c **** 
1865:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 2811              		.loc 1 1865 0
 2812 000a FFF7FEFF 		bl	vPortEnterCritical
1866:FreeRTOS/Source/tasks.c **** 	{
1867:FreeRTOS/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
1868:FreeRTOS/Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
1869:FreeRTOS/Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
1870:FreeRTOS/Source/tasks.c **** 			therefore never time out. */
1871:FreeRTOS/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 2813              		.loc 1 1871 0
 2814 000e 3B68     		ldr	r3, [r7]
 2815 0010 1B68     		ldr	r3, [r3]
 2816 0012 B3F1FF3F 		cmp	r3, #-1
 2817 0016 02D1     		bne	.L189
1872:FreeRTOS/Source/tasks.c **** 			{
1873:FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
 2818              		.loc 1 1873 0
 2819 0018 0023     		movs	r3, #0
 2820 001a FB60     		str	r3, [r7, #12]
 2821 001c 29E0     		b	.L190
 2822              	.L189:
1874:FreeRTOS/Source/tasks.c **** 			}
1875:FreeRTOS/Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
1876:FreeRTOS/Source/tasks.c **** 		#endif
1877:FreeRTOS/Source/tasks.c **** 
1878:FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2823              		.loc 1 1878 0
 2824 001e 7B68     		ldr	r3, [r7, #4]
 2825 0020 1A68     		ldr	r2, [r3]
 2826 0022 174B     		ldr	r3, .L194
 2827 0024 1B68     		ldr	r3, [r3]
 2828 0026 9A42     		cmp	r2, r3
 2829 0028 08D0     		beq	.L191
 2830              		.loc 1 1878 0 is_stmt 0 discriminator 1
 2831 002a 7B68     		ldr	r3, [r7, #4]
 2832 002c 5A68     		ldr	r2, [r3, #4]
 2833 002e 154B     		ldr	r3, .L194+4
 2834 0030 1B68     		ldr	r3, [r3]
 2835 0032 9A42     		cmp	r2, r3
 2836 0034 02D8     		bhi	.L191
1879:FreeRTOS/Source/tasks.c **** 		{
1880:FreeRTOS/Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
1881:FreeRTOS/Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
1882:FreeRTOS/Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
1883:FreeRTOS/Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
1884:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 2837              		.loc 1 1884 0 is_stmt 1
 2838 0036 0123     		movs	r3, #1
 2839 0038 FB60     		str	r3, [r7, #12]
 2840 003a 1AE0     		b	.L190
 2841              	.L191:
1885:FreeRTOS/Source/tasks.c **** 		}
1886:FreeRTOS/Source/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 2842              		.loc 1 1886 0
 2843 003c 114B     		ldr	r3, .L194+4
 2844 003e 1A68     		ldr	r2, [r3]
 2845 0040 7B68     		ldr	r3, [r7, #4]
 2846 0042 5B68     		ldr	r3, [r3, #4]
 2847 0044 D21A     		subs	r2, r2, r3
 2848 0046 3B68     		ldr	r3, [r7]
 2849 0048 1B68     		ldr	r3, [r3]
 2850 004a 9A42     		cmp	r2, r3
 2851 004c 0FD2     		bcs	.L192
1887:FreeRTOS/Source/tasks.c **** 		{
1888:FreeRTOS/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
1889:FreeRTOS/Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 2852              		.loc 1 1889 0
 2853 004e 3B68     		ldr	r3, [r7]
 2854 0050 1A68     		ldr	r2, [r3]
 2855 0052 7B68     		ldr	r3, [r7, #4]
 2856 0054 5968     		ldr	r1, [r3, #4]
 2857 0056 0B4B     		ldr	r3, .L194+4
 2858 0058 1B68     		ldr	r3, [r3]
 2859 005a CB1A     		subs	r3, r1, r3
 2860 005c 1A44     		add	r2, r2, r3
 2861 005e 3B68     		ldr	r3, [r7]
 2862 0060 1A60     		str	r2, [r3]
1890:FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2863              		.loc 1 1890 0
 2864 0062 7868     		ldr	r0, [r7, #4]
 2865 0064 FFF7FEFF 		bl	vTaskSetTimeOutState
1891:FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
 2866              		.loc 1 1891 0
 2867 0068 0023     		movs	r3, #0
 2868 006a FB60     		str	r3, [r7, #12]
 2869 006c 01E0     		b	.L190
 2870              	.L192:
1892:FreeRTOS/Source/tasks.c **** 		}
1893:FreeRTOS/Source/tasks.c **** 		else
1894:FreeRTOS/Source/tasks.c **** 		{
1895:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 2871              		.loc 1 1895 0
 2872 006e 0123     		movs	r3, #1
 2873 0070 FB60     		str	r3, [r7, #12]
 2874              	.L190:
1896:FreeRTOS/Source/tasks.c **** 		}
1897:FreeRTOS/Source/tasks.c **** 	}
1898:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 2875              		.loc 1 1898 0
 2876 0072 FFF7FEFF 		bl	vPortExitCritical
1899:FreeRTOS/Source/tasks.c **** 
1900:FreeRTOS/Source/tasks.c **** 	return xReturn;
 2877              		.loc 1 1900 0
 2878 0076 FB68     		ldr	r3, [r7, #12]
1901:FreeRTOS/Source/tasks.c **** }
 2879              		.loc 1 1901 0
 2880 0078 1846     		mov	r0, r3
 2881 007a 1037     		adds	r7, r7, #16
 2882 007c BD46     		mov	sp, r7
 2883              		@ sp needed
 2884 007e 80BD     		pop	{r7, pc}
 2885              	.L195:
 2886              		.align	2
 2887              	.L194:
 2888 0080 00000000 		.word	xNumOfOverflows
 2889 0084 00000000 		.word	xTickCount
 2890              		.cfi_endproc
 2891              	.LFE137:
 2893              		.section	.text.vTaskMissedYield,"ax",%progbits
 2894              		.align	2
 2895              		.global	vTaskMissedYield
 2896              		.thumb
 2897              		.thumb_func
 2899              	vTaskMissedYield:
 2900              	.LFB138:
1902:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1903:FreeRTOS/Source/tasks.c **** 
1904:FreeRTOS/Source/tasks.c **** void vTaskMissedYield( void )
1905:FreeRTOS/Source/tasks.c **** {
 2901              		.loc 1 1905 0
 2902              		.cfi_startproc
 2903              		@ args = 0, pretend = 0, frame = 0
 2904              		@ frame_needed = 1, uses_anonymous_args = 0
 2905              		@ link register save eliminated.
 2906 0000 80B4     		push	{r7}
 2907              	.LCFI80:
 2908              		.cfi_def_cfa_offset 4
 2909              		.cfi_offset 7, -4
 2910 0002 00AF     		add	r7, sp, #0
 2911              	.LCFI81:
 2912              		.cfi_def_cfa_register 7
1906:FreeRTOS/Source/tasks.c **** 	xMissedYield = pdTRUE;
 2913              		.loc 1 1906 0
 2914 0004 034B     		ldr	r3, .L197
 2915 0006 0122     		movs	r2, #1
 2916 0008 1A60     		str	r2, [r3]
1907:FreeRTOS/Source/tasks.c **** }
 2917              		.loc 1 1907 0
 2918 000a BD46     		mov	sp, r7
 2919              		@ sp needed
 2920 000c 5DF8047B 		ldr	r7, [sp], #4
 2921 0010 7047     		bx	lr
 2922              	.L198:
 2923 0012 00BF     		.align	2
 2924              	.L197:
 2925 0014 00000000 		.word	xMissedYield
 2926              		.cfi_endproc
 2927              	.LFE138:
 2929              		.section	.text.prvIdleTask,"ax",%progbits
 2930              		.align	2
 2931              		.thumb
 2932              		.thumb_func
 2934              	prvIdleTask:
 2935              	.LFB139:
1908:FreeRTOS/Source/tasks.c **** 
1909:FreeRTOS/Source/tasks.c **** /*
1910:FreeRTOS/Source/tasks.c ****  * -----------------------------------------------------------
1911:FreeRTOS/Source/tasks.c ****  * The Idle task.
1912:FreeRTOS/Source/tasks.c ****  * ----------------------------------------------------------
1913:FreeRTOS/Source/tasks.c ****  *
1914:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
1915:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
1916:FreeRTOS/Source/tasks.c ****  *
1917:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
1918:FreeRTOS/Source/tasks.c ****  *
1919:FreeRTOS/Source/tasks.c ****  */
1920:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
1921:FreeRTOS/Source/tasks.c **** {
 2936              		.loc 1 1921 0
 2937              		.cfi_startproc
 2938              		@ args = 0, pretend = 0, frame = 8
 2939              		@ frame_needed = 1, uses_anonymous_args = 0
 2940 0000 80B5     		push	{r7, lr}
 2941              	.LCFI82:
 2942              		.cfi_def_cfa_offset 8
 2943              		.cfi_offset 7, -8
 2944              		.cfi_offset 14, -4
 2945 0002 82B0     		sub	sp, sp, #8
 2946              	.LCFI83:
 2947              		.cfi_def_cfa_offset 16
 2948 0004 00AF     		add	r7, sp, #0
 2949              	.LCFI84:
 2950              		.cfi_def_cfa_register 7
 2951 0006 7860     		str	r0, [r7, #4]
 2952              	.L201:
1922:FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
1923:FreeRTOS/Source/tasks.c **** 	( void ) pvParameters;
1924:FreeRTOS/Source/tasks.c **** 
1925:FreeRTOS/Source/tasks.c **** 	for( ;; )
1926:FreeRTOS/Source/tasks.c **** 	{
1927:FreeRTOS/Source/tasks.c **** 		/* See if any tasks have been deleted. */
1928:FreeRTOS/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
 2953              		.loc 1 1928 0
 2954 0008 FFF7FEFF 		bl	prvCheckTasksWaitingTermination
1929:FreeRTOS/Source/tasks.c **** 
1930:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
1931:FreeRTOS/Source/tasks.c **** 		{
1932:FreeRTOS/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
1933:FreeRTOS/Source/tasks.c **** 			see if any other task has become available.  If we are using
1934:FreeRTOS/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
1935:FreeRTOS/Source/tasks.c **** 			will automatically get the processor anyway. */
1936:FreeRTOS/Source/tasks.c **** 			taskYIELD();
1937:FreeRTOS/Source/tasks.c **** 		}
1938:FreeRTOS/Source/tasks.c **** 		#endif
1939:FreeRTOS/Source/tasks.c **** 
1940:FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1941:FreeRTOS/Source/tasks.c **** 		{
1942:FreeRTOS/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
1943:FreeRTOS/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
1944:FreeRTOS/Source/tasks.c **** 			to run then the idle task should yield before the end of the
1945:FreeRTOS/Source/tasks.c **** 			timeslice.
1946:FreeRTOS/Source/tasks.c **** 
1947:FreeRTOS/Source/tasks.c **** 			A critical region is not required here as we are just reading from
1948:FreeRTOS/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
1949:FreeRTOS/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
1950:FreeRTOS/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
1951:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
 2955              		.loc 1 1951 0
 2956 000c 034B     		ldr	r3, .L202
 2957 000e 1B68     		ldr	r3, [r3]
 2958 0010 012B     		cmp	r3, #1
 2959 0012 02D9     		bls	.L200
1952:FreeRTOS/Source/tasks.c **** 			{
1953:FreeRTOS/Source/tasks.c **** 				taskYIELD();
 2960              		.loc 1 1953 0
 2961 0014 FFF7FEFF 		bl	vPortYieldFromISR
1954:FreeRTOS/Source/tasks.c **** 			}
1955:FreeRTOS/Source/tasks.c **** 		}
1956:FreeRTOS/Source/tasks.c **** 		#endif
1957:FreeRTOS/Source/tasks.c **** 
1958:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
1959:FreeRTOS/Source/tasks.c **** 		{
1960:FreeRTOS/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
1961:FreeRTOS/Source/tasks.c **** 
1962:FreeRTOS/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
1963:FreeRTOS/Source/tasks.c **** 			allows the application designer to add background functionality
1964:FreeRTOS/Source/tasks.c **** 			without the overhead of a separate task.
1965:FreeRTOS/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
1966:FreeRTOS/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
1967:FreeRTOS/Source/tasks.c **** 			vApplicationIdleHook();
1968:FreeRTOS/Source/tasks.c **** 		}
1969:FreeRTOS/Source/tasks.c **** 		#endif
1970:FreeRTOS/Source/tasks.c **** 	}
 2962              		.loc 1 1970 0
 2963 0018 F6E7     		b	.L201
 2964              	.L200:
 2965 001a F5E7     		b	.L201
 2966              	.L203:
 2967              		.align	2
 2968              	.L202:
 2969 001c 00000000 		.word	pxReadyTasksLists
 2970              		.cfi_endproc
 2971              	.LFE139:
 2973              		.section	.text.prvInitialiseTCBVariables,"ax",%progbits
 2974              		.align	2
 2975              		.thumb
 2976              		.thumb_func
 2978              	prvInitialiseTCBVariables:
 2979              	.LFB140:
1971:FreeRTOS/Source/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
1972:FreeRTOS/Source/tasks.c **** 
1973:FreeRTOS/Source/tasks.c **** 
1974:FreeRTOS/Source/tasks.c **** 
1975:FreeRTOS/Source/tasks.c **** 
1976:FreeRTOS/Source/tasks.c **** 
1977:FreeRTOS/Source/tasks.c **** 
1978:FreeRTOS/Source/tasks.c **** 
1979:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1980:FreeRTOS/Source/tasks.c ****  * File private functions documented at the top of the file.
1981:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1982:FreeRTOS/Source/tasks.c **** 
1983:FreeRTOS/Source/tasks.c **** 
1984:FreeRTOS/Source/tasks.c **** 
1985:FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
1986:FreeRTOS/Source/tasks.c **** {
 2980              		.loc 1 1986 0
 2981              		.cfi_startproc
 2982              		@ args = 4, pretend = 0, frame = 16
 2983              		@ frame_needed = 1, uses_anonymous_args = 0
 2984 0000 80B5     		push	{r7, lr}
 2985              	.LCFI85:
 2986              		.cfi_def_cfa_offset 8
 2987              		.cfi_offset 7, -8
 2988              		.cfi_offset 14, -4
 2989 0002 84B0     		sub	sp, sp, #16
 2990              	.LCFI86:
 2991              		.cfi_def_cfa_offset 24
 2992 0004 00AF     		add	r7, sp, #0
 2993              	.LCFI87:
 2994              		.cfi_def_cfa_register 7
 2995 0006 F860     		str	r0, [r7, #12]
 2996 0008 B960     		str	r1, [r7, #8]
 2997 000a 7A60     		str	r2, [r7, #4]
 2998 000c 3B60     		str	r3, [r7]
1987:FreeRTOS/Source/tasks.c **** 	/* Store the function name in the TCB. */
1988:FreeRTOS/Source/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
1989:FreeRTOS/Source/tasks.c **** 	{
1990:FreeRTOS/Source/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
1991:FreeRTOS/Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 2999              		.loc 1 1991 0
 3000 000e FB68     		ldr	r3, [r7, #12]
 3001 0010 3433     		adds	r3, r3, #52
 3002 0012 1846     		mov	r0, r3
 3003 0014 B968     		ldr	r1, [r7, #8]
 3004 0016 1022     		movs	r2, #16
 3005 0018 FFF7FEFF 		bl	strncpy
1992:FreeRTOS/Source/tasks.c **** 	}
1993:FreeRTOS/Source/tasks.c **** 	#endif
1994:FreeRTOS/Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
 3006              		.loc 1 1994 0
 3007 001c FB68     		ldr	r3, [r7, #12]
 3008 001e 0022     		movs	r2, #0
 3009 0020 83F84320 		strb	r2, [r3, #67]
1995:FreeRTOS/Source/tasks.c **** 
1996:FreeRTOS/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
1997:FreeRTOS/Source/tasks.c **** 	remove the privilege bit if one is present. */
1998:FreeRTOS/Source/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
 3010              		.loc 1 1998 0
 3011 0024 7B68     		ldr	r3, [r7, #4]
 3012 0026 042B     		cmp	r3, #4
 3013 0028 01D9     		bls	.L205
1999:FreeRTOS/Source/tasks.c **** 	{
2000:FreeRTOS/Source/tasks.c **** 		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 3014              		.loc 1 2000 0
 3015 002a 0423     		movs	r3, #4
 3016 002c 7B60     		str	r3, [r7, #4]
 3017              	.L205:
2001:FreeRTOS/Source/tasks.c **** 	}
2002:FreeRTOS/Source/tasks.c **** 
2003:FreeRTOS/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 3018              		.loc 1 2003 0
 3019 002e FB68     		ldr	r3, [r7, #12]
 3020 0030 7A68     		ldr	r2, [r7, #4]
 3021 0032 DA62     		str	r2, [r3, #44]
2004:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
2005:FreeRTOS/Source/tasks.c **** 	{
2006:FreeRTOS/Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
 3022              		.loc 1 2006 0
 3023 0034 FB68     		ldr	r3, [r7, #12]
 3024 0036 7A68     		ldr	r2, [r7, #4]
 3025 0038 5A64     		str	r2, [r3, #68]
2007:FreeRTOS/Source/tasks.c **** 	}
2008:FreeRTOS/Source/tasks.c **** 	#endif
2009:FreeRTOS/Source/tasks.c **** 
2010:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 3026              		.loc 1 2010 0
 3027 003a FB68     		ldr	r3, [r7, #12]
 3028 003c 0433     		adds	r3, r3, #4
 3029 003e 1846     		mov	r0, r3
 3030 0040 FFF7FEFF 		bl	vListInitialiseItem
2011:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 3031              		.loc 1 2011 0
 3032 0044 FB68     		ldr	r3, [r7, #12]
 3033 0046 1833     		adds	r3, r3, #24
 3034 0048 1846     		mov	r0, r3
 3035 004a FFF7FEFF 		bl	vListInitialiseItem
2012:FreeRTOS/Source/tasks.c **** 
2013:FreeRTOS/Source/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
2014:FreeRTOS/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
2015:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 3036              		.loc 1 2015 0
 3037 004e FB68     		ldr	r3, [r7, #12]
 3038 0050 FA68     		ldr	r2, [r7, #12]
 3039 0052 1A61     		str	r2, [r3, #16]
2016:FreeRTOS/Source/tasks.c **** 
2017:FreeRTOS/Source/tasks.c **** 	/* Event lists are always in priority order. */
2018:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 3040              		.loc 1 2018 0
 3041 0054 7B68     		ldr	r3, [r7, #4]
 3042 0056 C3F10502 		rsb	r2, r3, #5
 3043 005a FB68     		ldr	r3, [r7, #12]
 3044 005c 9A61     		str	r2, [r3, #24]
2019:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 3045              		.loc 1 2019 0
 3046 005e FB68     		ldr	r3, [r7, #12]
 3047 0060 FA68     		ldr	r2, [r7, #12]
 3048 0062 5A62     		str	r2, [r3, #36]
2020:FreeRTOS/Source/tasks.c **** 
2021:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2022:FreeRTOS/Source/tasks.c **** 	{
2023:FreeRTOS/Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
2024:FreeRTOS/Source/tasks.c **** 	}
2025:FreeRTOS/Source/tasks.c **** 	#endif
2026:FreeRTOS/Source/tasks.c **** 
2027:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2028:FreeRTOS/Source/tasks.c **** 	{
2029:FreeRTOS/Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
 3049              		.loc 1 2029 0
 3050 0064 FB68     		ldr	r3, [r7, #12]
 3051 0066 0022     		movs	r2, #0
 3052 0068 9A64     		str	r2, [r3, #72]
2030:FreeRTOS/Source/tasks.c **** 	}
2031:FreeRTOS/Source/tasks.c **** 	#endif
2032:FreeRTOS/Source/tasks.c **** 
2033:FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2034:FreeRTOS/Source/tasks.c **** 	{
2035:FreeRTOS/Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
 3053              		.loc 1 2035 0
 3054 006a FB68     		ldr	r3, [r7, #12]
 3055 006c 0022     		movs	r2, #0
 3056 006e DA64     		str	r2, [r3, #76]
2036:FreeRTOS/Source/tasks.c **** 	}
2037:FreeRTOS/Source/tasks.c **** 	#endif
2038:FreeRTOS/Source/tasks.c **** 
2039:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
2040:FreeRTOS/Source/tasks.c **** 	{
2041:FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2042:FreeRTOS/Source/tasks.c **** 	}
2043:FreeRTOS/Source/tasks.c **** 	#else
2044:FreeRTOS/Source/tasks.c **** 	{
2045:FreeRTOS/Source/tasks.c **** 		( void ) xRegions;
2046:FreeRTOS/Source/tasks.c **** 		( void ) usStackDepth;
2047:FreeRTOS/Source/tasks.c **** 	}
2048:FreeRTOS/Source/tasks.c **** 	#endif
2049:FreeRTOS/Source/tasks.c **** }
 3057              		.loc 1 2049 0
 3058 0070 1037     		adds	r7, r7, #16
 3059 0072 BD46     		mov	sp, r7
 3060              		@ sp needed
 3061 0074 80BD     		pop	{r7, pc}
 3062              		.cfi_endproc
 3063              	.LFE140:
 3065 0076 00BF     		.section	.text.prvInitialiseTaskLists,"ax",%progbits
 3066              		.align	2
 3067              		.thumb
 3068              		.thumb_func
 3070              	prvInitialiseTaskLists:
 3071              	.LFB141:
2050:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2051:FreeRTOS/Source/tasks.c **** 
2052:FreeRTOS/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2053:FreeRTOS/Source/tasks.c **** 
2054:FreeRTOS/Source/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2055:FreeRTOS/Source/tasks.c **** 	{
2056:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
2057:FreeRTOS/Source/tasks.c **** 	
2058:FreeRTOS/Source/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
2059:FreeRTOS/Source/tasks.c **** 		{
2060:FreeRTOS/Source/tasks.c **** 			xTaskToModify = NULL;
2061:FreeRTOS/Source/tasks.c **** 		}
2062:FreeRTOS/Source/tasks.c **** 
2063:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2064:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2065:FreeRTOS/Source/tasks.c **** 
2066:FreeRTOS/Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2067:FreeRTOS/Source/tasks.c **** 	}
2068:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
2069:FreeRTOS/Source/tasks.c **** #endif
2070:FreeRTOS/Source/tasks.c **** 
2071:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void )
2072:FreeRTOS/Source/tasks.c **** {
 3072              		.loc 1 2072 0
 3073              		.cfi_startproc
 3074              		@ args = 0, pretend = 0, frame = 8
 3075              		@ frame_needed = 1, uses_anonymous_args = 0
 3076 0000 80B5     		push	{r7, lr}
 3077              	.LCFI88:
 3078              		.cfi_def_cfa_offset 8
 3079              		.cfi_offset 7, -8
 3080              		.cfi_offset 14, -4
 3081 0002 82B0     		sub	sp, sp, #8
 3082              	.LCFI89:
 3083              		.cfi_def_cfa_offset 16
 3084 0004 00AF     		add	r7, sp, #0
 3085              	.LCFI90:
 3086              		.cfi_def_cfa_register 7
2073:FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxPriority;
2074:FreeRTOS/Source/tasks.c **** 
2075:FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 3087              		.loc 1 2075 0
 3088 0006 0023     		movs	r3, #0
 3089 0008 7B60     		str	r3, [r7, #4]
 3090 000a 0CE0     		b	.L207
 3091              	.L208:
2076:FreeRTOS/Source/tasks.c **** 	{
2077:FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 3092              		.loc 1 2077 0 discriminator 2
 3093 000c 7A68     		ldr	r2, [r7, #4]
 3094 000e 1346     		mov	r3, r2
 3095 0010 9B00     		lsls	r3, r3, #2
 3096 0012 1344     		add	r3, r3, r2
 3097 0014 9B00     		lsls	r3, r3, #2
 3098 0016 114A     		ldr	r2, .L209
 3099 0018 1344     		add	r3, r3, r2
 3100 001a 1846     		mov	r0, r3
 3101 001c FFF7FEFF 		bl	vListInitialise
2075:FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 3102              		.loc 1 2075 0 discriminator 2
 3103 0020 7B68     		ldr	r3, [r7, #4]
 3104 0022 0133     		adds	r3, r3, #1
 3105 0024 7B60     		str	r3, [r7, #4]
 3106              	.L207:
2075:FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 3107              		.loc 1 2075 0 is_stmt 0 discriminator 1
 3108 0026 7B68     		ldr	r3, [r7, #4]
 3109 0028 042B     		cmp	r3, #4
 3110 002a EFD9     		bls	.L208
2078:FreeRTOS/Source/tasks.c **** 	}
2079:FreeRTOS/Source/tasks.c **** 
2080:FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 3111              		.loc 1 2080 0 is_stmt 1
 3112 002c 0C48     		ldr	r0, .L209+4
 3113 002e FFF7FEFF 		bl	vListInitialise
2081:FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 3114              		.loc 1 2081 0
 3115 0032 0C48     		ldr	r0, .L209+8
 3116 0034 FFF7FEFF 		bl	vListInitialise
2082:FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 3117              		.loc 1 2082 0
 3118 0038 0B48     		ldr	r0, .L209+12
 3119 003a FFF7FEFF 		bl	vListInitialise
2083:FreeRTOS/Source/tasks.c **** 
2084:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2085:FreeRTOS/Source/tasks.c **** 	{
2086:FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 3120              		.loc 1 2086 0
 3121 003e 0B48     		ldr	r0, .L209+16
 3122 0040 FFF7FEFF 		bl	vListInitialise
2087:FreeRTOS/Source/tasks.c **** 	}
2088:FreeRTOS/Source/tasks.c **** 	#endif
2089:FreeRTOS/Source/tasks.c **** 
2090:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2091:FreeRTOS/Source/tasks.c **** 	{
2092:FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 3123              		.loc 1 2092 0
 3124 0044 0A48     		ldr	r0, .L209+20
 3125 0046 FFF7FEFF 		bl	vListInitialise
2093:FreeRTOS/Source/tasks.c **** 	}
2094:FreeRTOS/Source/tasks.c **** 	#endif
2095:FreeRTOS/Source/tasks.c **** 
2096:FreeRTOS/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2097:FreeRTOS/Source/tasks.c **** 	using list2. */
2098:FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 3126              		.loc 1 2098 0
 3127 004a 0A4B     		ldr	r3, .L209+24
 3128 004c 044A     		ldr	r2, .L209+4
 3129 004e 1A60     		str	r2, [r3]
2099:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 3130              		.loc 1 2099 0
 3131 0050 094B     		ldr	r3, .L209+28
 3132 0052 044A     		ldr	r2, .L209+8
 3133 0054 1A60     		str	r2, [r3]
2100:FreeRTOS/Source/tasks.c **** }
 3134              		.loc 1 2100 0
 3135 0056 0837     		adds	r7, r7, #8
 3136 0058 BD46     		mov	sp, r7
 3137              		@ sp needed
 3138 005a 80BD     		pop	{r7, pc}
 3139              	.L210:
 3140              		.align	2
 3141              	.L209:
 3142 005c 00000000 		.word	pxReadyTasksLists
 3143 0060 00000000 		.word	xDelayedTaskList1
 3144 0064 00000000 		.word	xDelayedTaskList2
 3145 0068 00000000 		.word	xPendingReadyList
 3146 006c 00000000 		.word	xTasksWaitingTermination
 3147 0070 00000000 		.word	xSuspendedTaskList
 3148 0074 00000000 		.word	pxDelayedTaskList
 3149 0078 00000000 		.word	pxOverflowDelayedTaskList
 3150              		.cfi_endproc
 3151              	.LFE141:
 3153              		.section	.text.prvCheckTasksWaitingTermination,"ax",%progbits
 3154              		.align	2
 3155              		.thumb
 3156              		.thumb_func
 3158              	prvCheckTasksWaitingTermination:
 3159              	.LFB142:
2101:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2102:FreeRTOS/Source/tasks.c **** 
2103:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2104:FreeRTOS/Source/tasks.c **** {
 3160              		.loc 1 2104 0
 3161              		.cfi_startproc
 3162              		@ args = 0, pretend = 0, frame = 8
 3163              		@ frame_needed = 1, uses_anonymous_args = 0
 3164 0000 80B5     		push	{r7, lr}
 3165              	.LCFI91:
 3166              		.cfi_def_cfa_offset 8
 3167              		.cfi_offset 7, -8
 3168              		.cfi_offset 14, -4
 3169 0002 82B0     		sub	sp, sp, #8
 3170              	.LCFI92:
 3171              		.cfi_def_cfa_offset 16
 3172 0004 00AF     		add	r7, sp, #0
 3173              	.LCFI93:
 3174              		.cfi_def_cfa_register 7
 3175              	.LBB8:
2105:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2106:FreeRTOS/Source/tasks.c **** 	{
2107:FreeRTOS/Source/tasks.c **** 		portBASE_TYPE xListIsEmpty;
2108:FreeRTOS/Source/tasks.c **** 
2109:FreeRTOS/Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2110:FreeRTOS/Source/tasks.c **** 		too often in the idle task. */
2111:FreeRTOS/Source/tasks.c **** 		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 3176              		.loc 1 2111 0
 3177 0006 184B     		ldr	r3, .L213
 3178 0008 1B68     		ldr	r3, [r3]
 3179 000a 002B     		cmp	r3, #0
 3180 000c 28D0     		beq	.L211
2112:FreeRTOS/Source/tasks.c **** 		{
2113:FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 3181              		.loc 1 2113 0
 3182 000e FFF7FEFF 		bl	vTaskSuspendAll
2114:FreeRTOS/Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 3183              		.loc 1 2114 0
 3184 0012 164B     		ldr	r3, .L213+4
 3185 0014 1B68     		ldr	r3, [r3]
 3186 0016 002B     		cmp	r3, #0
 3187 0018 14BF     		ite	ne
 3188 001a 0023     		movne	r3, #0
 3189 001c 0123     		moveq	r3, #1
 3190 001e DBB2     		uxtb	r3, r3
 3191 0020 7B60     		str	r3, [r7, #4]
2115:FreeRTOS/Source/tasks.c **** 			xTaskResumeAll();
 3192              		.loc 1 2115 0
 3193 0022 FFF7FEFF 		bl	xTaskResumeAll
2116:FreeRTOS/Source/tasks.c **** 
2117:FreeRTOS/Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 3194              		.loc 1 2117 0
 3195 0026 7B68     		ldr	r3, [r7, #4]
 3196 0028 002B     		cmp	r3, #0
 3197 002a 19D1     		bne	.L211
 3198              	.LBB9:
2118:FreeRTOS/Source/tasks.c **** 			{
2119:FreeRTOS/Source/tasks.c **** 				tskTCB *pxTCB;
2120:FreeRTOS/Source/tasks.c **** 
2121:FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
 3199              		.loc 1 2121 0
 3200 002c FFF7FEFF 		bl	vPortEnterCritical
2122:FreeRTOS/Source/tasks.c **** 				{
2123:FreeRTOS/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 3201              		.loc 1 2123 0
 3202 0030 0E4B     		ldr	r3, .L213+4
 3203 0032 DB68     		ldr	r3, [r3, #12]
 3204 0034 DB68     		ldr	r3, [r3, #12]
 3205 0036 3B60     		str	r3, [r7]
2124:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 3206              		.loc 1 2124 0
 3207 0038 3B68     		ldr	r3, [r7]
 3208 003a 0433     		adds	r3, r3, #4
 3209 003c 1846     		mov	r0, r3
 3210 003e FFF7FEFF 		bl	vListRemove
2125:FreeRTOS/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
 3211              		.loc 1 2125 0
 3212 0042 0B4B     		ldr	r3, .L213+8
 3213 0044 1B68     		ldr	r3, [r3]
 3214 0046 5A1E     		subs	r2, r3, #1
 3215 0048 094B     		ldr	r3, .L213+8
 3216 004a 1A60     		str	r2, [r3]
2126:FreeRTOS/Source/tasks.c **** 					--uxTasksDeleted;
 3217              		.loc 1 2126 0
 3218 004c 064B     		ldr	r3, .L213
 3219 004e 1B68     		ldr	r3, [r3]
 3220 0050 5A1E     		subs	r2, r3, #1
 3221 0052 054B     		ldr	r3, .L213
 3222 0054 1A60     		str	r2, [r3]
2127:FreeRTOS/Source/tasks.c **** 				}
2128:FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
 3223              		.loc 1 2128 0
 3224 0056 FFF7FEFF 		bl	vPortExitCritical
2129:FreeRTOS/Source/tasks.c **** 
2130:FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
 3225              		.loc 1 2130 0
 3226 005a 3868     		ldr	r0, [r7]
 3227 005c FFF7FEFF 		bl	prvDeleteTCB
 3228              	.L211:
 3229              	.LBE9:
 3230              	.LBE8:
2131:FreeRTOS/Source/tasks.c **** 			}
2132:FreeRTOS/Source/tasks.c **** 		}
2133:FreeRTOS/Source/tasks.c **** 	}
2134:FreeRTOS/Source/tasks.c **** 	#endif
2135:FreeRTOS/Source/tasks.c **** }
 3231              		.loc 1 2135 0
 3232 0060 0837     		adds	r7, r7, #8
 3233 0062 BD46     		mov	sp, r7
 3234              		@ sp needed
 3235 0064 80BD     		pop	{r7, pc}
 3236              	.L214:
 3237 0066 00BF     		.align	2
 3238              	.L213:
 3239 0068 00000000 		.word	uxTasksDeleted
 3240 006c 00000000 		.word	xTasksWaitingTermination
 3241 0070 00000000 		.word	uxCurrentNumberOfTasks
 3242              		.cfi_endproc
 3243              	.LFE142:
 3245              		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 3246              		.align	2
 3247              		.thumb
 3248              		.thumb_func
 3250              	prvAddCurrentTaskToDelayedList:
 3251              	.LFB143:
2136:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2137:FreeRTOS/Source/tasks.c **** 
2138:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2139:FreeRTOS/Source/tasks.c **** {
 3252              		.loc 1 2139 0
 3253              		.cfi_startproc
 3254              		@ args = 0, pretend = 0, frame = 8
 3255              		@ frame_needed = 1, uses_anonymous_args = 0
 3256 0000 80B5     		push	{r7, lr}
 3257              	.LCFI94:
 3258              		.cfi_def_cfa_offset 8
 3259              		.cfi_offset 7, -8
 3260              		.cfi_offset 14, -4
 3261 0002 82B0     		sub	sp, sp, #8
 3262              	.LCFI95:
 3263              		.cfi_def_cfa_offset 16
 3264 0004 00AF     		add	r7, sp, #0
 3265              	.LCFI96:
 3266              		.cfi_def_cfa_register 7
 3267 0006 7860     		str	r0, [r7, #4]
2140:FreeRTOS/Source/tasks.c **** 	/* The list item will be inserted in wake time order. */
2141:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 3268              		.loc 1 2141 0
 3269 0008 134B     		ldr	r3, .L218
 3270 000a 1B68     		ldr	r3, [r3]
 3271 000c 7A68     		ldr	r2, [r7, #4]
 3272 000e 5A60     		str	r2, [r3, #4]
2142:FreeRTOS/Source/tasks.c **** 
2143:FreeRTOS/Source/tasks.c **** 	if( xTimeToWake < xTickCount )
 3273              		.loc 1 2143 0
 3274 0010 124B     		ldr	r3, .L218+4
 3275 0012 1B68     		ldr	r3, [r3]
 3276 0014 7A68     		ldr	r2, [r7, #4]
 3277 0016 9A42     		cmp	r2, r3
 3278 0018 09D2     		bcs	.L216
2144:FreeRTOS/Source/tasks.c **** 	{
2145:FreeRTOS/Source/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2146:FreeRTOS/Source/tasks.c **** 		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericList
 3279              		.loc 1 2146 0
 3280 001a 114B     		ldr	r3, .L218+8
 3281 001c 1A68     		ldr	r2, [r3]
 3282 001e 0E4B     		ldr	r3, .L218
 3283 0020 1B68     		ldr	r3, [r3]
 3284 0022 0433     		adds	r3, r3, #4
 3285 0024 1046     		mov	r0, r2
 3286 0026 1946     		mov	r1, r3
 3287 0028 FFF7FEFF 		bl	vListInsert
 3288 002c 10E0     		b	.L215
 3289              	.L216:
2147:FreeRTOS/Source/tasks.c **** 	}
2148:FreeRTOS/Source/tasks.c **** 	else
2149:FreeRTOS/Source/tasks.c **** 	{
2150:FreeRTOS/Source/tasks.c **** 		/* The wake time has not overflowed, so we can use the current block list. */
2151:FreeRTOS/Source/tasks.c **** 		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) )
 3290              		.loc 1 2151 0
 3291 002e 0D4B     		ldr	r3, .L218+12
 3292 0030 1A68     		ldr	r2, [r3]
 3293 0032 094B     		ldr	r3, .L218
 3294 0034 1B68     		ldr	r3, [r3]
 3295 0036 0433     		adds	r3, r3, #4
 3296 0038 1046     		mov	r0, r2
 3297 003a 1946     		mov	r1, r3
 3298 003c FFF7FEFF 		bl	vListInsert
2152:FreeRTOS/Source/tasks.c **** 
2153:FreeRTOS/Source/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2154:FreeRTOS/Source/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2155:FreeRTOS/Source/tasks.c **** 		too. */
2156:FreeRTOS/Source/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 3299              		.loc 1 2156 0
 3300 0040 094B     		ldr	r3, .L218+16
 3301 0042 1B68     		ldr	r3, [r3]
 3302 0044 7A68     		ldr	r2, [r7, #4]
 3303 0046 9A42     		cmp	r2, r3
 3304 0048 02D2     		bcs	.L215
2157:FreeRTOS/Source/tasks.c **** 		{
2158:FreeRTOS/Source/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 3305              		.loc 1 2158 0
 3306 004a 074B     		ldr	r3, .L218+16
 3307 004c 7A68     		ldr	r2, [r7, #4]
 3308 004e 1A60     		str	r2, [r3]
 3309              	.L215:
2159:FreeRTOS/Source/tasks.c **** 		}
2160:FreeRTOS/Source/tasks.c **** 	}
2161:FreeRTOS/Source/tasks.c **** }
 3310              		.loc 1 2161 0
 3311 0050 0837     		adds	r7, r7, #8
 3312 0052 BD46     		mov	sp, r7
 3313              		@ sp needed
 3314 0054 80BD     		pop	{r7, pc}
 3315              	.L219:
 3316 0056 00BF     		.align	2
 3317              	.L218:
 3318 0058 00000000 		.word	pxCurrentTCB
 3319 005c 00000000 		.word	xTickCount
 3320 0060 00000000 		.word	pxOverflowDelayedTaskList
 3321 0064 00000000 		.word	pxDelayedTaskList
 3322 0068 00000000 		.word	xNextTaskUnblockTime
 3323              		.cfi_endproc
 3324              	.LFE143:
 3326              		.section	.text.prvAllocateTCBAndStack,"ax",%progbits
 3327              		.align	2
 3328              		.thumb
 3329              		.thumb_func
 3331              	prvAllocateTCBAndStack:
 3332              	.LFB144:
2162:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2163:FreeRTOS/Source/tasks.c **** 
2164:FreeRTOS/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2165:FreeRTOS/Source/tasks.c **** {
 3333              		.loc 1 2165 0
 3334              		.cfi_startproc
 3335              		@ args = 0, pretend = 0, frame = 16
 3336              		@ frame_needed = 1, uses_anonymous_args = 0
 3337 0000 80B5     		push	{r7, lr}
 3338              	.LCFI97:
 3339              		.cfi_def_cfa_offset 8
 3340              		.cfi_offset 7, -8
 3341              		.cfi_offset 14, -4
 3342 0002 84B0     		sub	sp, sp, #16
 3343              	.LCFI98:
 3344              		.cfi_def_cfa_offset 24
 3345 0004 00AF     		add	r7, sp, #0
 3346              	.LCFI99:
 3347              		.cfi_def_cfa_register 7
 3348 0006 0346     		mov	r3, r0
 3349 0008 3960     		str	r1, [r7]
 3350 000a FB80     		strh	r3, [r7, #6]	@ movhi
2166:FreeRTOS/Source/tasks.c **** tskTCB *pxNewTCB;
2167:FreeRTOS/Source/tasks.c **** 
2168:FreeRTOS/Source/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2169:FreeRTOS/Source/tasks.c **** 	the implementation of the port malloc function. */
2170:FreeRTOS/Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 3351              		.loc 1 2170 0
 3352 000c 5020     		movs	r0, #80
 3353 000e FFF7FEFF 		bl	malloc
 3354 0012 0346     		mov	r3, r0
 3355 0014 FB60     		str	r3, [r7, #12]
2171:FreeRTOS/Source/tasks.c **** 
2172:FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 3356              		.loc 1 2172 0
 3357 0016 FB68     		ldr	r3, [r7, #12]
 3358 0018 002B     		cmp	r3, #0
 3359 001a 1FD0     		beq	.L221
2173:FreeRTOS/Source/tasks.c **** 	{
2174:FreeRTOS/Source/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2175:FreeRTOS/Source/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2176:FreeRTOS/Source/tasks.c **** 		be deleted later if required. */
2177:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 3360              		.loc 1 2177 0
 3361 001c 3B68     		ldr	r3, [r7]
 3362 001e 002B     		cmp	r3, #0
 3363 0020 06D1     		bne	.L222
 3364              		.loc 1 2177 0 is_stmt 0 discriminator 1
 3365 0022 FB88     		ldrh	r3, [r7, #6]
 3366 0024 9B00     		lsls	r3, r3, #2
 3367 0026 1846     		mov	r0, r3
 3368 0028 FFF7FEFF 		bl	malloc
 3369 002c 0346     		mov	r3, r0
 3370 002e 00E0     		b	.L223
 3371              	.L222:
 3372              		.loc 1 2177 0 discriminator 2
 3373 0030 3B68     		ldr	r3, [r7]
 3374              	.L223:
 3375              		.loc 1 2177 0 discriminator 3
 3376 0032 FA68     		ldr	r2, [r7, #12]
 3377 0034 1363     		str	r3, [r2, #48]
2178:FreeRTOS/Source/tasks.c **** 
2179:FreeRTOS/Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 3378              		.loc 1 2179 0 is_stmt 1 discriminator 3
 3379 0036 FB68     		ldr	r3, [r7, #12]
 3380 0038 1B6B     		ldr	r3, [r3, #48]
 3381 003a 002B     		cmp	r3, #0
 3382 003c 05D1     		bne	.L224
2180:FreeRTOS/Source/tasks.c **** 		{
2181:FreeRTOS/Source/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2182:FreeRTOS/Source/tasks.c **** 			vPortFree( pxNewTCB );
 3383              		.loc 1 2182 0
 3384 003e F868     		ldr	r0, [r7, #12]
 3385 0040 FFF7FEFF 		bl	free
2183:FreeRTOS/Source/tasks.c **** 			pxNewTCB = NULL;
 3386              		.loc 1 2183 0
 3387 0044 0023     		movs	r3, #0
 3388 0046 FB60     		str	r3, [r7, #12]
 3389 0048 08E0     		b	.L221
 3390              	.L224:
2184:FreeRTOS/Source/tasks.c **** 		}
2185:FreeRTOS/Source/tasks.c **** 		else
2186:FreeRTOS/Source/tasks.c **** 		{
2187:FreeRTOS/Source/tasks.c **** 			/* Just to help debugging. */
2188:FreeRTOS/Source/tasks.c **** 			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTA
 3391              		.loc 1 2188 0
 3392 004a FB68     		ldr	r3, [r7, #12]
 3393 004c 1A6B     		ldr	r2, [r3, #48]
 3394 004e FB88     		ldrh	r3, [r7, #6]
 3395 0050 9B00     		lsls	r3, r3, #2
 3396 0052 1046     		mov	r0, r2
 3397 0054 A521     		movs	r1, #165
 3398 0056 1A46     		mov	r2, r3
 3399 0058 FFF7FEFF 		bl	memset
 3400              	.L221:
2189:FreeRTOS/Source/tasks.c **** 		}
2190:FreeRTOS/Source/tasks.c **** 	}
2191:FreeRTOS/Source/tasks.c **** 
2192:FreeRTOS/Source/tasks.c **** 	return pxNewTCB;
 3401              		.loc 1 2192 0
 3402 005c FB68     		ldr	r3, [r7, #12]
2193:FreeRTOS/Source/tasks.c **** }
 3403              		.loc 1 2193 0
 3404 005e 1846     		mov	r0, r3
 3405 0060 1037     		adds	r7, r7, #16
 3406 0062 BD46     		mov	sp, r7
 3407              		@ sp needed
 3408 0064 80BD     		pop	{r7, pc}
 3409              		.cfi_endproc
 3410              	.LFE144:
 3412 0066 00BF     		.section	.rodata
 3413 000b 00       		.align	2
 3414              	.LC2:
 3415 000c 25752020 		.ascii	"%u  %c  %-16s          0   0%%  %5u\015\012\000"
 3415      25632020 
 3415      252D3136 
 3415      73202020 
 3415      20202020 
 3416 0032 0000     		.align	2
 3417              	.LC3:
 3418 0034 25752020 		.ascii	"%u  %c  %-16s %10u %3u%%  %5u\015\012\000"
 3418      25632020 
 3418      252D3136 
 3418      73202531 
 3418      30752025 
 3419              		.align	2
 3420              	.LC4:
 3421 0054 25752020 		.ascii	"%u  %c  %-16s %10u  <1%%  %5u\015\012\000"
 3421      25632020 
 3421      252D3136 
 3421      73202531 
 3421      30752020 
 3422              		.section	.text.prvGenerateRunTimeStatsForTasksInList,"ax",%progbits
 3423              		.align	2
 3424              		.thumb
 3425              		.thumb_func
 3427              	prvGenerateRunTimeStatsForTasksInList:
 3428              	.LFB145:
2194:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2195:FreeRTOS/Source/tasks.c **** 
2196:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2197:FreeRTOS/Source/tasks.c **** 
2198:FreeRTOS/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2199:FreeRTOS/Source/tasks.c **** 	{
2200:FreeRTOS/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2201:FreeRTOS/Source/tasks.c **** 	unsigned short usStackRemaining;
2202:FreeRTOS/Source/tasks.c **** 
2203:FreeRTOS/Source/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2204:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2205:FreeRTOS/Source/tasks.c **** 		do
2206:FreeRTOS/Source/tasks.c **** 		{
2207:FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2208:FreeRTOS/Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2209:FreeRTOS/Source/tasks.c **** 			{
2210:FreeRTOS/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2211:FreeRTOS/Source/tasks.c **** 			}
2212:FreeRTOS/Source/tasks.c **** 			#else
2213:FreeRTOS/Source/tasks.c **** 			{
2214:FreeRTOS/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
2215:FreeRTOS/Source/tasks.c **** 			}
2216:FreeRTOS/Source/tasks.c **** 			#endif			
2217:FreeRTOS/Source/tasks.c **** 			
2218:FreeRTOS/Source/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
2219:FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
2220:FreeRTOS/Source/tasks.c **** 
2221:FreeRTOS/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2222:FreeRTOS/Source/tasks.c **** 	}
2223:FreeRTOS/Source/tasks.c **** 
2224:FreeRTOS/Source/tasks.c **** #endif
2225:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2226:FreeRTOS/Source/tasks.c **** 
2227:FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2228:FreeRTOS/Source/tasks.c **** 
2229:FreeRTOS/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2230:FreeRTOS/Source/tasks.c **** 	{
 3429              		.loc 1 2230 0
 3430              		.cfi_startproc
 3431              		@ args = 0, pretend = 0, frame = 40
 3432              		@ frame_needed = 1, uses_anonymous_args = 0
 3433 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 3434              	.LCFI100:
 3435              		.cfi_def_cfa_offset 24
 3436              		.cfi_offset 4, -24
 3437              		.cfi_offset 5, -20
 3438              		.cfi_offset 6, -16
 3439              		.cfi_offset 7, -12
 3440              		.cfi_offset 8, -8
 3441              		.cfi_offset 14, -4
 3442 0004 8EB0     		sub	sp, sp, #56
 3443              	.LCFI101:
 3444              		.cfi_def_cfa_offset 80
 3445 0006 04AF     		add	r7, sp, #16
 3446              	.LCFI102:
 3447              		.cfi_def_cfa 7, 64
 3448 0008 F860     		str	r0, [r7, #12]
 3449 000a B960     		str	r1, [r7, #8]
 3450 000c 7A60     		str	r2, [r7, #4]
 3451 000e FB70     		strb	r3, [r7, #3]
 3452              	.LBB10:
2231:FreeRTOS/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2232:FreeRTOS/Source/tasks.c **** 	unsigned long ulStatsAsPercentage;
2233:FreeRTOS/Source/tasks.c **** 
2234:FreeRTOS/Source/tasks.c **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2235:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 3453              		.loc 1 2235 0
 3454 0010 BB68     		ldr	r3, [r7, #8]
 3455 0012 7B62     		str	r3, [r7, #36]
 3456 0014 7B6A     		ldr	r3, [r7, #36]
 3457 0016 5B68     		ldr	r3, [r3, #4]
 3458 0018 5A68     		ldr	r2, [r3, #4]
 3459 001a 7B6A     		ldr	r3, [r7, #36]
 3460 001c 5A60     		str	r2, [r3, #4]
 3461 001e 7B6A     		ldr	r3, [r7, #36]
 3462 0020 5A68     		ldr	r2, [r3, #4]
 3463 0022 7B6A     		ldr	r3, [r7, #36]
 3464 0024 0833     		adds	r3, r3, #8
 3465 0026 9A42     		cmp	r2, r3
 3466 0028 04D1     		bne	.L227
 3467              		.loc 1 2235 0 is_stmt 0 discriminator 1
 3468 002a 7B6A     		ldr	r3, [r7, #36]
 3469 002c 5B68     		ldr	r3, [r3, #4]
 3470 002e 5A68     		ldr	r2, [r3, #4]
 3471 0030 7B6A     		ldr	r3, [r7, #36]
 3472 0032 5A60     		str	r2, [r3, #4]
 3473              	.L227:
 3474              		.loc 1 2235 0 discriminator 2
 3475 0034 7B6A     		ldr	r3, [r7, #36]
 3476 0036 5B68     		ldr	r3, [r3, #4]
 3477 0038 DB68     		ldr	r3, [r3, #12]
 3478 003a 3B62     		str	r3, [r7, #32]
 3479              	.L233:
 3480              	.LBE10:
 3481              	.LBB11:
2236:FreeRTOS/Source/tasks.c **** 		do
2237:FreeRTOS/Source/tasks.c **** 		{
2238:FreeRTOS/Source/tasks.c **** 			/* Get next TCB in from the list. */
2239:FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 3482              		.loc 1 2239 0 is_stmt 1
 3483 003c BB68     		ldr	r3, [r7, #8]
 3484 003e FB61     		str	r3, [r7, #28]
 3485 0040 FB69     		ldr	r3, [r7, #28]
 3486 0042 5B68     		ldr	r3, [r3, #4]
 3487 0044 5A68     		ldr	r2, [r3, #4]
 3488 0046 FB69     		ldr	r3, [r7, #28]
 3489 0048 5A60     		str	r2, [r3, #4]
 3490 004a FB69     		ldr	r3, [r7, #28]
 3491 004c 5A68     		ldr	r2, [r3, #4]
 3492 004e FB69     		ldr	r3, [r7, #28]
 3493 0050 0833     		adds	r3, r3, #8
 3494 0052 9A42     		cmp	r2, r3
 3495 0054 04D1     		bne	.L228
 3496              		.loc 1 2239 0 is_stmt 0 discriminator 1
 3497 0056 FB69     		ldr	r3, [r7, #28]
 3498 0058 5B68     		ldr	r3, [r3, #4]
 3499 005a 5A68     		ldr	r2, [r3, #4]
 3500 005c FB69     		ldr	r3, [r7, #28]
 3501 005e 5A60     		str	r2, [r3, #4]
 3502              	.L228:
 3503              		.loc 1 2239 0 discriminator 2
 3504 0060 FB69     		ldr	r3, [r7, #28]
 3505 0062 5B68     		ldr	r3, [r3, #4]
 3506 0064 DB68     		ldr	r3, [r3, #12]
 3507 0066 BB61     		str	r3, [r7, #24]
 3508              	.LBE11:
2240:FreeRTOS/Source/tasks.c **** 
2241:FreeRTOS/Source/tasks.c **** 			/* Divide by zero check. */
2242:FreeRTOS/Source/tasks.c **** 			if( ulTotalRunTime > 0UL )
 3509              		.loc 1 2242 0 is_stmt 1 discriminator 2
 3510 0068 7B68     		ldr	r3, [r7, #4]
 3511 006a 002B     		cmp	r3, #0
 3512 006c 5BD0     		beq	.L229
2243:FreeRTOS/Source/tasks.c **** 			{
2244:FreeRTOS/Source/tasks.c **** 				/* Has the task run at all? */
2245:FreeRTOS/Source/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0UL )
 3513              		.loc 1 2245 0
 3514 006e BB69     		ldr	r3, [r7, #24]
 3515 0070 DB6C     		ldr	r3, [r3, #76]
 3516 0072 002B     		cmp	r3, #0
 3517 0074 15D1     		bne	.L230
2246:FreeRTOS/Source/tasks.c **** 				{
2247:FreeRTOS/Source/tasks.c **** 					/* The task has used no CPU time at all. */
2248:FreeRTOS/Source/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%u  %c  %-16s          0   0%%  %5u\r\n", (unsigned int) p
 3518              		.loc 1 2248 0
 3519 0076 BB69     		ldr	r3, [r7, #24]
 3520 0078 DD6A     		ldr	r5, [r3, #44]
 3521 007a 97F90340 		ldrsb	r4, [r7, #3]
 3522 007e BB69     		ldr	r3, [r7, #24]
 3523 0080 03F13406 		add	r6, r3, #52
 3524 0084 BB69     		ldr	r3, [r7, #24]
 3525 0086 1B6B     		ldr	r3, [r3, #48]
 3526 0088 1846     		mov	r0, r3
 3527 008a FFF7FEFF 		bl	usTaskCheckFreeStackSpace
 3528 008e 0346     		mov	r3, r0
 3529 0090 0096     		str	r6, [sp]
 3530 0092 0193     		str	r3, [sp, #4]
 3531 0094 2848     		ldr	r0, .L234
 3532 0096 2949     		ldr	r1, .L234+4
 3533 0098 2A46     		mov	r2, r5
 3534 009a 2346     		mov	r3, r4
 3535 009c FFF7FEFF 		bl	sprintf
 3536 00a0 3DE0     		b	.L231
 3537              	.L230:
2249:FreeRTOS/Source/tasks.c **** 				}
2250:FreeRTOS/Source/tasks.c **** 				else
2251:FreeRTOS/Source/tasks.c **** 				{
2252:FreeRTOS/Source/tasks.c **** 					/* What percentage of the total run time has the task used?
2253:FreeRTOS/Source/tasks.c **** 					This will always be rounded down to the nearest integer.
2254:FreeRTOS/Source/tasks.c **** 					ulTotalRunTime has already been divided by 100. */
2255:FreeRTOS/Source/tasks.c **** 					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
 3538              		.loc 1 2255 0
 3539 00a2 BB69     		ldr	r3, [r7, #24]
 3540 00a4 DA6C     		ldr	r2, [r3, #76]
 3541 00a6 7B68     		ldr	r3, [r7, #4]
 3542 00a8 B2FBF3F3 		udiv	r3, r2, r3
 3543 00ac 7B61     		str	r3, [r7, #20]
2256:FreeRTOS/Source/tasks.c **** 
2257:FreeRTOS/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
 3544              		.loc 1 2257 0
 3545 00ae 7B69     		ldr	r3, [r7, #20]
 3546 00b0 002B     		cmp	r3, #0
 3547 00b2 1BD0     		beq	.L232
2258:FreeRTOS/Source/tasks.c **** 					{
2259:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2260:FreeRTOS/Source/tasks.c **** 						{
2261:FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxNextTCB->pcTaskName, pxNextTC
2262:FreeRTOS/Source/tasks.c **** 						}
2263:FreeRTOS/Source/tasks.c **** 						#else
2264:FreeRTOS/Source/tasks.c **** 						{
2265:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2266:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
2267:FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%u  %c  %-16s %10u %3u%%  %5u\r\n", (unsigned int) pxNex
 3548              		.loc 1 2267 0
 3549 00b4 BB69     		ldr	r3, [r7, #24]
 3550 00b6 DD6A     		ldr	r5, [r3, #44]
 3551 00b8 97F90340 		ldrsb	r4, [r7, #3]
 3552 00bc BB69     		ldr	r3, [r7, #24]
 3553 00be 03F13408 		add	r8, r3, #52
 3554 00c2 BB69     		ldr	r3, [r7, #24]
 3555 00c4 DE6C     		ldr	r6, [r3, #76]
 3556 00c6 BB69     		ldr	r3, [r7, #24]
 3557 00c8 1B6B     		ldr	r3, [r3, #48]
 3558 00ca 1846     		mov	r0, r3
 3559 00cc FFF7FEFF 		bl	usTaskCheckFreeStackSpace
 3560 00d0 0346     		mov	r3, r0
 3561 00d2 CDF80080 		str	r8, [sp]
 3562 00d6 0196     		str	r6, [sp, #4]
 3563 00d8 7A69     		ldr	r2, [r7, #20]
 3564 00da 0292     		str	r2, [sp, #8]
 3565 00dc 0393     		str	r3, [sp, #12]
 3566 00de 1648     		ldr	r0, .L234
 3567 00e0 1749     		ldr	r1, .L234+8
 3568 00e2 2A46     		mov	r2, r5
 3569 00e4 2346     		mov	r3, r4
 3570 00e6 FFF7FEFF 		bl	sprintf
 3571 00ea 18E0     		b	.L231
 3572              	.L232:
2268:FreeRTOS/Source/tasks.c **** 						}
2269:FreeRTOS/Source/tasks.c **** 						#endif
2270:FreeRTOS/Source/tasks.c **** 					}
2271:FreeRTOS/Source/tasks.c **** 					else
2272:FreeRTOS/Source/tasks.c **** 					{
2273:FreeRTOS/Source/tasks.c **** 						/* If the percentage is zero here then the task has
2274:FreeRTOS/Source/tasks.c **** 						consumed less than 1% of the total run time. */
2275:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2276:FreeRTOS/Source/tasks.c **** 						{
2277:FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxNextTCB->pcTaskName, pxNextTCB
2278:FreeRTOS/Source/tasks.c **** 						}
2279:FreeRTOS/Source/tasks.c **** 						#else
2280:FreeRTOS/Source/tasks.c **** 						{
2281:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2282:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
2283:FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%u  %c  %-16s %10u  <1%%  %5u\r\n",  (unsigned int) pxNe
 3573              		.loc 1 2283 0
 3574 00ec BB69     		ldr	r3, [r7, #24]
 3575 00ee DD6A     		ldr	r5, [r3, #44]
 3576 00f0 97F90340 		ldrsb	r4, [r7, #3]
 3577 00f4 BB69     		ldr	r3, [r7, #24]
 3578 00f6 03F13408 		add	r8, r3, #52
 3579 00fa BB69     		ldr	r3, [r7, #24]
 3580 00fc DE6C     		ldr	r6, [r3, #76]
 3581 00fe BB69     		ldr	r3, [r7, #24]
 3582 0100 1B6B     		ldr	r3, [r3, #48]
 3583 0102 1846     		mov	r0, r3
 3584 0104 FFF7FEFF 		bl	usTaskCheckFreeStackSpace
 3585 0108 0346     		mov	r3, r0
 3586 010a CDF80080 		str	r8, [sp]
 3587 010e 0196     		str	r6, [sp, #4]
 3588 0110 0293     		str	r3, [sp, #8]
 3589 0112 0948     		ldr	r0, .L234
 3590 0114 0B49     		ldr	r1, .L234+12
 3591 0116 2A46     		mov	r2, r5
 3592 0118 2346     		mov	r3, r4
 3593 011a FFF7FEFF 		bl	sprintf
 3594              	.L231:
2284:FreeRTOS/Source/tasks.c **** 						}
2285:FreeRTOS/Source/tasks.c **** 						#endif
2286:FreeRTOS/Source/tasks.c **** 					}
2287:FreeRTOS/Source/tasks.c **** 				}
2288:FreeRTOS/Source/tasks.c **** 
2289:FreeRTOS/Source/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
 3595              		.loc 1 2289 0
 3596 011e F868     		ldr	r0, [r7, #12]
 3597 0120 0549     		ldr	r1, .L234
 3598 0122 FFF7FEFF 		bl	strcat
 3599              	.L229:
2290:FreeRTOS/Source/tasks.c **** 			}
2291:FreeRTOS/Source/tasks.c **** 
2292:FreeRTOS/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
 3600              		.loc 1 2292 0
 3601 0126 BA69     		ldr	r2, [r7, #24]
 3602 0128 3B6A     		ldr	r3, [r7, #32]
 3603 012a 9A42     		cmp	r2, r3
 3604 012c 86D1     		bne	.L233
2293:FreeRTOS/Source/tasks.c **** 	}
 3605              		.loc 1 2293 0
 3606 012e 2837     		adds	r7, r7, #40
 3607 0130 BD46     		mov	sp, r7
 3608              		@ sp needed
 3609 0132 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 3610              	.L235:
 3611 0136 00BF     		.align	2
 3612              	.L234:
 3613 0138 00000000 		.word	pcStatsString
 3614 013c 0C000000 		.word	.LC2
 3615 0140 34000000 		.word	.LC3
 3616 0144 54000000 		.word	.LC4
 3617              		.cfi_endproc
 3618              	.LFE145:
 3620              		.section	.text.usTaskCheckFreeStackSpace,"ax",%progbits
 3621              		.align	2
 3622              		.thumb
 3623              		.thumb_func
 3625              	usTaskCheckFreeStackSpace:
 3626              	.LFB146:
2294:FreeRTOS/Source/tasks.c **** 
2295:FreeRTOS/Source/tasks.c **** #endif
2296:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2297:FreeRTOS/Source/tasks.c **** 
2298:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2299:FreeRTOS/Source/tasks.c **** 
2300:FreeRTOS/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2301:FreeRTOS/Source/tasks.c **** 	{
 3627              		.loc 1 2301 0
 3628              		.cfi_startproc
 3629              		@ args = 0, pretend = 0, frame = 8
 3630              		@ frame_needed = 1, uses_anonymous_args = 0
 3631              		@ link register save eliminated.
 3632 0000 90B4     		push	{r4, r7}
 3633              	.LCFI103:
 3634              		.cfi_def_cfa_offset 8
 3635              		.cfi_offset 4, -8
 3636              		.cfi_offset 7, -4
 3637 0002 82B0     		sub	sp, sp, #8
 3638              	.LCFI104:
 3639              		.cfi_def_cfa_offset 16
 3640 0004 00AF     		add	r7, sp, #0
 3641              	.LCFI105:
 3642              		.cfi_def_cfa_register 7
 3643 0006 7860     		str	r0, [r7, #4]
2302:FreeRTOS/Source/tasks.c **** 	register unsigned short usCount = 0U;
 3644              		.loc 1 2302 0
 3645 0008 0024     		movs	r4, #0
2303:FreeRTOS/Source/tasks.c **** 
2304:FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 3646              		.loc 1 2304 0
 3647 000a 05E0     		b	.L237
 3648              	.L238:
2305:FreeRTOS/Source/tasks.c **** 		{
2306:FreeRTOS/Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
 3649              		.loc 1 2306 0
 3650 000c 7B68     		ldr	r3, [r7, #4]
 3651 000e 0133     		adds	r3, r3, #1
 3652 0010 7B60     		str	r3, [r7, #4]
2307:FreeRTOS/Source/tasks.c **** 			usCount++;
 3653              		.loc 1 2307 0
 3654 0012 2346     		mov	r3, r4
 3655 0014 0133     		adds	r3, r3, #1
 3656 0016 9CB2     		uxth	r4, r3
 3657              	.L237:
2304:FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 3658              		.loc 1 2304 0 discriminator 1
 3659 0018 7B68     		ldr	r3, [r7, #4]
 3660 001a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3661 001c A52B     		cmp	r3, #165
 3662 001e F5D0     		beq	.L238
2308:FreeRTOS/Source/tasks.c **** 		}
2309:FreeRTOS/Source/tasks.c **** 
2310:FreeRTOS/Source/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
 3663              		.loc 1 2310 0
 3664 0020 A308     		lsrs	r3, r4, #2
 3665 0022 9CB2     		uxth	r4, r3
2311:FreeRTOS/Source/tasks.c **** 
2312:FreeRTOS/Source/tasks.c **** 		return usCount;
 3666              		.loc 1 2312 0
 3667 0024 2346     		mov	r3, r4
2313:FreeRTOS/Source/tasks.c **** 	}
 3668              		.loc 1 2313 0
 3669 0026 1846     		mov	r0, r3
 3670 0028 0837     		adds	r7, r7, #8
 3671 002a BD46     		mov	sp, r7
 3672              		@ sp needed
 3673 002c 90BC     		pop	{r4, r7}
 3674 002e 7047     		bx	lr
 3675              		.cfi_endproc
 3676              	.LFE146:
 3678              		.section	.text.uxTaskGetStackHighWaterMark,"ax",%progbits
 3679              		.align	2
 3680              		.global	uxTaskGetStackHighWaterMark
 3681              		.thumb
 3682              		.thumb_func
 3684              	uxTaskGetStackHighWaterMark:
 3685              	.LFB147:
2314:FreeRTOS/Source/tasks.c **** 
2315:FreeRTOS/Source/tasks.c **** #endif
2316:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2317:FreeRTOS/Source/tasks.c **** 
2318:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2319:FreeRTOS/Source/tasks.c **** 
2320:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2321:FreeRTOS/Source/tasks.c **** 	{
 3686              		.loc 1 2321 0
 3687              		.cfi_startproc
 3688              		@ args = 0, pretend = 0, frame = 24
 3689              		@ frame_needed = 1, uses_anonymous_args = 0
 3690 0000 80B5     		push	{r7, lr}
 3691              	.LCFI106:
 3692              		.cfi_def_cfa_offset 8
 3693              		.cfi_offset 7, -8
 3694              		.cfi_offset 14, -4
 3695 0002 86B0     		sub	sp, sp, #24
 3696              	.LCFI107:
 3697              		.cfi_def_cfa_offset 32
 3698 0004 00AF     		add	r7, sp, #0
 3699              	.LCFI108:
 3700              		.cfi_def_cfa_register 7
 3701 0006 7860     		str	r0, [r7, #4]
2322:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
2323:FreeRTOS/Source/tasks.c **** 	unsigned char *pcEndOfStack;
2324:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2325:FreeRTOS/Source/tasks.c **** 
2326:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 3702              		.loc 1 2326 0
 3703 0008 7B68     		ldr	r3, [r7, #4]
 3704 000a 002B     		cmp	r3, #0
 3705 000c 02D1     		bne	.L241
 3706              		.loc 1 2326 0 is_stmt 0 discriminator 1
 3707 000e 094B     		ldr	r3, .L244
 3708 0010 1B68     		ldr	r3, [r3]
 3709 0012 00E0     		b	.L242
 3710              	.L241:
 3711              		.loc 1 2326 0 discriminator 2
 3712 0014 7B68     		ldr	r3, [r7, #4]
 3713              	.L242:
 3714              		.loc 1 2326 0 discriminator 3
 3715 0016 7B61     		str	r3, [r7, #20]
2327:FreeRTOS/Source/tasks.c **** 
2328:FreeRTOS/Source/tasks.c **** 		#if portSTACK_GROWTH < 0
2329:FreeRTOS/Source/tasks.c **** 		{
2330:FreeRTOS/Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
 3716              		.loc 1 2330 0 is_stmt 1 discriminator 3
 3717 0018 7B69     		ldr	r3, [r7, #20]
 3718 001a 1B6B     		ldr	r3, [r3, #48]
 3719 001c 3B61     		str	r3, [r7, #16]
2331:FreeRTOS/Source/tasks.c **** 		}
2332:FreeRTOS/Source/tasks.c **** 		#else
2333:FreeRTOS/Source/tasks.c **** 		{
2334:FreeRTOS/Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2335:FreeRTOS/Source/tasks.c **** 		}
2336:FreeRTOS/Source/tasks.c **** 		#endif
2337:FreeRTOS/Source/tasks.c **** 
2338:FreeRTOS/Source/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
 3720              		.loc 1 2338 0 discriminator 3
 3721 001e 3869     		ldr	r0, [r7, #16]
 3722 0020 FFF7FEFF 		bl	usTaskCheckFreeStackSpace
 3723 0024 0346     		mov	r3, r0
 3724 0026 FB60     		str	r3, [r7, #12]
2339:FreeRTOS/Source/tasks.c **** 
2340:FreeRTOS/Source/tasks.c **** 		return uxReturn;
 3725              		.loc 1 2340 0 discriminator 3
 3726 0028 FB68     		ldr	r3, [r7, #12]
2341:FreeRTOS/Source/tasks.c **** 	}
 3727              		.loc 1 2341 0 discriminator 3
 3728 002a 1846     		mov	r0, r3
 3729 002c 1837     		adds	r7, r7, #24
 3730 002e BD46     		mov	sp, r7
 3731              		@ sp needed
 3732 0030 80BD     		pop	{r7, pc}
 3733              	.L245:
 3734 0032 00BF     		.align	2
 3735              	.L244:
 3736 0034 00000000 		.word	pxCurrentTCB
 3737              		.cfi_endproc
 3738              	.LFE147:
 3740              		.section	.text.prvDeleteTCB,"ax",%progbits
 3741              		.align	2
 3742              		.thumb
 3743              		.thumb_func
 3745              	prvDeleteTCB:
 3746              	.LFB148:
2342:FreeRTOS/Source/tasks.c **** 
2343:FreeRTOS/Source/tasks.c **** #endif
2344:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2345:FreeRTOS/Source/tasks.c **** 
2346:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
2347:FreeRTOS/Source/tasks.c **** 
2348:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2349:FreeRTOS/Source/tasks.c **** 	{
 3747              		.loc 1 2349 0
 3748              		.cfi_startproc
 3749              		@ args = 0, pretend = 0, frame = 8
 3750              		@ frame_needed = 1, uses_anonymous_args = 0
 3751 0000 80B5     		push	{r7, lr}
 3752              	.LCFI109:
 3753              		.cfi_def_cfa_offset 8
 3754              		.cfi_offset 7, -8
 3755              		.cfi_offset 14, -4
 3756 0002 82B0     		sub	sp, sp, #8
 3757              	.LCFI110:
 3758              		.cfi_def_cfa_offset 16
 3759 0004 00AF     		add	r7, sp, #0
 3760              	.LCFI111:
 3761              		.cfi_def_cfa_register 7
 3762 0006 7860     		str	r0, [r7, #4]
2350:FreeRTOS/Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2351:FreeRTOS/Source/tasks.c **** 		the task to free any memory allocated at the application level. */
2352:FreeRTOS/Source/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
 3763              		.loc 1 2352 0
 3764 0008 7B68     		ldr	r3, [r7, #4]
 3765 000a 1B6B     		ldr	r3, [r3, #48]
 3766 000c 1846     		mov	r0, r3
 3767 000e FFF7FEFF 		bl	free
2353:FreeRTOS/Source/tasks.c **** 		vPortFree( pxTCB );
 3768              		.loc 1 2353 0
 3769 0012 7868     		ldr	r0, [r7, #4]
 3770 0014 FFF7FEFF 		bl	free
2354:FreeRTOS/Source/tasks.c **** 	}
 3771              		.loc 1 2354 0
 3772 0018 0837     		adds	r7, r7, #8
 3773 001a BD46     		mov	sp, r7
 3774              		@ sp needed
 3775 001c 80BD     		pop	{r7, pc}
 3776              		.cfi_endproc
 3777              	.LFE148:
 3779 001e 00BF     		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 3780              		.align	2
 3781              		.global	xTaskGetCurrentTaskHandle
 3782              		.thumb
 3783              		.thumb_func
 3785              	xTaskGetCurrentTaskHandle:
 3786              	.LFB149:
2355:FreeRTOS/Source/tasks.c **** 
2356:FreeRTOS/Source/tasks.c **** #endif
2357:FreeRTOS/Source/tasks.c **** 
2358:FreeRTOS/Source/tasks.c **** 
2359:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2360:FreeRTOS/Source/tasks.c **** 
2361:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2362:FreeRTOS/Source/tasks.c **** 
2363:FreeRTOS/Source/tasks.c **** 	xTaskHandle xTaskGetCurrentTaskHandle( void )
2364:FreeRTOS/Source/tasks.c **** 	{
 3787              		.loc 1 2364 0
 3788              		.cfi_startproc
 3789              		@ args = 0, pretend = 0, frame = 8
 3790              		@ frame_needed = 1, uses_anonymous_args = 0
 3791              		@ link register save eliminated.
 3792 0000 80B4     		push	{r7}
 3793              	.LCFI112:
 3794              		.cfi_def_cfa_offset 4
 3795              		.cfi_offset 7, -4
 3796 0002 83B0     		sub	sp, sp, #12
 3797              	.LCFI113:
 3798              		.cfi_def_cfa_offset 16
 3799 0004 00AF     		add	r7, sp, #0
 3800              	.LCFI114:
 3801              		.cfi_def_cfa_register 7
2365:FreeRTOS/Source/tasks.c **** 	xTaskHandle xReturn;
2366:FreeRTOS/Source/tasks.c **** 
2367:FreeRTOS/Source/tasks.c **** 		/* A critical section is not required as this is not called from
2368:FreeRTOS/Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
2369:FreeRTOS/Source/tasks.c **** 		individual execution thread. */
2370:FreeRTOS/Source/tasks.c **** 		xReturn = pxCurrentTCB;
 3802              		.loc 1 2370 0
 3803 0006 054B     		ldr	r3, .L249
 3804 0008 1B68     		ldr	r3, [r3]
 3805 000a 7B60     		str	r3, [r7, #4]
2371:FreeRTOS/Source/tasks.c **** 
2372:FreeRTOS/Source/tasks.c **** 		return xReturn;
 3806              		.loc 1 2372 0
 3807 000c 7B68     		ldr	r3, [r7, #4]
2373:FreeRTOS/Source/tasks.c **** 	}
 3808              		.loc 1 2373 0
 3809 000e 1846     		mov	r0, r3
 3810 0010 0C37     		adds	r7, r7, #12
 3811 0012 BD46     		mov	sp, r7
 3812              		@ sp needed
 3813 0014 5DF8047B 		ldr	r7, [sp], #4
 3814 0018 7047     		bx	lr
 3815              	.L250:
 3816 001a 00BF     		.align	2
 3817              	.L249:
 3818 001c 00000000 		.word	pxCurrentTCB
 3819              		.cfi_endproc
 3820              	.LFE149:
 3822              		.section	.text.vTaskPriorityInherit,"ax",%progbits
 3823              		.align	2
 3824              		.global	vTaskPriorityInherit
 3825              		.thumb
 3826              		.thumb_func
 3828              	vTaskPriorityInherit:
 3829              	.LFB150:
2374:FreeRTOS/Source/tasks.c **** 
2375:FreeRTOS/Source/tasks.c **** #endif
2376:FreeRTOS/Source/tasks.c **** 
2377:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2378:FreeRTOS/Source/tasks.c **** 
2379:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2380:FreeRTOS/Source/tasks.c **** 
2381:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskGetSchedulerState( void )
2382:FreeRTOS/Source/tasks.c **** 	{
2383:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn;
2384:FreeRTOS/Source/tasks.c **** 
2385:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
2386:FreeRTOS/Source/tasks.c **** 		{
2387:FreeRTOS/Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
2388:FreeRTOS/Source/tasks.c **** 		}
2389:FreeRTOS/Source/tasks.c **** 		else
2390:FreeRTOS/Source/tasks.c **** 		{
2391:FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
2392:FreeRTOS/Source/tasks.c **** 			{
2393:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
2394:FreeRTOS/Source/tasks.c **** 			}
2395:FreeRTOS/Source/tasks.c **** 			else
2396:FreeRTOS/Source/tasks.c **** 			{
2397:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
2398:FreeRTOS/Source/tasks.c **** 			}
2399:FreeRTOS/Source/tasks.c **** 		}
2400:FreeRTOS/Source/tasks.c **** 
2401:FreeRTOS/Source/tasks.c **** 		return xReturn;
2402:FreeRTOS/Source/tasks.c **** 	}
2403:FreeRTOS/Source/tasks.c **** 
2404:FreeRTOS/Source/tasks.c **** #endif
2405:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2406:FreeRTOS/Source/tasks.c **** 
2407:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2408:FreeRTOS/Source/tasks.c **** 
2409:FreeRTOS/Source/tasks.c **** 	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
2410:FreeRTOS/Source/tasks.c **** 	{
 3830              		.loc 1 2410 0
 3831              		.cfi_startproc
 3832              		@ args = 0, pretend = 0, frame = 16
 3833              		@ frame_needed = 1, uses_anonymous_args = 0
 3834 0000 80B5     		push	{r7, lr}
 3835              	.LCFI115:
 3836              		.cfi_def_cfa_offset 8
 3837              		.cfi_offset 7, -8
 3838              		.cfi_offset 14, -4
 3839 0002 84B0     		sub	sp, sp, #16
 3840              	.LCFI116:
 3841              		.cfi_def_cfa_offset 24
 3842 0004 00AF     		add	r7, sp, #0
 3843              	.LCFI117:
 3844              		.cfi_def_cfa_register 7
 3845 0006 7860     		str	r0, [r7, #4]
2411:FreeRTOS/Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3846              		.loc 1 2411 0
 3847 0008 7B68     		ldr	r3, [r7, #4]
 3848 000a FB60     		str	r3, [r7, #12]
2412:FreeRTOS/Source/tasks.c **** 
2413:FreeRTOS/Source/tasks.c **** 		configASSERT( pxMutexHolder );
2414:FreeRTOS/Source/tasks.c **** 
2415:FreeRTOS/Source/tasks.c **** 		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 3849              		.loc 1 2415 0
 3850 000c FB68     		ldr	r3, [r7, #12]
 3851 000e DA6A     		ldr	r2, [r3, #44]
 3852 0010 214B     		ldr	r3, .L255
 3853 0012 1B68     		ldr	r3, [r3]
 3854 0014 DB6A     		ldr	r3, [r3, #44]
 3855 0016 9A42     		cmp	r2, r3
 3856 0018 3AD2     		bcs	.L251
2416:FreeRTOS/Source/tasks.c **** 		{
2417:FreeRTOS/Source/tasks.c **** 			/* Adjust the mutex holder state to account for its new priority. */
2418:FreeRTOS/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxC
 3857              		.loc 1 2418 0
 3858 001a 1F4B     		ldr	r3, .L255
 3859 001c 1B68     		ldr	r3, [r3]
 3860 001e DB6A     		ldr	r3, [r3, #44]
 3861 0020 C3F10502 		rsb	r2, r3, #5
 3862 0024 FB68     		ldr	r3, [r7, #12]
 3863 0026 9A61     		str	r2, [r3, #24]
2419:FreeRTOS/Source/tasks.c **** 
2420:FreeRTOS/Source/tasks.c **** 			/* If the task being modified is in the ready state it will need to
2421:FreeRTOS/Source/tasks.c **** 			be moved in to a new list. */
2422:FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericList
 3864              		.loc 1 2422 0
 3865 0028 FB68     		ldr	r3, [r7, #12]
 3866 002a 5969     		ldr	r1, [r3, #20]
 3867 002c FB68     		ldr	r3, [r7, #12]
 3868 002e DA6A     		ldr	r2, [r3, #44]
 3869 0030 1346     		mov	r3, r2
 3870 0032 9B00     		lsls	r3, r3, #2
 3871 0034 1344     		add	r3, r3, r2
 3872 0036 9B00     		lsls	r3, r3, #2
 3873 0038 184A     		ldr	r2, .L255+4
 3874 003a 1344     		add	r3, r3, r2
 3875 003c 9942     		cmp	r1, r3
 3876 003e 22D1     		bne	.L253
2423:FreeRTOS/Source/tasks.c **** 			{
2424:FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 3877              		.loc 1 2424 0
 3878 0040 FB68     		ldr	r3, [r7, #12]
 3879 0042 0433     		adds	r3, r3, #4
 3880 0044 1846     		mov	r0, r3
 3881 0046 FFF7FEFF 		bl	vListRemove
2425:FreeRTOS/Source/tasks.c **** 
2426:FreeRTOS/Source/tasks.c **** 				/* Inherit the priority before being moved into the new list. */
2427:FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3882              		.loc 1 2427 0
 3883 004a 134B     		ldr	r3, .L255
 3884 004c 1B68     		ldr	r3, [r3]
 3885 004e DA6A     		ldr	r2, [r3, #44]
 3886 0050 FB68     		ldr	r3, [r7, #12]
 3887 0052 DA62     		str	r2, [r3, #44]
2428:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 3888              		.loc 1 2428 0
 3889 0054 FB68     		ldr	r3, [r7, #12]
 3890 0056 DA6A     		ldr	r2, [r3, #44]
 3891 0058 114B     		ldr	r3, .L255+8
 3892 005a 1B68     		ldr	r3, [r3]
 3893 005c 9A42     		cmp	r2, r3
 3894 005e 03D9     		bls	.L254
 3895              		.loc 1 2428 0 is_stmt 0 discriminator 1
 3896 0060 FB68     		ldr	r3, [r7, #12]
 3897 0062 DA6A     		ldr	r2, [r3, #44]
 3898 0064 0E4B     		ldr	r3, .L255+8
 3899 0066 1A60     		str	r2, [r3]
 3900              	.L254:
 3901              		.loc 1 2428 0 discriminator 2
 3902 0068 FB68     		ldr	r3, [r7, #12]
 3903 006a DA6A     		ldr	r2, [r3, #44]
 3904 006c 1346     		mov	r3, r2
 3905 006e 9B00     		lsls	r3, r3, #2
 3906 0070 1344     		add	r3, r3, r2
 3907 0072 9B00     		lsls	r3, r3, #2
 3908 0074 094A     		ldr	r2, .L255+4
 3909 0076 1A44     		add	r2, r2, r3
 3910 0078 FB68     		ldr	r3, [r7, #12]
 3911 007a 0433     		adds	r3, r3, #4
 3912 007c 1046     		mov	r0, r2
 3913 007e 1946     		mov	r1, r3
 3914 0080 FFF7FEFF 		bl	vListInsertEnd
 3915 0084 04E0     		b	.L251
 3916              	.L253:
2429:FreeRTOS/Source/tasks.c **** 			}
2430:FreeRTOS/Source/tasks.c **** 			else
2431:FreeRTOS/Source/tasks.c **** 			{
2432:FreeRTOS/Source/tasks.c **** 				/* Just inherit the priority. */
2433:FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3917              		.loc 1 2433 0 is_stmt 1
 3918 0086 044B     		ldr	r3, .L255
 3919 0088 1B68     		ldr	r3, [r3]
 3920 008a DA6A     		ldr	r2, [r3, #44]
 3921 008c FB68     		ldr	r3, [r7, #12]
 3922 008e DA62     		str	r2, [r3, #44]
 3923              	.L251:
2434:FreeRTOS/Source/tasks.c **** 			}
2435:FreeRTOS/Source/tasks.c **** 		}
2436:FreeRTOS/Source/tasks.c **** 	}
 3924              		.loc 1 2436 0
 3925 0090 1037     		adds	r7, r7, #16
 3926 0092 BD46     		mov	sp, r7
 3927              		@ sp needed
 3928 0094 80BD     		pop	{r7, pc}
 3929              	.L256:
 3930 0096 00BF     		.align	2
 3931              	.L255:
 3932 0098 00000000 		.word	pxCurrentTCB
 3933 009c 00000000 		.word	pxReadyTasksLists
 3934 00a0 00000000 		.word	uxTopReadyPriority
 3935              		.cfi_endproc
 3936              	.LFE150:
 3938              		.section	.text.vTaskPriorityDisinherit,"ax",%progbits
 3939              		.align	2
 3940              		.global	vTaskPriorityDisinherit
 3941              		.thumb
 3942              		.thumb_func
 3944              	vTaskPriorityDisinherit:
 3945              	.LFB151:
2437:FreeRTOS/Source/tasks.c **** 
2438:FreeRTOS/Source/tasks.c **** #endif
2439:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2440:FreeRTOS/Source/tasks.c **** 
2441:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2442:FreeRTOS/Source/tasks.c **** 
2443:FreeRTOS/Source/tasks.c **** 	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
2444:FreeRTOS/Source/tasks.c **** 	{
 3946              		.loc 1 2444 0
 3947              		.cfi_startproc
 3948              		@ args = 0, pretend = 0, frame = 16
 3949              		@ frame_needed = 1, uses_anonymous_args = 0
 3950 0000 80B5     		push	{r7, lr}
 3951              	.LCFI118:
 3952              		.cfi_def_cfa_offset 8
 3953              		.cfi_offset 7, -8
 3954              		.cfi_offset 14, -4
 3955 0002 84B0     		sub	sp, sp, #16
 3956              	.LCFI119:
 3957              		.cfi_def_cfa_offset 24
 3958 0004 00AF     		add	r7, sp, #0
 3959              	.LCFI120:
 3960              		.cfi_def_cfa_register 7
 3961 0006 7860     		str	r0, [r7, #4]
2445:FreeRTOS/Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3962              		.loc 1 2445 0
 3963 0008 7B68     		ldr	r3, [r7, #4]
 3964 000a FB60     		str	r3, [r7, #12]
2446:FreeRTOS/Source/tasks.c **** 
2447:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
 3965              		.loc 1 2447 0
 3966 000c 7B68     		ldr	r3, [r7, #4]
 3967 000e 002B     		cmp	r3, #0
 3968 0010 2CD0     		beq	.L257
2448:FreeRTOS/Source/tasks.c **** 		{
2449:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 3969              		.loc 1 2449 0
 3970 0012 FB68     		ldr	r3, [r7, #12]
 3971 0014 DA6A     		ldr	r2, [r3, #44]
 3972 0016 FB68     		ldr	r3, [r7, #12]
 3973 0018 5B6C     		ldr	r3, [r3, #68]
 3974 001a 9A42     		cmp	r2, r3
 3975 001c 26D0     		beq	.L257
2450:FreeRTOS/Source/tasks.c **** 			{
2451:FreeRTOS/Source/tasks.c **** 				/* We must be the running task to be able to give the mutex back.
2452:FreeRTOS/Source/tasks.c **** 				Remove ourselves from the ready list we currently appear in. */
2453:FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 3976              		.loc 1 2453 0
 3977 001e FB68     		ldr	r3, [r7, #12]
 3978 0020 0433     		adds	r3, r3, #4
 3979 0022 1846     		mov	r0, r3
 3980 0024 FFF7FEFF 		bl	vListRemove
2454:FreeRTOS/Source/tasks.c **** 
2455:FreeRTOS/Source/tasks.c **** 				/* Disinherit the priority before adding ourselves into the new
2456:FreeRTOS/Source/tasks.c **** 				ready list. */
2457:FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
 3981              		.loc 1 2457 0
 3982 0028 FB68     		ldr	r3, [r7, #12]
 3983 002a 5A6C     		ldr	r2, [r3, #68]
 3984 002c FB68     		ldr	r3, [r7, #12]
 3985 002e DA62     		str	r2, [r3, #44]
2458:FreeRTOS/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 3986              		.loc 1 2458 0
 3987 0030 FB68     		ldr	r3, [r7, #12]
 3988 0032 DB6A     		ldr	r3, [r3, #44]
 3989 0034 C3F10502 		rsb	r2, r3, #5
 3990 0038 FB68     		ldr	r3, [r7, #12]
 3991 003a 9A61     		str	r2, [r3, #24]
2459:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 3992              		.loc 1 2459 0
 3993 003c FB68     		ldr	r3, [r7, #12]
 3994 003e DA6A     		ldr	r2, [r3, #44]
 3995 0040 0C4B     		ldr	r3, .L260
 3996 0042 1B68     		ldr	r3, [r3]
 3997 0044 9A42     		cmp	r2, r3
 3998 0046 03D9     		bls	.L259
 3999              		.loc 1 2459 0 is_stmt 0 discriminator 1
 4000 0048 FB68     		ldr	r3, [r7, #12]
 4001 004a DA6A     		ldr	r2, [r3, #44]
 4002 004c 094B     		ldr	r3, .L260
 4003 004e 1A60     		str	r2, [r3]
 4004              	.L259:
 4005              		.loc 1 2459 0 discriminator 2
 4006 0050 FB68     		ldr	r3, [r7, #12]
 4007 0052 DA6A     		ldr	r2, [r3, #44]
 4008 0054 1346     		mov	r3, r2
 4009 0056 9B00     		lsls	r3, r3, #2
 4010 0058 1344     		add	r3, r3, r2
 4011 005a 9B00     		lsls	r3, r3, #2
 4012 005c 064A     		ldr	r2, .L260+4
 4013 005e 1A44     		add	r2, r2, r3
 4014 0060 FB68     		ldr	r3, [r7, #12]
 4015 0062 0433     		adds	r3, r3, #4
 4016 0064 1046     		mov	r0, r2
 4017 0066 1946     		mov	r1, r3
 4018 0068 FFF7FEFF 		bl	vListInsertEnd
 4019              	.L257:
2460:FreeRTOS/Source/tasks.c **** 			}
2461:FreeRTOS/Source/tasks.c **** 		}
2462:FreeRTOS/Source/tasks.c **** 	}
 4020              		.loc 1 2462 0 is_stmt 1
 4021 006c 1037     		adds	r7, r7, #16
 4022 006e BD46     		mov	sp, r7
 4023              		@ sp needed
 4024 0070 80BD     		pop	{r7, pc}
 4025              	.L261:
 4026 0072 00BF     		.align	2
 4027              	.L260:
 4028 0074 00000000 		.word	uxTopReadyPriority
 4029 0078 00000000 		.word	pxReadyTasksLists
 4030              		.cfi_endproc
 4031              	.LFE151:
 4033              		.text
 4034              	.Letext0:
 4035              		.file 2 "/home/shihyu/data/STM32F4/gcc-arm-none-eabi-4_8-2013q4/lib/gcc/arm-none-eabi/4.8.3/includ
 4036              		.file 3 "/home/shihyu/data/STM32F4/gcc-arm-none-eabi-4_8-2013q4/arm-none-eabi/include/stdint.h"
 4037              		.file 4 "FreeRTOS/Source/include/projdefs.h"
 4038              		.file 5 "libs/Device/STM32F4xx/Include/stm32f4xx.h"
 4039              		.file 6 "FreeRTOS/Source/include/../../Source/portable/GCC/ARM_CM4F/portmacro.h"
 4040              		.file 7 "FreeRTOS/Source/include/FreeRTOS.h"
 4041              		.file 8 "FreeRTOS/Source/include/list.h"
 4042              		.file 9 "FreeRTOS/Source/include/task.h"
 4043              		.file 10 "libs/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
     /tmp/cc3w68cE.s:24     .bss.pxCurrentTCB:00000000 pxCurrentTCB
     /tmp/cc3w68cE.s:21     .bss.pxCurrentTCB:00000000 $d
     /tmp/cc3w68cE.s:27     .bss.pxReadyTasksLists:00000000 $d
     /tmp/cc3w68cE.s:30     .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
     /tmp/cc3w68cE.s:33     .bss.xDelayedTaskList1:00000000 $d
     /tmp/cc3w68cE.s:36     .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
     /tmp/cc3w68cE.s:39     .bss.xDelayedTaskList2:00000000 $d
     /tmp/cc3w68cE.s:42     .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
     /tmp/cc3w68cE.s:45     .bss.pxDelayedTaskList:00000000 $d
     /tmp/cc3w68cE.s:48     .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
     /tmp/cc3w68cE.s:51     .bss.pxOverflowDelayedTaskList:00000000 $d
     /tmp/cc3w68cE.s:54     .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
     /tmp/cc3w68cE.s:57     .bss.xPendingReadyList:00000000 $d
     /tmp/cc3w68cE.s:60     .bss.xPendingReadyList:00000000 xPendingReadyList
     /tmp/cc3w68cE.s:63     .bss.xTasksWaitingTermination:00000000 $d
     /tmp/cc3w68cE.s:66     .bss.xTasksWaitingTermination:00000000 xTasksWaitingTermination
     /tmp/cc3w68cE.s:69     .bss.uxTasksDeleted:00000000 $d
     /tmp/cc3w68cE.s:72     .bss.uxTasksDeleted:00000000 uxTasksDeleted
     /tmp/cc3w68cE.s:75     .bss.xSuspendedTaskList:00000000 $d
     /tmp/cc3w68cE.s:78     .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
     /tmp/cc3w68cE.s:81     .bss.xIdleTaskHandle:00000000 $d
     /tmp/cc3w68cE.s:84     .bss.xIdleTaskHandle:00000000 xIdleTaskHandle
     /tmp/cc3w68cE.s:87     .bss.uxCurrentNumberOfTasks:00000000 $d
     /tmp/cc3w68cE.s:90     .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
     /tmp/cc3w68cE.s:93     .bss.xTickCount:00000000 $d
     /tmp/cc3w68cE.s:96     .bss.xTickCount:00000000 xTickCount
     /tmp/cc3w68cE.s:99     .bss.uxTopUsedPriority:00000000 $d
     /tmp/cc3w68cE.s:102    .bss.uxTopUsedPriority:00000000 uxTopUsedPriority
     /tmp/cc3w68cE.s:105    .bss.uxTopReadyPriority:00000000 $d
     /tmp/cc3w68cE.s:108    .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
     /tmp/cc3w68cE.s:111    .bss.xSchedulerRunning:00000000 $d
     /tmp/cc3w68cE.s:114    .bss.xSchedulerRunning:00000000 xSchedulerRunning
     /tmp/cc3w68cE.s:117    .bss.uxSchedulerSuspended:00000000 $d
     /tmp/cc3w68cE.s:120    .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
     /tmp/cc3w68cE.s:123    .bss.uxMissedTicks:00000000 $d
     /tmp/cc3w68cE.s:126    .bss.uxMissedTicks:00000000 uxMissedTicks
     /tmp/cc3w68cE.s:129    .bss.xMissedYield:00000000 $d
     /tmp/cc3w68cE.s:132    .bss.xMissedYield:00000000 xMissedYield
     /tmp/cc3w68cE.s:135    .bss.xNumOfOverflows:00000000 $d
     /tmp/cc3w68cE.s:138    .bss.xNumOfOverflows:00000000 xNumOfOverflows
     /tmp/cc3w68cE.s:141    .bss.uxTaskNumber:00000000 $d
     /tmp/cc3w68cE.s:144    .bss.uxTaskNumber:00000000 uxTaskNumber
     /tmp/cc3w68cE.s:147    .data.xNextTaskUnblockTime:00000000 $d
     /tmp/cc3w68cE.s:150    .data.xNextTaskUnblockTime:00000000 xNextTaskUnblockTime
     /tmp/cc3w68cE.s:153    .bss.pcStatsString:00000000 $d
     /tmp/cc3w68cE.s:156    .bss.pcStatsString:00000000 pcStatsString
     /tmp/cc3w68cE.s:159    .bss.ulTaskSwitchedInTime:00000000 $d
     /tmp/cc3w68cE.s:162    .bss.ulTaskSwitchedInTime:00000000 ulTaskSwitchedInTime
     /tmp/cc3w68cE.s:165    .text.xTaskGenericCreate:00000000 $t
     /tmp/cc3w68cE.s:170    .text.xTaskGenericCreate:00000000 xTaskGenericCreate
     /tmp/cc3w68cE.s:3331   .text.prvAllocateTCBAndStack:00000000 prvAllocateTCBAndStack
     /tmp/cc3w68cE.s:2978   .text.prvInitialiseTCBVariables:00000000 prvInitialiseTCBVariables
     /tmp/cc3w68cE.s:3070   .text.prvInitialiseTaskLists:00000000 prvInitialiseTaskLists
     /tmp/cc3w68cE.s:373    .text.xTaskGenericCreate:00000134 $d
     /tmp/cc3w68cE.s:384    .text.vTaskDelete:00000000 $t
     /tmp/cc3w68cE.s:389    .text.vTaskDelete:00000000 vTaskDelete
     /tmp/cc3w68cE.s:489    .text.vTaskDelete:00000084 $d
     /tmp/cc3w68cE.s:498    .text.vTaskDelayUntil:00000000 $t
     /tmp/cc3w68cE.s:503    .text.vTaskDelayUntil:00000000 vTaskDelayUntil
     /tmp/cc3w68cE.s:1464   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
     /tmp/cc3w68cE.s:3250   .text.prvAddCurrentTaskToDelayedList:00000000 prvAddCurrentTaskToDelayedList
     /tmp/cc3w68cE.s:1502   .text.xTaskResumeAll:00000000 xTaskResumeAll
     /tmp/cc3w68cE.s:610    .text.vTaskDelayUntil:00000090 $d
     /tmp/cc3w68cE.s:616    .text.vTaskDelay:00000000 $t
     /tmp/cc3w68cE.s:621    .text.vTaskDelay:00000000 vTaskDelay
     /tmp/cc3w68cE.s:682    .text.vTaskDelay:00000048 $d
     /tmp/cc3w68cE.s:688    .text.uxTaskPriorityGet:00000000 $t
     /tmp/cc3w68cE.s:693    .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
     /tmp/cc3w68cE.s:744    .text.uxTaskPriorityGet:00000030 $d
     /tmp/cc3w68cE.s:749    .text.vTaskPrioritySet:00000000 $t
     /tmp/cc3w68cE.s:754    .text.vTaskPrioritySet:00000000 vTaskPrioritySet
     /tmp/cc3w68cE.s:924    .text.vTaskPrioritySet:000000ec $d
     /tmp/cc3w68cE.s:931    .text.vTaskSuspend:00000000 $t
     /tmp/cc3w68cE.s:936    .text.vTaskSuspend:00000000 vTaskSuspend
     /tmp/cc3w68cE.s:2414   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
     /tmp/cc3w68cE.s:1041   .text.vTaskSuspend:00000088 $d
     /tmp/cc3w68cE.s:1049   .text.xTaskIsTaskSuspended:00000000 $t
     /tmp/cc3w68cE.s:1054   .text.xTaskIsTaskSuspended:00000000 xTaskIsTaskSuspended
     /tmp/cc3w68cE.s:1111   .text.xTaskIsTaskSuspended:00000040 $d
     /tmp/cc3w68cE.s:1117   .text.vTaskResume:00000000 $t
     /tmp/cc3w68cE.s:1122   .text.vTaskResume:00000000 vTaskResume
     /tmp/cc3w68cE.s:1215   .text.vTaskResume:00000084 $d
     /tmp/cc3w68cE.s:1222   .text.xTaskResumeFromISR:00000000 $t
     /tmp/cc3w68cE.s:1227   .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
     /tmp/cc3w68cE.s:1326   .text.xTaskResumeFromISR:0000008c $d
     /tmp/cc3w68cE.s:1335   .rodata:00000000 $d
     /tmp/cc3w68cE.s:1339   .text.vTaskStartScheduler:00000000 $t
     /tmp/cc3w68cE.s:1344   .text.vTaskStartScheduler:00000000 vTaskStartScheduler
     /tmp/cc3w68cE.s:1408   .text.vTaskStartScheduler:00000050 $d
     /tmp/cc3w68cE.s:2934   .text.prvIdleTask:00000000 prvIdleTask
     /tmp/cc3w68cE.s:1417   .text.vTaskEndScheduler:00000000 $t
     /tmp/cc3w68cE.s:1422   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
     /tmp/cc3w68cE.s:1454   .text.vTaskEndScheduler:00000018 $d
     /tmp/cc3w68cE.s:1459   .text.vTaskSuspendAll:00000000 $t
     /tmp/cc3w68cE.s:1492   .text.vTaskSuspendAll:00000018 $d
     /tmp/cc3w68cE.s:1497   .text.xTaskResumeAll:00000000 $t
     /tmp/cc3w68cE.s:2025   .text.vTaskIncrementTick:00000000 vTaskIncrementTick
     /tmp/cc3w68cE.s:1659   .text.xTaskResumeAll:000000d4 $d
     /tmp/cc3w68cE.s:1671   .text.xTaskGetTickCount:00000000 $t
     /tmp/cc3w68cE.s:1676   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
     /tmp/cc3w68cE.s:1712   .text.xTaskGetTickCount:00000020 $d
     /tmp/cc3w68cE.s:1717   .text.xTaskGetTickCountFromISR:00000000 $t
     /tmp/cc3w68cE.s:1722   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
     /tmp/cc3w68cE.s:1771   .text.xTaskGetTickCountFromISR:00000030 $d
     /tmp/cc3w68cE.s:1776   .text.uxTaskGetNumberOfTasks:00000000 $t
     /tmp/cc3w68cE.s:1781   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
     /tmp/cc3w68cE.s:1807   .text.uxTaskGetNumberOfTasks:00000014 $d
     /tmp/cc3w68cE.s:1816   .text.vTaskGetRunTimeStats:00000000 $t
     /tmp/cc3w68cE.s:1821   .text.vTaskGetRunTimeStats:00000000 vTaskGetRunTimeStats
     /tmp/cc3w68cE.s:3427   .text.prvGenerateRunTimeStatsForTasksInList:00000000 prvGenerateRunTimeStatsForTasksInList
     /tmp/cc3w68cE.s:1972   .text.vTaskGetRunTimeStats:000000e8 $d
     /tmp/cc3w68cE.s:1984   .text.xTaskGetIdleTaskHandle:00000000 $t
     /tmp/cc3w68cE.s:1989   .text.xTaskGetIdleTaskHandle:00000000 xTaskGetIdleTaskHandle
     /tmp/cc3w68cE.s:2015   .text.xTaskGetIdleTaskHandle:00000014 $d
     /tmp/cc3w68cE.s:2020   .text.vTaskIncrementTick:00000000 $t
     /tmp/cc3w68cE.s:2205   .text.vTaskIncrementTick:00000108 $d
     /tmp/cc3w68cE.s:2218   .text.vTaskSetApplicationTaskTag:00000000 $t
     /tmp/cc3w68cE.s:2223   .text.vTaskSetApplicationTaskTag:00000000 vTaskSetApplicationTaskTag
     /tmp/cc3w68cE.s:2272   .text.vTaskSetApplicationTaskTag:00000030 $d
     /tmp/cc3w68cE.s:2277   .text.xTaskGetApplicationTaskTag:00000000 $t
     /tmp/cc3w68cE.s:2282   .text.xTaskGetApplicationTaskTag:00000000 xTaskGetApplicationTaskTag
     /tmp/cc3w68cE.s:2333   .text.xTaskGetApplicationTaskTag:00000034 $d
     /tmp/cc3w68cE.s:2338   .text.xTaskCallApplicationTaskHook:00000000 $t
     /tmp/cc3w68cE.s:2343   .text.xTaskCallApplicationTaskHook:00000000 xTaskCallApplicationTaskHook
     /tmp/cc3w68cE.s:2404   .text.xTaskCallApplicationTaskHook:00000040 $d
     /tmp/cc3w68cE.s:2409   .text.vTaskSwitchContext:00000000 $t
     /tmp/cc3w68cE.s:2537   .text.vTaskSwitchContext:000000a8 $d
     /tmp/cc3w68cE.s:2548   .text.vTaskPlaceOnEventList:00000000 $t
     /tmp/cc3w68cE.s:2553   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
     /tmp/cc3w68cE.s:2616   .text.vTaskPlaceOnEventList:00000054 $d
     /tmp/cc3w68cE.s:2623   .text.xTaskRemoveFromEventList:00000000 $t
     /tmp/cc3w68cE.s:2628   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
     /tmp/cc3w68cE.s:2730   .text.xTaskRemoveFromEventList:0000008c $d
     /tmp/cc3w68cE.s:2739   .text.vTaskSetTimeOutState:00000000 $t
     /tmp/cc3w68cE.s:2744   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
     /tmp/cc3w68cE.s:2781   .text.vTaskSetTimeOutState:00000024 $d
     /tmp/cc3w68cE.s:2787   .text.xTaskCheckForTimeOut:00000000 $t
     /tmp/cc3w68cE.s:2792   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
     /tmp/cc3w68cE.s:2888   .text.xTaskCheckForTimeOut:00000080 $d
     /tmp/cc3w68cE.s:2894   .text.vTaskMissedYield:00000000 $t
     /tmp/cc3w68cE.s:2899   .text.vTaskMissedYield:00000000 vTaskMissedYield
     /tmp/cc3w68cE.s:2925   .text.vTaskMissedYield:00000014 $d
     /tmp/cc3w68cE.s:2930   .text.prvIdleTask:00000000 $t
     /tmp/cc3w68cE.s:3158   .text.prvCheckTasksWaitingTermination:00000000 prvCheckTasksWaitingTermination
     /tmp/cc3w68cE.s:2969   .text.prvIdleTask:0000001c $d
     /tmp/cc3w68cE.s:2974   .text.prvInitialiseTCBVariables:00000000 $t
     /tmp/cc3w68cE.s:3066   .text.prvInitialiseTaskLists:00000000 $t
     /tmp/cc3w68cE.s:3142   .text.prvInitialiseTaskLists:0000005c $d
     /tmp/cc3w68cE.s:3154   .text.prvCheckTasksWaitingTermination:00000000 $t
     /tmp/cc3w68cE.s:3745   .text.prvDeleteTCB:00000000 prvDeleteTCB
     /tmp/cc3w68cE.s:3239   .text.prvCheckTasksWaitingTermination:00000068 $d
     /tmp/cc3w68cE.s:3246   .text.prvAddCurrentTaskToDelayedList:00000000 $t
     /tmp/cc3w68cE.s:3318   .text.prvAddCurrentTaskToDelayedList:00000058 $d
     /tmp/cc3w68cE.s:3327   .text.prvAllocateTCBAndStack:00000000 $t
     /tmp/cc3w68cE.s:3423   .text.prvGenerateRunTimeStatsForTasksInList:00000000 $t
     /tmp/cc3w68cE.s:3625   .text.usTaskCheckFreeStackSpace:00000000 usTaskCheckFreeStackSpace
     /tmp/cc3w68cE.s:3613   .text.prvGenerateRunTimeStatsForTasksInList:00000138 $d
     /tmp/cc3w68cE.s:3621   .text.usTaskCheckFreeStackSpace:00000000 $t
     /tmp/cc3w68cE.s:3679   .text.uxTaskGetStackHighWaterMark:00000000 $t
     /tmp/cc3w68cE.s:3684   .text.uxTaskGetStackHighWaterMark:00000000 uxTaskGetStackHighWaterMark
     /tmp/cc3w68cE.s:3736   .text.uxTaskGetStackHighWaterMark:00000034 $d
     /tmp/cc3w68cE.s:3741   .text.prvDeleteTCB:00000000 $t
     /tmp/cc3w68cE.s:3780   .text.xTaskGetCurrentTaskHandle:00000000 $t
     /tmp/cc3w68cE.s:3785   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
     /tmp/cc3w68cE.s:3818   .text.xTaskGetCurrentTaskHandle:0000001c $d
     /tmp/cc3w68cE.s:3823   .text.vTaskPriorityInherit:00000000 $t
     /tmp/cc3w68cE.s:3828   .text.vTaskPriorityInherit:00000000 vTaskPriorityInherit
     /tmp/cc3w68cE.s:3932   .text.vTaskPriorityInherit:00000098 $d
     /tmp/cc3w68cE.s:3939   .text.vTaskPriorityDisinherit:00000000 $t
     /tmp/cc3w68cE.s:3944   .text.vTaskPriorityDisinherit:00000000 vTaskPriorityDisinherit
     /tmp/cc3w68cE.s:4028   .text.vTaskPriorityDisinherit:00000074 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
vPortYieldFromISR
vListRemove
init_us_timer
xPortStartScheduler
vPortEndScheduler
get_us_time
strlen
vListInsert
strncpy
vListInitialiseItem
vListInitialise
malloc
free
memset
sprintf
strcat
